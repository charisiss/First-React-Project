{"ast":null,"code":"'use strict';\n\nconst DataManager = require('./DataManager');\n\nconst {\n  _cleanupSymbol\n} = require('../util/Constants');\n/**\n * Manages the API methods of a data model with a mutable cache of instances.\n * @extends {DataManager}\n * @abstract\n */\n\n\nclass CachedManager extends DataManager {\n  constructor(client, holds, iterable) {\n    super(client, holds);\n    Object.defineProperty(this, '_cache', {\n      value: this.client.options.makeCache(this.constructor, this.holds)\n    });\n    let cleanup = this._cache[_cleanupSymbol]?.();\n\n    if (cleanup) {\n      cleanup = cleanup.bind(this._cache);\n\n      client._cleanups.add(cleanup);\n\n      client._finalizers.register(this, {\n        cleanup,\n        message: `Garbage collection completed on ${this.constructor.name}, ` + `which had a ${this._cache.constructor.name} of ${this.holds.name}.`,\n        name: this.constructor.name\n      });\n    }\n\n    if (iterable) {\n      for (const item of iterable) {\n        this._add(item);\n      }\n    }\n  }\n  /**\n   * The cache of items for this manager.\n   * @type {Collection}\n   * @abstract\n   */\n\n\n  get cache() {\n    return this._cache;\n  }\n\n  _add(data) {\n    let cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let {\n      id,\n      extras = []\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const existing = this.cache.get(id ?? data.id);\n\n    if (existing) {\n      if (cache) {\n        existing._patch(data);\n\n        return existing;\n      }\n\n      const clone = existing._clone();\n\n      clone._patch(data);\n\n      return clone;\n    }\n\n    const entry = this.holds ? new this.holds(this.client, data, ...extras) : data;\n    if (cache) this.cache.set(id ?? entry.id, entry);\n    return entry;\n  }\n\n}\n\nmodule.exports = CachedManager;","map":{"version":3,"names":["DataManager","require","_cleanupSymbol","CachedManager","constructor","client","holds","iterable","Object","defineProperty","value","options","makeCache","cleanup","_cache","bind","_cleanups","add","_finalizers","register","message","name","item","_add","cache","data","id","extras","existing","get","_patch","clone","_clone","entry","set","module","exports"],"sources":["C:/Users/xsxsam/node_modules/discord.js/src/managers/CachedManager.js"],"sourcesContent":["'use strict';\n\nconst DataManager = require('./DataManager');\nconst { _cleanupSymbol } = require('../util/Constants');\n\n/**\n * Manages the API methods of a data model with a mutable cache of instances.\n * @extends {DataManager}\n * @abstract\n */\nclass CachedManager extends DataManager {\n  constructor(client, holds, iterable) {\n    super(client, holds);\n\n    Object.defineProperty(this, '_cache', { value: this.client.options.makeCache(this.constructor, this.holds) });\n\n    let cleanup = this._cache[_cleanupSymbol]?.();\n    if (cleanup) {\n      cleanup = cleanup.bind(this._cache);\n      client._cleanups.add(cleanup);\n      client._finalizers.register(this, {\n        cleanup,\n        message:\n          `Garbage collection completed on ${this.constructor.name}, ` +\n          `which had a ${this._cache.constructor.name} of ${this.holds.name}.`,\n        name: this.constructor.name,\n      });\n    }\n\n    if (iterable) {\n      for (const item of iterable) {\n        this._add(item);\n      }\n    }\n  }\n\n  /**\n   * The cache of items for this manager.\n   * @type {Collection}\n   * @abstract\n   */\n  get cache() {\n    return this._cache;\n  }\n\n  _add(data, cache = true, { id, extras = [] } = {}) {\n    const existing = this.cache.get(id ?? data.id);\n    if (existing) {\n      if (cache) {\n        existing._patch(data);\n        return existing;\n      }\n      const clone = existing._clone();\n      clone._patch(data);\n      return clone;\n    }\n\n    const entry = this.holds ? new this.holds(this.client, data, ...extras) : data;\n    if (cache) this.cache.set(id ?? entry.id, entry);\n    return entry;\n  }\n}\n\nmodule.exports = CachedManager;\n"],"mappings":"AAAA;;AAEA,MAAMA,WAAW,GAAGC,OAAO,CAAC,eAAD,CAA3B;;AACA,MAAM;EAAEC;AAAF,IAAqBD,OAAO,CAAC,mBAAD,CAAlC;AAEA;AACA;AACA;AACA;AACA;;;AACA,MAAME,aAAN,SAA4BH,WAA5B,CAAwC;EACtCI,WAAW,CAACC,MAAD,EAASC,KAAT,EAAgBC,QAAhB,EAA0B;IACnC,MAAMF,MAAN,EAAcC,KAAd;IAEAE,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,QAA5B,EAAsC;MAAEC,KAAK,EAAE,KAAKL,MAAL,CAAYM,OAAZ,CAAoBC,SAApB,CAA8B,KAAKR,WAAnC,EAAgD,KAAKE,KAArD;IAAT,CAAtC;IAEA,IAAIO,OAAO,GAAG,KAAKC,MAAL,CAAYZ,cAAZ,KAAd;;IACA,IAAIW,OAAJ,EAAa;MACXA,OAAO,GAAGA,OAAO,CAACE,IAAR,CAAa,KAAKD,MAAlB,CAAV;;MACAT,MAAM,CAACW,SAAP,CAAiBC,GAAjB,CAAqBJ,OAArB;;MACAR,MAAM,CAACa,WAAP,CAAmBC,QAAnB,CAA4B,IAA5B,EAAkC;QAChCN,OADgC;QAEhCO,OAAO,EACJ,mCAAkC,KAAKhB,WAAL,CAAiBiB,IAAK,IAAzD,GACC,eAAc,KAAKP,MAAL,CAAYV,WAAZ,CAAwBiB,IAAK,OAAM,KAAKf,KAAL,CAAWe,IAAK,GAJpC;QAKhCA,IAAI,EAAE,KAAKjB,WAAL,CAAiBiB;MALS,CAAlC;IAOD;;IAED,IAAId,QAAJ,EAAc;MACZ,KAAK,MAAMe,IAAX,IAAmBf,QAAnB,EAA6B;QAC3B,KAAKgB,IAAL,CAAUD,IAAV;MACD;IACF;EACF;EAED;AACF;AACA;AACA;AACA;;;EACW,IAALE,KAAK,GAAG;IACV,OAAO,KAAKV,MAAZ;EACD;;EAEDS,IAAI,CAACE,IAAD,EAA+C;IAAA,IAAxCD,KAAwC,uEAAhC,IAAgC;IAAA,IAA1B;MAAEE,EAAF;MAAMC,MAAM,GAAG;IAAf,CAA0B,uEAAJ,EAAI;IACjD,MAAMC,QAAQ,GAAG,KAAKJ,KAAL,CAAWK,GAAX,CAAeH,EAAE,IAAID,IAAI,CAACC,EAA1B,CAAjB;;IACA,IAAIE,QAAJ,EAAc;MACZ,IAAIJ,KAAJ,EAAW;QACTI,QAAQ,CAACE,MAAT,CAAgBL,IAAhB;;QACA,OAAOG,QAAP;MACD;;MACD,MAAMG,KAAK,GAAGH,QAAQ,CAACI,MAAT,EAAd;;MACAD,KAAK,CAACD,MAAN,CAAaL,IAAb;;MACA,OAAOM,KAAP;IACD;;IAED,MAAME,KAAK,GAAG,KAAK3B,KAAL,GAAa,IAAI,KAAKA,KAAT,CAAe,KAAKD,MAApB,EAA4BoB,IAA5B,EAAkC,GAAGE,MAArC,CAAb,GAA4DF,IAA1E;IACA,IAAID,KAAJ,EAAW,KAAKA,KAAL,CAAWU,GAAX,CAAeR,EAAE,IAAIO,KAAK,CAACP,EAA3B,EAA+BO,KAA/B;IACX,OAAOA,KAAP;EACD;;AAlDqC;;AAqDxCE,MAAM,CAACC,OAAP,GAAiBjC,aAAjB"},"metadata":{},"sourceType":"script"}