{"ast":null,"code":"'use strict';\n\nconst process = require('node:process');\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst CachedManager = require('./CachedManager');\n\nconst ThreadManager = require('./ThreadManager');\n\nconst {\n  Error\n} = require('../errors');\n\nconst GuildChannel = require('../structures/GuildChannel');\n\nconst PermissionOverwrites = require('../structures/PermissionOverwrites');\n\nconst ThreadChannel = require('../structures/ThreadChannel');\n\nconst {\n  ChannelTypes,\n  ThreadChannelTypes\n} = require('../util/Constants');\n\nlet cacheWarningEmitted = false;\nlet storeChannelDeprecationEmitted = false;\n/**\n * Manages API methods for GuildChannels and stores their cache.\n * @extends {CachedManager}\n */\n\nclass GuildChannelManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, GuildChannel, iterable);\n    const defaultCaching = this._cache.constructor.name === 'Collection' || (this._cache.maxSize === undefined || this._cache.maxSize === Infinity) && (this._cache.sweepFilter === undefined || this._cache.sweepFilter.isDefault);\n\n    if (!cacheWarningEmitted && !defaultCaching) {\n      cacheWarningEmitted = true;\n      process.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, 'UnsupportedCacheOverwriteWarning');\n    }\n    /**\n     * The guild this Manager belongs to\n     * @type {Guild}\n     */\n\n\n    this.guild = guild;\n  }\n  /**\n   * The number of channels in this managers cache excluding thread channels\n   * that do not count towards a guild's maximum channels restriction.\n   * @type {number}\n   * @readonly\n   */\n\n\n  get channelCountWithoutThreads() {\n    return this.cache.reduce((acc, channel) => {\n      if (ThreadChannelTypes.includes(channel.type)) return acc;\n      return ++acc;\n    }, 0);\n  }\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, GuildChannel|ThreadChannel>}\n   * @name GuildChannelManager#cache\n   */\n\n\n  _add(channel) {\n    const existing = this.cache.get(channel.id);\n    if (existing) return existing;\n    this.cache.set(channel.id, channel);\n    return channel;\n  }\n  /**\n   * Data that can be resolved to give a Guild Channel object. This can be:\n   * * A GuildChannel object\n   * * A ThreadChannel object\n   * * A Snowflake\n   * @typedef {GuildChannel|ThreadChannel|Snowflake} GuildChannelResolvable\n   */\n\n  /**\n   * Resolves a GuildChannelResolvable to a Channel object.\n   * @param {GuildChannelResolvable} channel The GuildChannel resolvable to resolve\n   * @returns {?(GuildChannel|ThreadChannel)}\n   */\n\n\n  resolve(channel) {\n    if (channel instanceof ThreadChannel) return super.resolve(channel.id);\n    return super.resolve(channel);\n  }\n  /**\n   * Resolves a GuildChannelResolvable to a channel id.\n   * @param {GuildChannelResolvable} channel The GuildChannel resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n\n  resolveId(channel) {\n    if (channel instanceof ThreadChannel) return super.resolveId(channel.id);\n    return super.resolveId(channel);\n  }\n  /**\n   * Options used to create a new channel in a guild.\n   * @typedef {CategoryCreateChannelOptions} GuildChannelCreateOptions\n   * @property {CategoryChannelResolvable} [parent] Parent of the new channel\n   */\n\n  /**\n   * Creates a new channel in the guild.\n   * @param {string} name The name of the new channel\n   * @param {GuildChannelCreateOptions} [options={}] Options for creating the new channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Create a new text channel\n   * guild.channels.create('new-general', { reason: 'Needed a cool new channel' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Create a new channel with permission overwrites\n   * guild.channels.create('new-voice', {\n   *   type: 'GUILD_VOICE',\n   *   permissionOverwrites: [\n   *      {\n   *        id: message.author.id,\n   *        deny: [Permissions.FLAGS.VIEW_CHANNEL],\n   *     },\n   *   ],\n   * })\n   */\n\n\n  async create(name) {\n    let {\n      type,\n      topic,\n      nsfw,\n      bitrate,\n      userLimit,\n      parent,\n      permissionOverwrites,\n      position,\n      rateLimitPerUser,\n      rtcRegion,\n      reason\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    parent &&= this.client.channels.resolveId(parent);\n    permissionOverwrites &&= permissionOverwrites.map(o => PermissionOverwrites.resolve(o, this.guild));\n    const intType = typeof type === 'number' ? type : ChannelTypes[type] ?? ChannelTypes.GUILD_TEXT;\n\n    if (intType === ChannelTypes.GUILD_STORE && !storeChannelDeprecationEmitted) {\n      storeChannelDeprecationEmitted = true;\n      process.emitWarning( // eslint-disable-next-line max-len\n      'Creating store channels is deprecated by Discord and will stop working in March 2022. Check the docs for more info.', 'DeprecationWarning');\n    }\n\n    const data = await this.client.api.guilds(this.guild.id).channels.post({\n      data: {\n        name,\n        topic,\n        type: intType,\n        nsfw,\n        bitrate,\n        user_limit: userLimit,\n        parent_id: parent,\n        position,\n        permission_overwrites: permissionOverwrites,\n        rate_limit_per_user: rateLimitPerUser,\n        rtc_region: rtcRegion\n      },\n      reason\n    });\n    return this.client.actions.ChannelCreate.handle(data).channel;\n  }\n  /**\n   * Obtains one or more guild channels from Discord, or the channel cache if they're already available.\n   * @param {Snowflake} [id] The channel's id\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<?GuildChannel|Collection<Snowflake, GuildChannel>>}\n   * @example\n   * // Fetch all channels from the guild (excluding threads)\n   * message.guild.channels.fetch()\n   *   .then(channels => console.log(`There are ${channels.size} channels.`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single channel\n   * message.guild.channels.fetch('222197033908436994')\n   *   .then(channel => console.log(`The channel name is: ${channel.name}`))\n   *   .catch(console.error);\n   */\n\n\n  async fetch(id) {\n    let {\n      cache = true,\n      force = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (id && !force) {\n      const existing = this.cache.get(id);\n      if (existing) return existing;\n    }\n\n    if (id) {\n      const data = await this.client.api.channels(id).get(); // Since this is the guild manager, throw if on a different guild\n\n      if (this.guild.id !== data.guild_id) throw new Error('GUILD_CHANNEL_UNOWNED');\n      return this.client.channels._add(data, this.guild, {\n        cache\n      });\n    }\n\n    const data = await this.client.api.guilds(this.guild.id).channels.get();\n    const channels = new Collection();\n\n    for (const channel of data) channels.set(channel.id, this.client.channels._add(channel, this.guild, {\n      cache\n    }));\n\n    return channels;\n  }\n  /**\n   * Batch-updates the guild's channels' positions.\n   * <info>Only one channel's parent can be changed at a time</info>\n   * @param {ChannelPosition[]} channelPositions Channel positions to update\n   * @returns {Promise<Guild>}\n   * @example\n   * guild.channels.setPositions([{ channel: channelId, position: newChannelIndex }])\n   *   .then(guild => console.log(`Updated channel positions for ${guild}`))\n   *   .catch(console.error);\n   */\n\n\n  async setPositions(channelPositions) {\n    channelPositions = channelPositions.map(r => ({\n      id: this.client.channels.resolveId(r.channel),\n      position: r.position,\n      lock_permissions: r.lockPermissions,\n      parent_id: typeof r.parent !== 'undefined' ? this.channels.resolveId(r.parent) : undefined\n    }));\n    await this.client.api.guilds(this.guild.id).channels.patch({\n      data: channelPositions\n    });\n    return this.client.actions.GuildChannelsPositionUpdate.handle({\n      guild_id: this.guild.id,\n      channels: channelPositions\n    }).guild;\n  }\n  /**\n   * Obtains all active thread channels in the guild from Discord\n   * @param {boolean} [cache=true] Whether to cache the fetched data\n   * @returns {Promise<FetchedThreads>}\n   * @example\n   * // Fetch all threads from the guild\n   * message.guild.channels.fetchActiveThreads()\n   *   .then(fetched => console.log(`There are ${fetched.threads.size} threads.`))\n   *   .catch(console.error);\n   */\n\n\n  async fetchActiveThreads() {\n    let cache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    const raw = await this.client.api.guilds(this.guild.id).threads.active.get();\n    return ThreadManager._mapThreads(raw, this.client, {\n      guild: this.guild,\n      cache\n    });\n  }\n\n}\n\nmodule.exports = GuildChannelManager;","map":{"version":3,"names":["process","require","Collection","CachedManager","ThreadManager","Error","GuildChannel","PermissionOverwrites","ThreadChannel","ChannelTypes","ThreadChannelTypes","cacheWarningEmitted","storeChannelDeprecationEmitted","GuildChannelManager","constructor","guild","iterable","client","defaultCaching","_cache","name","maxSize","undefined","Infinity","sweepFilter","isDefault","emitWarning","channelCountWithoutThreads","cache","reduce","acc","channel","includes","type","_add","existing","get","id","set","resolve","resolveId","create","topic","nsfw","bitrate","userLimit","parent","permissionOverwrites","position","rateLimitPerUser","rtcRegion","reason","channels","map","o","intType","GUILD_TEXT","GUILD_STORE","data","api","guilds","post","user_limit","parent_id","permission_overwrites","rate_limit_per_user","rtc_region","actions","ChannelCreate","handle","fetch","force","guild_id","setPositions","channelPositions","r","lock_permissions","lockPermissions","patch","GuildChannelsPositionUpdate","fetchActiveThreads","raw","threads","active","_mapThreads","module","exports"],"sources":["C:/Users/xsxsam/node_modules/discord.js/src/managers/GuildChannelManager.js"],"sourcesContent":["'use strict';\n\nconst process = require('node:process');\nconst { Collection } = require('@discordjs/collection');\nconst CachedManager = require('./CachedManager');\nconst ThreadManager = require('./ThreadManager');\nconst { Error } = require('../errors');\nconst GuildChannel = require('../structures/GuildChannel');\nconst PermissionOverwrites = require('../structures/PermissionOverwrites');\nconst ThreadChannel = require('../structures/ThreadChannel');\nconst { ChannelTypes, ThreadChannelTypes } = require('../util/Constants');\n\nlet cacheWarningEmitted = false;\nlet storeChannelDeprecationEmitted = false;\n\n/**\n * Manages API methods for GuildChannels and stores their cache.\n * @extends {CachedManager}\n */\nclass GuildChannelManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, GuildChannel, iterable);\n    const defaultCaching =\n      this._cache.constructor.name === 'Collection' ||\n      ((this._cache.maxSize === undefined || this._cache.maxSize === Infinity) &&\n        (this._cache.sweepFilter === undefined || this._cache.sweepFilter.isDefault));\n    if (!cacheWarningEmitted && !defaultCaching) {\n      cacheWarningEmitted = true;\n      process.emitWarning(\n        `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,\n        'UnsupportedCacheOverwriteWarning',\n      );\n    }\n\n    /**\n     * The guild this Manager belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The number of channels in this managers cache excluding thread channels\n   * that do not count towards a guild's maximum channels restriction.\n   * @type {number}\n   * @readonly\n   */\n  get channelCountWithoutThreads() {\n    return this.cache.reduce((acc, channel) => {\n      if (ThreadChannelTypes.includes(channel.type)) return acc;\n      return ++acc;\n    }, 0);\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, GuildChannel|ThreadChannel>}\n   * @name GuildChannelManager#cache\n   */\n\n  _add(channel) {\n    const existing = this.cache.get(channel.id);\n    if (existing) return existing;\n    this.cache.set(channel.id, channel);\n    return channel;\n  }\n\n  /**\n   * Data that can be resolved to give a Guild Channel object. This can be:\n   * * A GuildChannel object\n   * * A ThreadChannel object\n   * * A Snowflake\n   * @typedef {GuildChannel|ThreadChannel|Snowflake} GuildChannelResolvable\n   */\n\n  /**\n   * Resolves a GuildChannelResolvable to a Channel object.\n   * @param {GuildChannelResolvable} channel The GuildChannel resolvable to resolve\n   * @returns {?(GuildChannel|ThreadChannel)}\n   */\n  resolve(channel) {\n    if (channel instanceof ThreadChannel) return super.resolve(channel.id);\n    return super.resolve(channel);\n  }\n\n  /**\n   * Resolves a GuildChannelResolvable to a channel id.\n   * @param {GuildChannelResolvable} channel The GuildChannel resolvable to resolve\n   * @returns {?Snowflake}\n   */\n  resolveId(channel) {\n    if (channel instanceof ThreadChannel) return super.resolveId(channel.id);\n    return super.resolveId(channel);\n  }\n\n  /**\n   * Options used to create a new channel in a guild.\n   * @typedef {CategoryCreateChannelOptions} GuildChannelCreateOptions\n   * @property {CategoryChannelResolvable} [parent] Parent of the new channel\n   */\n\n  /**\n   * Creates a new channel in the guild.\n   * @param {string} name The name of the new channel\n   * @param {GuildChannelCreateOptions} [options={}] Options for creating the new channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Create a new text channel\n   * guild.channels.create('new-general', { reason: 'Needed a cool new channel' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Create a new channel with permission overwrites\n   * guild.channels.create('new-voice', {\n   *   type: 'GUILD_VOICE',\n   *   permissionOverwrites: [\n   *      {\n   *        id: message.author.id,\n   *        deny: [Permissions.FLAGS.VIEW_CHANNEL],\n   *     },\n   *   ],\n   * })\n   */\n  async create(\n    name,\n    {\n      type,\n      topic,\n      nsfw,\n      bitrate,\n      userLimit,\n      parent,\n      permissionOverwrites,\n      position,\n      rateLimitPerUser,\n      rtcRegion,\n      reason,\n    } = {},\n  ) {\n    parent &&= this.client.channels.resolveId(parent);\n    permissionOverwrites &&= permissionOverwrites.map(o => PermissionOverwrites.resolve(o, this.guild));\n    const intType = typeof type === 'number' ? type : ChannelTypes[type] ?? ChannelTypes.GUILD_TEXT;\n\n    if (intType === ChannelTypes.GUILD_STORE && !storeChannelDeprecationEmitted) {\n      storeChannelDeprecationEmitted = true;\n      process.emitWarning(\n        // eslint-disable-next-line max-len\n        'Creating store channels is deprecated by Discord and will stop working in March 2022. Check the docs for more info.',\n        'DeprecationWarning',\n      );\n    }\n\n    const data = await this.client.api.guilds(this.guild.id).channels.post({\n      data: {\n        name,\n        topic,\n        type: intType,\n        nsfw,\n        bitrate,\n        user_limit: userLimit,\n        parent_id: parent,\n        position,\n        permission_overwrites: permissionOverwrites,\n        rate_limit_per_user: rateLimitPerUser,\n        rtc_region: rtcRegion,\n      },\n      reason,\n    });\n    return this.client.actions.ChannelCreate.handle(data).channel;\n  }\n\n  /**\n   * Obtains one or more guild channels from Discord, or the channel cache if they're already available.\n   * @param {Snowflake} [id] The channel's id\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<?GuildChannel|Collection<Snowflake, GuildChannel>>}\n   * @example\n   * // Fetch all channels from the guild (excluding threads)\n   * message.guild.channels.fetch()\n   *   .then(channels => console.log(`There are ${channels.size} channels.`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single channel\n   * message.guild.channels.fetch('222197033908436994')\n   *   .then(channel => console.log(`The channel name is: ${channel.name}`))\n   *   .catch(console.error);\n   */\n  async fetch(id, { cache = true, force = false } = {}) {\n    if (id && !force) {\n      const existing = this.cache.get(id);\n      if (existing) return existing;\n    }\n\n    if (id) {\n      const data = await this.client.api.channels(id).get();\n      // Since this is the guild manager, throw if on a different guild\n      if (this.guild.id !== data.guild_id) throw new Error('GUILD_CHANNEL_UNOWNED');\n      return this.client.channels._add(data, this.guild, { cache });\n    }\n\n    const data = await this.client.api.guilds(this.guild.id).channels.get();\n    const channels = new Collection();\n    for (const channel of data) channels.set(channel.id, this.client.channels._add(channel, this.guild, { cache }));\n    return channels;\n  }\n\n  /**\n   * Batch-updates the guild's channels' positions.\n   * <info>Only one channel's parent can be changed at a time</info>\n   * @param {ChannelPosition[]} channelPositions Channel positions to update\n   * @returns {Promise<Guild>}\n   * @example\n   * guild.channels.setPositions([{ channel: channelId, position: newChannelIndex }])\n   *   .then(guild => console.log(`Updated channel positions for ${guild}`))\n   *   .catch(console.error);\n   */\n  async setPositions(channelPositions) {\n    channelPositions = channelPositions.map(r => ({\n      id: this.client.channels.resolveId(r.channel),\n      position: r.position,\n      lock_permissions: r.lockPermissions,\n      parent_id: typeof r.parent !== 'undefined' ? this.channels.resolveId(r.parent) : undefined,\n    }));\n\n    await this.client.api.guilds(this.guild.id).channels.patch({ data: channelPositions });\n    return this.client.actions.GuildChannelsPositionUpdate.handle({\n      guild_id: this.guild.id,\n      channels: channelPositions,\n    }).guild;\n  }\n\n  /**\n   * Obtains all active thread channels in the guild from Discord\n   * @param {boolean} [cache=true] Whether to cache the fetched data\n   * @returns {Promise<FetchedThreads>}\n   * @example\n   * // Fetch all threads from the guild\n   * message.guild.channels.fetchActiveThreads()\n   *   .then(fetched => console.log(`There are ${fetched.threads.size} threads.`))\n   *   .catch(console.error);\n   */\n  async fetchActiveThreads(cache = true) {\n    const raw = await this.client.api.guilds(this.guild.id).threads.active.get();\n    return ThreadManager._mapThreads(raw, this.client, { guild: this.guild, cache });\n  }\n}\n\nmodule.exports = GuildChannelManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}