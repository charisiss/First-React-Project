{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('node:events');\n\nconst fs = require('node:fs');\n\nconst path = require('node:path');\n\nconst process = require('node:process');\n\nconst {\n  setTimeout: sleep\n} = require('node:timers/promises');\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst Shard = require('./Shard');\n\nconst {\n  Error,\n  TypeError,\n  RangeError\n} = require('../errors');\n\nconst Util = require('../util/Util');\n/**\n * This is a utility class that makes multi-process sharding of a bot an easy and painless experience.\n * It works by spawning a self-contained {@link ChildProcess} or {@link Worker} for each individual shard, each\n * containing its own instance of your bot's {@link Client}. They all have a line of communication with the master\n * process, and there are several useful methods that utilise it in order to simplify tasks that are normally difficult\n * with sharding. It can spawn a specific number of shards or the amount that Discord suggests for the bot, and takes a\n * path to your main bot script to launch for each one.\n * @extends {EventEmitter}\n */\n\n\nclass ShardingManager extends EventEmitter {\n  /**\n   * The mode to spawn shards with for a {@link ShardingManager}. Can be either one of:\n   * * 'process' to use child processes\n   * * 'worker' to use [Worker threads](https://nodejs.org/api/worker_threads.html)\n   * @typedef {string} ShardingManagerMode\n   */\n\n  /**\n   * The options to spawn shards with for a {@link ShardingManager}.\n   * @typedef {Object} ShardingManagerOptions\n   * @property {string|number} [totalShards='auto'] Number of total shards of all shard managers or \"auto\"\n   * @property {string|number[]} [shardList='auto'] List of shards to spawn or \"auto\"\n   * @property {ShardingManagerMode} [mode='process'] Which mode to use for shards\n   * @property {boolean} [respawn=true] Whether shards should automatically respawn upon exiting\n   * @property {string[]} [shardArgs=[]] Arguments to pass to the shard script when spawning\n   * (only available when mode is set to 'process')\n   * @property {string} [execArgv=[]] Arguments to pass to the shard script executable when spawning\n   * (only available when mode is set to 'process')\n   * @property {string} [token] Token to use for automatic shard count and passing to shards\n   */\n\n  /**\n   * @param {string} file Path to your shard script file\n   * @param {ShardingManagerOptions} [options] Options for the sharding manager\n   */\n  constructor(file) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    options = Util.mergeDefault({\n      totalShards: 'auto',\n      mode: 'process',\n      respawn: true,\n      shardArgs: [],\n      execArgv: [],\n      token: process.env.DISCORD_TOKEN\n    }, options);\n    /**\n     * Path to the shard script file\n     * @type {string}\n     */\n\n    this.file = file;\n    if (!file) throw new Error('CLIENT_INVALID_OPTION', 'File', 'specified.');\n    if (!path.isAbsolute(file)) this.file = path.resolve(process.cwd(), file);\n    const stats = fs.statSync(this.file);\n    if (!stats.isFile()) throw new Error('CLIENT_INVALID_OPTION', 'File', 'a file');\n    /**\n     * List of shards this sharding manager spawns\n     * @type {string|number[]}\n     */\n\n    this.shardList = options.shardList ?? 'auto';\n\n    if (this.shardList !== 'auto') {\n      if (!Array.isArray(this.shardList)) {\n        throw new TypeError('CLIENT_INVALID_OPTION', 'shardList', 'an array.');\n      }\n\n      this.shardList = [...new Set(this.shardList)];\n      if (this.shardList.length < 1) throw new RangeError('CLIENT_INVALID_OPTION', 'shardList', 'at least 1 id.');\n\n      if (this.shardList.some(shardId => typeof shardId !== 'number' || isNaN(shardId) || !Number.isInteger(shardId) || shardId < 0)) {\n        throw new TypeError('CLIENT_INVALID_OPTION', 'shardList', 'an array of positive integers.');\n      }\n    }\n    /**\n     * Amount of shards that all sharding managers spawn in total\n     * @type {number}\n     */\n\n\n    this.totalShards = options.totalShards || 'auto';\n\n    if (this.totalShards !== 'auto') {\n      if (typeof this.totalShards !== 'number' || isNaN(this.totalShards)) {\n        throw new TypeError('CLIENT_INVALID_OPTION', 'Amount of shards', 'a number.');\n      }\n\n      if (this.totalShards < 1) throw new RangeError('CLIENT_INVALID_OPTION', 'Amount of shards', 'at least 1.');\n\n      if (!Number.isInteger(this.totalShards)) {\n        throw new RangeError('CLIENT_INVALID_OPTION', 'Amount of shards', 'an integer.');\n      }\n    }\n    /**\n     * Mode for shards to spawn with\n     * @type {ShardingManagerMode}\n     */\n\n\n    this.mode = options.mode;\n\n    if (this.mode !== 'process' && this.mode !== 'worker') {\n      throw new RangeError('CLIENT_INVALID_OPTION', 'Sharding mode', '\"process\" or \"worker\"');\n    }\n    /**\n     * Whether shards should automatically respawn upon exiting\n     * @type {boolean}\n     */\n\n\n    this.respawn = options.respawn;\n    /**\n     * An array of arguments to pass to shards (only when {@link ShardingManager#mode} is `process`)\n     * @type {string[]}\n     */\n\n    this.shardArgs = options.shardArgs;\n    /**\n     * An array of arguments to pass to the executable (only when {@link ShardingManager#mode} is `process`)\n     * @type {string[]}\n     */\n\n    this.execArgv = options.execArgv;\n    /**\n     * Token to use for obtaining the automatic shard count, and passing to shards\n     * @type {?string}\n     */\n\n    this.token = options.token?.replace(/^Bot\\s*/i, '') ?? null;\n    /**\n     * A collection of shards that this manager has spawned\n     * @type {Collection<number, Shard>}\n     */\n\n    this.shards = new Collection();\n    process.env.SHARDING_MANAGER = true;\n    process.env.SHARDING_MANAGER_MODE = this.mode;\n    process.env.DISCORD_TOKEN = this.token;\n  }\n  /**\n   * Creates a single shard.\n   * <warn>Using this method is usually not necessary if you use the spawn method.</warn>\n   * @param {number} [id=this.shards.size] Id of the shard to create\n   * <info>This is usually not necessary to manually specify.</info>\n   * @returns {Shard} Note that the created shard needs to be explicitly spawned using its spawn method.\n   */\n\n\n  createShard() {\n    let id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.shards.size;\n    const shard = new Shard(this, id);\n    this.shards.set(id, shard);\n    /**\n     * Emitted upon creating a shard.\n     * @event ShardingManager#shardCreate\n     * @param {Shard} shard Shard that was created\n     */\n\n    this.emit('shardCreate', shard);\n    return shard;\n  }\n  /**\n   * Options used to spawn multiple shards.\n   * @typedef {Object} MultipleShardSpawnOptions\n   * @property {number|string} [amount=this.totalShards] Number of shards to spawn\n   * @property {number} [delay=5500] How long to wait in between spawning each shard (in milliseconds)\n   * @property {number} [timeout=30000] The amount in milliseconds to wait until the {@link Client} has become ready\n   */\n\n  /**\n   * Spawns multiple shards.\n   * @param {MultipleShardSpawnOptions} [options] Options for spawning shards\n   * @returns {Promise<Collection<number, Shard>>}\n   */\n\n\n  async spawn() {\n    let {\n      amount = this.totalShards,\n      delay = 5500,\n      timeout = 30_000\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    // Obtain/verify the number of shards to spawn\n    if (amount === 'auto') {\n      amount = await Util.fetchRecommendedShards(this.token);\n    } else {\n      if (typeof amount !== 'number' || isNaN(amount)) {\n        throw new TypeError('CLIENT_INVALID_OPTION', 'Amount of shards', 'a number.');\n      }\n\n      if (amount < 1) throw new RangeError('CLIENT_INVALID_OPTION', 'Amount of shards', 'at least 1.');\n\n      if (!Number.isInteger(amount)) {\n        throw new TypeError('CLIENT_INVALID_OPTION', 'Amount of shards', 'an integer.');\n      }\n    } // Make sure this many shards haven't already been spawned\n\n\n    if (this.shards.size >= amount) throw new Error('SHARDING_ALREADY_SPAWNED', this.shards.size);\n\n    if (this.shardList === 'auto' || this.totalShards === 'auto' || this.totalShards !== amount) {\n      this.shardList = [...Array(amount).keys()];\n    }\n\n    if (this.totalShards === 'auto' || this.totalShards !== amount) {\n      this.totalShards = amount;\n    }\n\n    if (this.shardList.some(shardId => shardId >= amount)) {\n      throw new RangeError('CLIENT_INVALID_OPTION', 'Amount of shards', 'bigger than the highest shardId in the shardList option.');\n    } // Spawn the shards\n\n\n    for (const shardId of this.shardList) {\n      const promises = [];\n      const shard = this.createShard(shardId);\n      promises.push(shard.spawn(timeout));\n      if (delay > 0 && this.shards.size !== this.shardList.length) promises.push(sleep(delay));\n      await Promise.all(promises); // eslint-disable-line no-await-in-loop\n    }\n\n    return this.shards;\n  }\n  /**\n   * Sends a message to all shards.\n   * @param {*} message Message to be sent to the shards\n   * @returns {Promise<Shard[]>}\n   */\n\n\n  broadcast(message) {\n    const promises = [];\n\n    for (const shard of this.shards.values()) promises.push(shard.send(message));\n\n    return Promise.all(promises);\n  }\n  /**\n   * Options for {@link ShardingManager#broadcastEval} and {@link ShardClientUtil#broadcastEval}.\n   * @typedef {Object} BroadcastEvalOptions\n   * @property {number} [shard] Shard to run script on, all if undefined\n   * @property {*} [context] The JSON-serializable values to call the script with\n   */\n\n  /**\n   * Evaluates a script on all shards, or a given shard, in the context of the {@link Client}s.\n   * @param {Function} script JavaScript to run on each shard\n   * @param {BroadcastEvalOptions} [options={}] The options for the broadcast\n   * @returns {Promise<*|Array<*>>} Results of the script execution\n   */\n\n\n  broadcastEval(script) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (typeof script !== 'function') return Promise.reject(new TypeError('SHARDING_INVALID_EVAL_BROADCAST'));\n    return this._performOnShards('eval', [`(${script})(this, ${JSON.stringify(options.context)})`], options.shard);\n  }\n  /**\n   * Fetches a client property value of each shard, or a given shard.\n   * @param {string} prop Name of the client property to get, using periods for nesting\n   * @param {number} [shard] Shard to fetch property from, all if undefined\n   * @returns {Promise<*|Array<*>>}\n   * @example\n   * manager.fetchClientValues('guilds.cache.size')\n   *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))\n   *   .catch(console.error);\n   */\n\n\n  fetchClientValues(prop, shard) {\n    return this._performOnShards('fetchClientValue', [prop], shard);\n  }\n  /**\n   * Runs a method with given arguments on all shards, or a given shard.\n   * @param {string} method Method name to run on each shard\n   * @param {Array<*>} args Arguments to pass through to the method call\n   * @param {number} [shard] Shard to run on, all if undefined\n   * @returns {Promise<*|Array<*>>} Results of the method execution\n   * @private\n   */\n\n\n  _performOnShards(method, args, shard) {\n    if (this.shards.size === 0) return Promise.reject(new Error('SHARDING_NO_SHARDS'));\n\n    if (typeof shard === 'number') {\n      if (this.shards.has(shard)) return this.shards.get(shard)[method](...args);\n      return Promise.reject(new Error('SHARDING_SHARD_NOT_FOUND', shard));\n    }\n\n    if (this.shards.size !== this.shardList.length) return Promise.reject(new Error('SHARDING_IN_PROCESS'));\n    const promises = [];\n\n    for (const sh of this.shards.values()) promises.push(sh[method](...args));\n\n    return Promise.all(promises);\n  }\n  /**\n   * Options used to respawn all shards.\n   * @typedef {Object} MultipleShardRespawnOptions\n   * @property {number} [shardDelay=5000] How long to wait between shards (in milliseconds)\n   * @property {number} [respawnDelay=500] How long to wait between killing a shard's process and restarting it\n   * (in milliseconds)\n   * @property {number} [timeout=30000] The amount in milliseconds to wait for a shard to become ready before\n   * continuing to another (`-1` or `Infinity` for no wait)\n   */\n\n  /**\n   * Kills all running shards and respawns them.\n   * @param {MultipleShardRespawnOptions} [options] Options for respawning shards\n   * @returns {Promise<Collection<number, Shard>>}\n   */\n\n\n  async respawnAll() {\n    let {\n      shardDelay = 5_000,\n      respawnDelay = 500,\n      timeout = 30_000\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let s = 0;\n\n    for (const shard of this.shards.values()) {\n      const promises = [shard.respawn({\n        delay: respawnDelay,\n        timeout\n      })];\n      if (++s < this.shards.size && shardDelay > 0) promises.push(sleep(shardDelay));\n      await Promise.all(promises); // eslint-disable-line no-await-in-loop\n    }\n\n    return this.shards;\n  }\n\n}\n\nmodule.exports = ShardingManager;","map":{"version":3,"names":["EventEmitter","require","fs","path","process","setTimeout","sleep","Collection","Shard","Error","TypeError","RangeError","Util","ShardingManager","constructor","file","options","mergeDefault","totalShards","mode","respawn","shardArgs","execArgv","token","env","DISCORD_TOKEN","isAbsolute","resolve","cwd","stats","statSync","isFile","shardList","Array","isArray","Set","length","some","shardId","isNaN","Number","isInteger","replace","shards","SHARDING_MANAGER","SHARDING_MANAGER_MODE","createShard","id","size","shard","set","emit","spawn","amount","delay","timeout","fetchRecommendedShards","keys","promises","push","Promise","all","broadcast","message","values","send","broadcastEval","script","reject","_performOnShards","JSON","stringify","context","fetchClientValues","prop","method","args","has","get","sh","respawnAll","shardDelay","respawnDelay","s","module","exports"],"sources":["C:/Users/xsxsam/node_modules/discord.js/src/sharding/ShardingManager.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('node:events');\nconst fs = require('node:fs');\nconst path = require('node:path');\nconst process = require('node:process');\nconst { setTimeout: sleep } = require('node:timers/promises');\nconst { Collection } = require('@discordjs/collection');\nconst Shard = require('./Shard');\nconst { Error, TypeError, RangeError } = require('../errors');\nconst Util = require('../util/Util');\n\n/**\n * This is a utility class that makes multi-process sharding of a bot an easy and painless experience.\n * It works by spawning a self-contained {@link ChildProcess} or {@link Worker} for each individual shard, each\n * containing its own instance of your bot's {@link Client}. They all have a line of communication with the master\n * process, and there are several useful methods that utilise it in order to simplify tasks that are normally difficult\n * with sharding. It can spawn a specific number of shards or the amount that Discord suggests for the bot, and takes a\n * path to your main bot script to launch for each one.\n * @extends {EventEmitter}\n */\nclass ShardingManager extends EventEmitter {\n  /**\n   * The mode to spawn shards with for a {@link ShardingManager}. Can be either one of:\n   * * 'process' to use child processes\n   * * 'worker' to use [Worker threads](https://nodejs.org/api/worker_threads.html)\n   * @typedef {string} ShardingManagerMode\n   */\n\n  /**\n   * The options to spawn shards with for a {@link ShardingManager}.\n   * @typedef {Object} ShardingManagerOptions\n   * @property {string|number} [totalShards='auto'] Number of total shards of all shard managers or \"auto\"\n   * @property {string|number[]} [shardList='auto'] List of shards to spawn or \"auto\"\n   * @property {ShardingManagerMode} [mode='process'] Which mode to use for shards\n   * @property {boolean} [respawn=true] Whether shards should automatically respawn upon exiting\n   * @property {string[]} [shardArgs=[]] Arguments to pass to the shard script when spawning\n   * (only available when mode is set to 'process')\n   * @property {string} [execArgv=[]] Arguments to pass to the shard script executable when spawning\n   * (only available when mode is set to 'process')\n   * @property {string} [token] Token to use for automatic shard count and passing to shards\n   */\n\n  /**\n   * @param {string} file Path to your shard script file\n   * @param {ShardingManagerOptions} [options] Options for the sharding manager\n   */\n  constructor(file, options = {}) {\n    super();\n    options = Util.mergeDefault(\n      {\n        totalShards: 'auto',\n        mode: 'process',\n        respawn: true,\n        shardArgs: [],\n        execArgv: [],\n        token: process.env.DISCORD_TOKEN,\n      },\n      options,\n    );\n\n    /**\n     * Path to the shard script file\n     * @type {string}\n     */\n    this.file = file;\n    if (!file) throw new Error('CLIENT_INVALID_OPTION', 'File', 'specified.');\n    if (!path.isAbsolute(file)) this.file = path.resolve(process.cwd(), file);\n    const stats = fs.statSync(this.file);\n    if (!stats.isFile()) throw new Error('CLIENT_INVALID_OPTION', 'File', 'a file');\n\n    /**\n     * List of shards this sharding manager spawns\n     * @type {string|number[]}\n     */\n    this.shardList = options.shardList ?? 'auto';\n    if (this.shardList !== 'auto') {\n      if (!Array.isArray(this.shardList)) {\n        throw new TypeError('CLIENT_INVALID_OPTION', 'shardList', 'an array.');\n      }\n      this.shardList = [...new Set(this.shardList)];\n      if (this.shardList.length < 1) throw new RangeError('CLIENT_INVALID_OPTION', 'shardList', 'at least 1 id.');\n      if (\n        this.shardList.some(\n          shardId => typeof shardId !== 'number' || isNaN(shardId) || !Number.isInteger(shardId) || shardId < 0,\n        )\n      ) {\n        throw new TypeError('CLIENT_INVALID_OPTION', 'shardList', 'an array of positive integers.');\n      }\n    }\n\n    /**\n     * Amount of shards that all sharding managers spawn in total\n     * @type {number}\n     */\n    this.totalShards = options.totalShards || 'auto';\n    if (this.totalShards !== 'auto') {\n      if (typeof this.totalShards !== 'number' || isNaN(this.totalShards)) {\n        throw new TypeError('CLIENT_INVALID_OPTION', 'Amount of shards', 'a number.');\n      }\n      if (this.totalShards < 1) throw new RangeError('CLIENT_INVALID_OPTION', 'Amount of shards', 'at least 1.');\n      if (!Number.isInteger(this.totalShards)) {\n        throw new RangeError('CLIENT_INVALID_OPTION', 'Amount of shards', 'an integer.');\n      }\n    }\n\n    /**\n     * Mode for shards to spawn with\n     * @type {ShardingManagerMode}\n     */\n    this.mode = options.mode;\n    if (this.mode !== 'process' && this.mode !== 'worker') {\n      throw new RangeError('CLIENT_INVALID_OPTION', 'Sharding mode', '\"process\" or \"worker\"');\n    }\n\n    /**\n     * Whether shards should automatically respawn upon exiting\n     * @type {boolean}\n     */\n    this.respawn = options.respawn;\n\n    /**\n     * An array of arguments to pass to shards (only when {@link ShardingManager#mode} is `process`)\n     * @type {string[]}\n     */\n    this.shardArgs = options.shardArgs;\n\n    /**\n     * An array of arguments to pass to the executable (only when {@link ShardingManager#mode} is `process`)\n     * @type {string[]}\n     */\n    this.execArgv = options.execArgv;\n\n    /**\n     * Token to use for obtaining the automatic shard count, and passing to shards\n     * @type {?string}\n     */\n    this.token = options.token?.replace(/^Bot\\s*/i, '') ?? null;\n\n    /**\n     * A collection of shards that this manager has spawned\n     * @type {Collection<number, Shard>}\n     */\n    this.shards = new Collection();\n\n    process.env.SHARDING_MANAGER = true;\n    process.env.SHARDING_MANAGER_MODE = this.mode;\n    process.env.DISCORD_TOKEN = this.token;\n  }\n\n  /**\n   * Creates a single shard.\n   * <warn>Using this method is usually not necessary if you use the spawn method.</warn>\n   * @param {number} [id=this.shards.size] Id of the shard to create\n   * <info>This is usually not necessary to manually specify.</info>\n   * @returns {Shard} Note that the created shard needs to be explicitly spawned using its spawn method.\n   */\n  createShard(id = this.shards.size) {\n    const shard = new Shard(this, id);\n    this.shards.set(id, shard);\n    /**\n     * Emitted upon creating a shard.\n     * @event ShardingManager#shardCreate\n     * @param {Shard} shard Shard that was created\n     */\n    this.emit('shardCreate', shard);\n    return shard;\n  }\n\n  /**\n   * Options used to spawn multiple shards.\n   * @typedef {Object} MultipleShardSpawnOptions\n   * @property {number|string} [amount=this.totalShards] Number of shards to spawn\n   * @property {number} [delay=5500] How long to wait in between spawning each shard (in milliseconds)\n   * @property {number} [timeout=30000] The amount in milliseconds to wait until the {@link Client} has become ready\n   */\n\n  /**\n   * Spawns multiple shards.\n   * @param {MultipleShardSpawnOptions} [options] Options for spawning shards\n   * @returns {Promise<Collection<number, Shard>>}\n   */\n  async spawn({ amount = this.totalShards, delay = 5500, timeout = 30_000 } = {}) {\n    // Obtain/verify the number of shards to spawn\n    if (amount === 'auto') {\n      amount = await Util.fetchRecommendedShards(this.token);\n    } else {\n      if (typeof amount !== 'number' || isNaN(amount)) {\n        throw new TypeError('CLIENT_INVALID_OPTION', 'Amount of shards', 'a number.');\n      }\n      if (amount < 1) throw new RangeError('CLIENT_INVALID_OPTION', 'Amount of shards', 'at least 1.');\n      if (!Number.isInteger(amount)) {\n        throw new TypeError('CLIENT_INVALID_OPTION', 'Amount of shards', 'an integer.');\n      }\n    }\n\n    // Make sure this many shards haven't already been spawned\n    if (this.shards.size >= amount) throw new Error('SHARDING_ALREADY_SPAWNED', this.shards.size);\n    if (this.shardList === 'auto' || this.totalShards === 'auto' || this.totalShards !== amount) {\n      this.shardList = [...Array(amount).keys()];\n    }\n    if (this.totalShards === 'auto' || this.totalShards !== amount) {\n      this.totalShards = amount;\n    }\n\n    if (this.shardList.some(shardId => shardId >= amount)) {\n      throw new RangeError(\n        'CLIENT_INVALID_OPTION',\n        'Amount of shards',\n        'bigger than the highest shardId in the shardList option.',\n      );\n    }\n\n    // Spawn the shards\n    for (const shardId of this.shardList) {\n      const promises = [];\n      const shard = this.createShard(shardId);\n      promises.push(shard.spawn(timeout));\n      if (delay > 0 && this.shards.size !== this.shardList.length) promises.push(sleep(delay));\n      await Promise.all(promises); // eslint-disable-line no-await-in-loop\n    }\n\n    return this.shards;\n  }\n\n  /**\n   * Sends a message to all shards.\n   * @param {*} message Message to be sent to the shards\n   * @returns {Promise<Shard[]>}\n   */\n  broadcast(message) {\n    const promises = [];\n    for (const shard of this.shards.values()) promises.push(shard.send(message));\n    return Promise.all(promises);\n  }\n\n  /**\n   * Options for {@link ShardingManager#broadcastEval} and {@link ShardClientUtil#broadcastEval}.\n   * @typedef {Object} BroadcastEvalOptions\n   * @property {number} [shard] Shard to run script on, all if undefined\n   * @property {*} [context] The JSON-serializable values to call the script with\n   */\n\n  /**\n   * Evaluates a script on all shards, or a given shard, in the context of the {@link Client}s.\n   * @param {Function} script JavaScript to run on each shard\n   * @param {BroadcastEvalOptions} [options={}] The options for the broadcast\n   * @returns {Promise<*|Array<*>>} Results of the script execution\n   */\n  broadcastEval(script, options = {}) {\n    if (typeof script !== 'function') return Promise.reject(new TypeError('SHARDING_INVALID_EVAL_BROADCAST'));\n    return this._performOnShards('eval', [`(${script})(this, ${JSON.stringify(options.context)})`], options.shard);\n  }\n\n  /**\n   * Fetches a client property value of each shard, or a given shard.\n   * @param {string} prop Name of the client property to get, using periods for nesting\n   * @param {number} [shard] Shard to fetch property from, all if undefined\n   * @returns {Promise<*|Array<*>>}\n   * @example\n   * manager.fetchClientValues('guilds.cache.size')\n   *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))\n   *   .catch(console.error);\n   */\n  fetchClientValues(prop, shard) {\n    return this._performOnShards('fetchClientValue', [prop], shard);\n  }\n\n  /**\n   * Runs a method with given arguments on all shards, or a given shard.\n   * @param {string} method Method name to run on each shard\n   * @param {Array<*>} args Arguments to pass through to the method call\n   * @param {number} [shard] Shard to run on, all if undefined\n   * @returns {Promise<*|Array<*>>} Results of the method execution\n   * @private\n   */\n  _performOnShards(method, args, shard) {\n    if (this.shards.size === 0) return Promise.reject(new Error('SHARDING_NO_SHARDS'));\n\n    if (typeof shard === 'number') {\n      if (this.shards.has(shard)) return this.shards.get(shard)[method](...args);\n      return Promise.reject(new Error('SHARDING_SHARD_NOT_FOUND', shard));\n    }\n\n    if (this.shards.size !== this.shardList.length) return Promise.reject(new Error('SHARDING_IN_PROCESS'));\n\n    const promises = [];\n    for (const sh of this.shards.values()) promises.push(sh[method](...args));\n    return Promise.all(promises);\n  }\n\n  /**\n   * Options used to respawn all shards.\n   * @typedef {Object} MultipleShardRespawnOptions\n   * @property {number} [shardDelay=5000] How long to wait between shards (in milliseconds)\n   * @property {number} [respawnDelay=500] How long to wait between killing a shard's process and restarting it\n   * (in milliseconds)\n   * @property {number} [timeout=30000] The amount in milliseconds to wait for a shard to become ready before\n   * continuing to another (`-1` or `Infinity` for no wait)\n   */\n\n  /**\n   * Kills all running shards and respawns them.\n   * @param {MultipleShardRespawnOptions} [options] Options for respawning shards\n   * @returns {Promise<Collection<number, Shard>>}\n   */\n  async respawnAll({ shardDelay = 5_000, respawnDelay = 500, timeout = 30_000 } = {}) {\n    let s = 0;\n    for (const shard of this.shards.values()) {\n      const promises = [shard.respawn({ delay: respawnDelay, timeout })];\n      if (++s < this.shards.size && shardDelay > 0) promises.push(sleep(shardDelay));\n      await Promise.all(promises); // eslint-disable-line no-await-in-loop\n    }\n    return this.shards;\n  }\n}\n\nmodule.exports = ShardingManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}