{"ast":null,"code":"'use strict';\n\nconst process = require('node:process');\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst CachedManager = require('./CachedManager');\n\nconst {\n  TypeError\n} = require('../errors');\n\nconst {\n  Role\n} = require('../structures/Role');\n\nconst DataResolver = require('../util/DataResolver');\n\nconst Permissions = require('../util/Permissions');\n\nconst {\n  resolveColor,\n  setPosition\n} = require('../util/Util');\n\nlet cacheWarningEmitted = false;\n/**\n * Manages API methods for roles and stores their cache.\n * @extends {CachedManager}\n */\n\nclass RoleManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, Role, iterable);\n\n    if (!cacheWarningEmitted && this._cache.constructor.name !== 'Collection') {\n      cacheWarningEmitted = true;\n      process.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, 'UnsupportedCacheOverwriteWarning');\n    }\n    /**\n     * The guild belonging to this manager\n     * @type {Guild}\n     */\n\n\n    this.guild = guild;\n  }\n  /**\n   * The role cache of this manager\n   * @type {Collection<Snowflake, Role>}\n   * @name RoleManager#cache\n   */\n\n\n  _add(data, cache) {\n    return super._add(data, cache, {\n      extras: [this.guild]\n    });\n  }\n  /**\n   * Obtains a role from Discord, or the role cache if they're already available.\n   * @param {Snowflake} [id] The role's id\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<?Role|Collection<Snowflake, Role>>}\n   * @example\n   * // Fetch all roles from the guild\n   * message.guild.roles.fetch()\n   *   .then(roles => console.log(`There are ${roles.size} roles.`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single role\n   * message.guild.roles.fetch('222078108977594368')\n   *   .then(role => console.log(`The role color is: ${role.color}`))\n   *   .catch(console.error);\n   */\n\n\n  async fetch(id) {\n    let {\n      cache = true,\n      force = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (id && !force) {\n      const existing = this.cache.get(id);\n      if (existing) return existing;\n    } // We cannot fetch a single role, as of this commit's date, Discord API throws with 405\n\n\n    const data = await this.client.api.guilds(this.guild.id).roles.get();\n    const roles = new Collection();\n\n    for (const role of data) roles.set(role.id, this._add(role, cache));\n\n    return id ? roles.get(id) ?? null : roles;\n  }\n  /**\n   * Data that can be resolved to a Role object. This can be:\n   * * A Role\n   * * A Snowflake\n   * @typedef {Role|Snowflake} RoleResolvable\n   */\n\n  /**\n   * Resolves a {@link RoleResolvable} to a {@link Role} object.\n   * @method resolve\n   * @memberof RoleManager\n   * @instance\n   * @param {RoleResolvable} role The role resolvable to resolve\n   * @returns {?Role}\n   */\n\n  /**\n   * Resolves a {@link RoleResolvable} to a {@link Role} id.\n   * @method resolveId\n   * @memberof RoleManager\n   * @instance\n   * @param {RoleResolvable} role The role resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Options used to create a new role.\n   * @typedef {Object} CreateRoleOptions\n   * @property {string} [name] The name of the new role\n   * @property {ColorResolvable} [color] The data to create the role with\n   * @property {boolean} [hoist] Whether or not the new role should be hoisted\n   * @property {PermissionResolvable} [permissions] The permissions for the new role\n   * @property {number} [position] The position of the new role\n   * @property {boolean} [mentionable] Whether or not the new role should be mentionable\n   * @property {?(BufferResolvable|Base64Resolvable|EmojiResolvable)} [icon] The icon for the role\n   * <warn>The `EmojiResolvable` should belong to the same guild as the role.\n   * If not, pass the emoji's URL directly</warn>\n   * @property {?string} [unicodeEmoji] The unicode emoji for the role\n   * @property {string} [reason] The reason for creating this role\n   */\n\n  /**\n   * Creates a new role in the guild with given information.\n   * <warn>The position will silently reset to 1 if an invalid one is provided, or none.</warn>\n   * @param {CreateRoleOptions} [options] Options for creating the new role\n   * @returns {Promise<Role>}\n   * @example\n   * // Create a new role\n   * guild.roles.create()\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Create a new role with data and a reason\n   * guild.roles.create({\n   *   name: 'Super Cool Blue People',\n   *   color: 'BLUE',\n   *   reason: 'we needed a role for Super Cool People',\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  async create() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let {\n      name,\n      color,\n      hoist,\n      permissions,\n      position,\n      mentionable,\n      reason,\n      icon,\n      unicodeEmoji\n    } = options;\n    color &&= resolveColor(color);\n    if (typeof permissions !== 'undefined') permissions = new Permissions(permissions);\n\n    if (icon) {\n      const guildEmojiURL = this.guild.emojis.resolve(icon)?.url;\n      icon = guildEmojiURL ? await DataResolver.resolveImage(guildEmojiURL) : await DataResolver.resolveImage(icon);\n      if (typeof icon !== 'string') icon = undefined;\n    }\n\n    const data = await this.client.api.guilds(this.guild.id).roles.post({\n      data: {\n        name,\n        color,\n        hoist,\n        permissions,\n        mentionable,\n        icon,\n        unicode_emoji: unicodeEmoji\n      },\n      reason\n    });\n    const {\n      role\n    } = this.client.actions.GuildRoleCreate.handle({\n      guild_id: this.guild.id,\n      role: data\n    });\n    if (position) return role.setPosition(position, reason);\n    return role;\n  }\n  /**\n   * Edits a role of the guild.\n   * @param {RoleResolvable} role The role to edit\n   * @param {RoleData} data The new data for the role\n   * @param {string} [reason] Reason for editing this role\n   * @returns {Promise<Role>}\n   * @example\n   * // Edit a role\n   * guild.roles.edit('222079219327434752', { name: 'buddies' })\n   *   .then(updated => console.log(`Edited role name to ${updated.name}`))\n   *   .catch(console.error);\n   */\n\n\n  async edit(role, data, reason) {\n    role = this.resolve(role);\n    if (!role) throw new TypeError('INVALID_TYPE', 'role', 'RoleResolvable');\n\n    if (typeof data.position === 'number') {\n      const updatedRoles = await setPosition(role, data.position, false, this.guild._sortedRoles(), this.client.api.guilds(this.guild.id).roles, reason);\n      this.client.actions.GuildRolesPositionUpdate.handle({\n        guild_id: this.guild.id,\n        roles: updatedRoles\n      });\n    }\n\n    let icon = data.icon;\n\n    if (icon) {\n      const guildEmojiURL = this.guild.emojis.resolve(icon)?.url;\n      icon = guildEmojiURL ? await DataResolver.resolveImage(guildEmojiURL) : await DataResolver.resolveImage(icon);\n      if (typeof icon !== 'string') icon = undefined;\n    }\n\n    const _data = {\n      name: data.name,\n      color: typeof data.color === 'undefined' ? undefined : resolveColor(data.color),\n      hoist: data.hoist,\n      permissions: typeof data.permissions === 'undefined' ? undefined : new Permissions(data.permissions),\n      mentionable: data.mentionable,\n      icon,\n      unicode_emoji: data.unicodeEmoji\n    };\n    const d = await this.client.api.guilds(this.guild.id).roles(role.id).patch({\n      data: _data,\n      reason\n    });\n\n    const clone = role._clone();\n\n    clone._patch(d);\n\n    return clone;\n  }\n  /**\n   * Deletes a role.\n   * @param {RoleResolvable} role The role to delete\n   * @param {string} [reason] Reason for deleting the role\n   * @returns {Promise<void>}\n   * @example\n   * // Delete a role\n   * guild.roles.delete('222079219327434752', 'The role needed to go')\n   *   .then(deleted => console.log(`Deleted role ${deleted.name}`))\n   *   .catch(console.error);\n   */\n\n\n  async delete(role, reason) {\n    const id = this.resolveId(role);\n    await this.client.api.guilds[this.guild.id].roles[id].delete({\n      reason\n    });\n    this.client.actions.GuildRoleDelete.handle({\n      guild_id: this.guild.id,\n      role_id: id\n    });\n  }\n  /**\n   * Batch-updates the guild's role positions\n   * @param {GuildRolePosition[]} rolePositions Role positions to update\n   * @returns {Promise<Guild>}\n   * @example\n   * guild.roles.setPositions([{ role: roleId, position: updatedRoleIndex }])\n   *  .then(guild => console.log(`Role positions updated for ${guild}`))\n   *  .catch(console.error);\n   */\n\n\n  async setPositions(rolePositions) {\n    // Make sure rolePositions are prepared for API\n    rolePositions = rolePositions.map(o => ({\n      id: this.resolveId(o.role),\n      position: o.position\n    })); // Call the API to update role positions\n\n    await this.client.api.guilds(this.guild.id).roles.patch({\n      data: rolePositions\n    });\n    return this.client.actions.GuildRolesPositionUpdate.handle({\n      guild_id: this.guild.id,\n      roles: rolePositions\n    }).guild;\n  }\n  /**\n   * Compares the positions of two roles.\n   * @param {RoleResolvable} role1 First role to compare\n   * @param {RoleResolvable} role2 Second role to compare\n   * @returns {number} Negative number if the first role's position is lower (second role's is higher),\n   * positive number if the first's is higher (second's is lower), 0 if equal\n   */\n\n\n  comparePositions(role1, role2) {\n    const resolvedRole1 = this.resolve(role1);\n    const resolvedRole2 = this.resolve(role2);\n    if (!resolvedRole1 || !resolvedRole2) throw new TypeError('INVALID_TYPE', 'role', 'Role nor a Snowflake');\n\n    if (resolvedRole1.position === resolvedRole2.position) {\n      return Number(BigInt(resolvedRole2.id) - BigInt(resolvedRole1.id));\n    }\n\n    return resolvedRole1.position - resolvedRole2.position;\n  }\n  /**\n   * Gets the managed role a user created when joining the guild, if any\n   * <info>Only ever available for bots</info>\n   * @param {UserResolvable} user The user to access the bot role for\n   * @returns {?Role}\n   */\n\n\n  botRoleFor(user) {\n    const userId = this.client.users.resolveId(user);\n    if (!userId) return null;\n    return this.cache.find(role => role.tags?.botId === userId) ?? null;\n  }\n  /**\n   * The `@everyone` role of the guild\n   * @type {Role}\n   * @readonly\n   */\n\n\n  get everyone() {\n    return this.cache.get(this.guild.id);\n  }\n  /**\n   * The premium subscriber role of the guild, if any\n   * @type {?Role}\n   * @readonly\n   */\n\n\n  get premiumSubscriberRole() {\n    return this.cache.find(role => role.tags?.premiumSubscriberRole) ?? null;\n  }\n  /**\n   * The role with the highest position in the cache\n   * @type {Role}\n   * @readonly\n   */\n\n\n  get highest() {\n    return this.cache.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev, this.cache.first());\n  }\n\n}\n\nmodule.exports = RoleManager;","map":{"version":3,"names":["process","require","Collection","CachedManager","TypeError","Role","DataResolver","Permissions","resolveColor","setPosition","cacheWarningEmitted","RoleManager","constructor","guild","iterable","client","_cache","name","emitWarning","_add","data","cache","extras","fetch","id","force","existing","get","api","guilds","roles","role","set","create","options","color","hoist","permissions","position","mentionable","reason","icon","unicodeEmoji","guildEmojiURL","emojis","resolve","url","resolveImage","undefined","post","unicode_emoji","actions","GuildRoleCreate","handle","guild_id","edit","updatedRoles","_sortedRoles","GuildRolesPositionUpdate","_data","d","patch","clone","_clone","_patch","delete","resolveId","GuildRoleDelete","role_id","setPositions","rolePositions","map","o","comparePositions","role1","role2","resolvedRole1","resolvedRole2","Number","BigInt","botRoleFor","user","userId","users","find","tags","botId","everyone","premiumSubscriberRole","highest","reduce","prev","comparePositionTo","first","module","exports"],"sources":["C:/Users/xsxsam/node_modules/discord.js/src/managers/RoleManager.js"],"sourcesContent":["'use strict';\n\nconst process = require('node:process');\nconst { Collection } = require('@discordjs/collection');\nconst CachedManager = require('./CachedManager');\nconst { TypeError } = require('../errors');\nconst { Role } = require('../structures/Role');\nconst DataResolver = require('../util/DataResolver');\nconst Permissions = require('../util/Permissions');\nconst { resolveColor, setPosition } = require('../util/Util');\n\nlet cacheWarningEmitted = false;\n\n/**\n * Manages API methods for roles and stores their cache.\n * @extends {CachedManager}\n */\nclass RoleManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, Role, iterable);\n    if (!cacheWarningEmitted && this._cache.constructor.name !== 'Collection') {\n      cacheWarningEmitted = true;\n      process.emitWarning(\n        `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,\n        'UnsupportedCacheOverwriteWarning',\n      );\n    }\n\n    /**\n     * The guild belonging to this manager\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The role cache of this manager\n   * @type {Collection<Snowflake, Role>}\n   * @name RoleManager#cache\n   */\n\n  _add(data, cache) {\n    return super._add(data, cache, { extras: [this.guild] });\n  }\n\n  /**\n   * Obtains a role from Discord, or the role cache if they're already available.\n   * @param {Snowflake} [id] The role's id\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<?Role|Collection<Snowflake, Role>>}\n   * @example\n   * // Fetch all roles from the guild\n   * message.guild.roles.fetch()\n   *   .then(roles => console.log(`There are ${roles.size} roles.`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single role\n   * message.guild.roles.fetch('222078108977594368')\n   *   .then(role => console.log(`The role color is: ${role.color}`))\n   *   .catch(console.error);\n   */\n  async fetch(id, { cache = true, force = false } = {}) {\n    if (id && !force) {\n      const existing = this.cache.get(id);\n      if (existing) return existing;\n    }\n\n    // We cannot fetch a single role, as of this commit's date, Discord API throws with 405\n    const data = await this.client.api.guilds(this.guild.id).roles.get();\n    const roles = new Collection();\n    for (const role of data) roles.set(role.id, this._add(role, cache));\n    return id ? roles.get(id) ?? null : roles;\n  }\n\n  /**\n   * Data that can be resolved to a Role object. This can be:\n   * * A Role\n   * * A Snowflake\n   * @typedef {Role|Snowflake} RoleResolvable\n   */\n\n  /**\n   * Resolves a {@link RoleResolvable} to a {@link Role} object.\n   * @method resolve\n   * @memberof RoleManager\n   * @instance\n   * @param {RoleResolvable} role The role resolvable to resolve\n   * @returns {?Role}\n   */\n\n  /**\n   * Resolves a {@link RoleResolvable} to a {@link Role} id.\n   * @method resolveId\n   * @memberof RoleManager\n   * @instance\n   * @param {RoleResolvable} role The role resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Options used to create a new role.\n   * @typedef {Object} CreateRoleOptions\n   * @property {string} [name] The name of the new role\n   * @property {ColorResolvable} [color] The data to create the role with\n   * @property {boolean} [hoist] Whether or not the new role should be hoisted\n   * @property {PermissionResolvable} [permissions] The permissions for the new role\n   * @property {number} [position] The position of the new role\n   * @property {boolean} [mentionable] Whether or not the new role should be mentionable\n   * @property {?(BufferResolvable|Base64Resolvable|EmojiResolvable)} [icon] The icon for the role\n   * <warn>The `EmojiResolvable` should belong to the same guild as the role.\n   * If not, pass the emoji's URL directly</warn>\n   * @property {?string} [unicodeEmoji] The unicode emoji for the role\n   * @property {string} [reason] The reason for creating this role\n   */\n\n  /**\n   * Creates a new role in the guild with given information.\n   * <warn>The position will silently reset to 1 if an invalid one is provided, or none.</warn>\n   * @param {CreateRoleOptions} [options] Options for creating the new role\n   * @returns {Promise<Role>}\n   * @example\n   * // Create a new role\n   * guild.roles.create()\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Create a new role with data and a reason\n   * guild.roles.create({\n   *   name: 'Super Cool Blue People',\n   *   color: 'BLUE',\n   *   reason: 'we needed a role for Super Cool People',\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async create(options = {}) {\n    let { name, color, hoist, permissions, position, mentionable, reason, icon, unicodeEmoji } = options;\n    color &&= resolveColor(color);\n    if (typeof permissions !== 'undefined') permissions = new Permissions(permissions);\n    if (icon) {\n      const guildEmojiURL = this.guild.emojis.resolve(icon)?.url;\n      icon = guildEmojiURL ? await DataResolver.resolveImage(guildEmojiURL) : await DataResolver.resolveImage(icon);\n      if (typeof icon !== 'string') icon = undefined;\n    }\n\n    const data = await this.client.api.guilds(this.guild.id).roles.post({\n      data: {\n        name,\n        color,\n        hoist,\n        permissions,\n        mentionable,\n        icon,\n        unicode_emoji: unicodeEmoji,\n      },\n      reason,\n    });\n    const { role } = this.client.actions.GuildRoleCreate.handle({\n      guild_id: this.guild.id,\n      role: data,\n    });\n    if (position) return role.setPosition(position, reason);\n    return role;\n  }\n\n  /**\n   * Edits a role of the guild.\n   * @param {RoleResolvable} role The role to edit\n   * @param {RoleData} data The new data for the role\n   * @param {string} [reason] Reason for editing this role\n   * @returns {Promise<Role>}\n   * @example\n   * // Edit a role\n   * guild.roles.edit('222079219327434752', { name: 'buddies' })\n   *   .then(updated => console.log(`Edited role name to ${updated.name}`))\n   *   .catch(console.error);\n   */\n  async edit(role, data, reason) {\n    role = this.resolve(role);\n    if (!role) throw new TypeError('INVALID_TYPE', 'role', 'RoleResolvable');\n\n    if (typeof data.position === 'number') {\n      const updatedRoles = await setPosition(\n        role,\n        data.position,\n        false,\n        this.guild._sortedRoles(),\n        this.client.api.guilds(this.guild.id).roles,\n        reason,\n      );\n\n      this.client.actions.GuildRolesPositionUpdate.handle({\n        guild_id: this.guild.id,\n        roles: updatedRoles,\n      });\n    }\n\n    let icon = data.icon;\n    if (icon) {\n      const guildEmojiURL = this.guild.emojis.resolve(icon)?.url;\n      icon = guildEmojiURL ? await DataResolver.resolveImage(guildEmojiURL) : await DataResolver.resolveImage(icon);\n      if (typeof icon !== 'string') icon = undefined;\n    }\n\n    const _data = {\n      name: data.name,\n      color: typeof data.color === 'undefined' ? undefined : resolveColor(data.color),\n      hoist: data.hoist,\n      permissions: typeof data.permissions === 'undefined' ? undefined : new Permissions(data.permissions),\n      mentionable: data.mentionable,\n      icon,\n      unicode_emoji: data.unicodeEmoji,\n    };\n\n    const d = await this.client.api.guilds(this.guild.id).roles(role.id).patch({ data: _data, reason });\n\n    const clone = role._clone();\n    clone._patch(d);\n    return clone;\n  }\n\n  /**\n   * Deletes a role.\n   * @param {RoleResolvable} role The role to delete\n   * @param {string} [reason] Reason for deleting the role\n   * @returns {Promise<void>}\n   * @example\n   * // Delete a role\n   * guild.roles.delete('222079219327434752', 'The role needed to go')\n   *   .then(deleted => console.log(`Deleted role ${deleted.name}`))\n   *   .catch(console.error);\n   */\n  async delete(role, reason) {\n    const id = this.resolveId(role);\n    await this.client.api.guilds[this.guild.id].roles[id].delete({ reason });\n    this.client.actions.GuildRoleDelete.handle({ guild_id: this.guild.id, role_id: id });\n  }\n\n  /**\n   * Batch-updates the guild's role positions\n   * @param {GuildRolePosition[]} rolePositions Role positions to update\n   * @returns {Promise<Guild>}\n   * @example\n   * guild.roles.setPositions([{ role: roleId, position: updatedRoleIndex }])\n   *  .then(guild => console.log(`Role positions updated for ${guild}`))\n   *  .catch(console.error);\n   */\n  async setPositions(rolePositions) {\n    // Make sure rolePositions are prepared for API\n    rolePositions = rolePositions.map(o => ({\n      id: this.resolveId(o.role),\n      position: o.position,\n    }));\n\n    // Call the API to update role positions\n    await this.client.api.guilds(this.guild.id).roles.patch({\n      data: rolePositions,\n    });\n    return this.client.actions.GuildRolesPositionUpdate.handle({\n      guild_id: this.guild.id,\n      roles: rolePositions,\n    }).guild;\n  }\n\n  /**\n   * Compares the positions of two roles.\n   * @param {RoleResolvable} role1 First role to compare\n   * @param {RoleResolvable} role2 Second role to compare\n   * @returns {number} Negative number if the first role's position is lower (second role's is higher),\n   * positive number if the first's is higher (second's is lower), 0 if equal\n   */\n  comparePositions(role1, role2) {\n    const resolvedRole1 = this.resolve(role1);\n    const resolvedRole2 = this.resolve(role2);\n    if (!resolvedRole1 || !resolvedRole2) throw new TypeError('INVALID_TYPE', 'role', 'Role nor a Snowflake');\n\n    if (resolvedRole1.position === resolvedRole2.position) {\n      return Number(BigInt(resolvedRole2.id) - BigInt(resolvedRole1.id));\n    }\n\n    return resolvedRole1.position - resolvedRole2.position;\n  }\n\n  /**\n   * Gets the managed role a user created when joining the guild, if any\n   * <info>Only ever available for bots</info>\n   * @param {UserResolvable} user The user to access the bot role for\n   * @returns {?Role}\n   */\n  botRoleFor(user) {\n    const userId = this.client.users.resolveId(user);\n    if (!userId) return null;\n    return this.cache.find(role => role.tags?.botId === userId) ?? null;\n  }\n\n  /**\n   * The `@everyone` role of the guild\n   * @type {Role}\n   * @readonly\n   */\n  get everyone() {\n    return this.cache.get(this.guild.id);\n  }\n\n  /**\n   * The premium subscriber role of the guild, if any\n   * @type {?Role}\n   * @readonly\n   */\n  get premiumSubscriberRole() {\n    return this.cache.find(role => role.tags?.premiumSubscriberRole) ?? null;\n  }\n\n  /**\n   * The role with the highest position in the cache\n   * @type {Role}\n   * @readonly\n   */\n  get highest() {\n    return this.cache.reduce((prev, role) => (role.comparePositionTo(prev) > 0 ? role : prev), this.cache.first());\n  }\n}\n\nmodule.exports = RoleManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}