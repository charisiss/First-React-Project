{"ast":null,"code":"'use strict';\n\nconst CachedManager = require('./CachedManager');\n\nconst {\n  GuildMember\n} = require('../structures/GuildMember');\n\nconst {\n  Message\n} = require('../structures/Message');\n\nconst ThreadMember = require('../structures/ThreadMember');\n\nconst User = require('../structures/User');\n/**\n * Manages API methods for users and stores their cache.\n * @extends {CachedManager}\n */\n\n\nclass UserManager extends CachedManager {\n  constructor(client, iterable) {\n    super(client, User, iterable);\n  }\n  /**\n   * The cache of this manager\n   * @type {Collection<Snowflake, User>}\n   * @name UserManager#cache\n   */\n\n  /**\n   * Data that resolves to give a User object. This can be:\n   * * A User object\n   * * A Snowflake\n   * * A Message object (resolves to the message author)\n   * * A GuildMember object\n   * * A ThreadMember object\n   * @typedef {User|Snowflake|Message|GuildMember|ThreadMember} UserResolvable\n   */\n\n  /**\n   * The DM between the client's user and a user\n   * @param {Snowflake} userId The user id\n   * @returns {?DMChannel}\n   * @private\n   */\n\n\n  dmChannel(userId) {\n    return this.client.channels.cache.find(c => c.type === 'DM' && c.recipient.id === userId) ?? null;\n  }\n  /**\n   * Creates a {@link DMChannel} between the client and a user.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<DMChannel>}\n   */\n\n\n  async createDM(user) {\n    let {\n      cache = true,\n      force = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const id = this.resolveId(user);\n\n    if (!force) {\n      const dmChannel = this.dmChannel(id);\n      if (dmChannel && !dmChannel.partial) return dmChannel;\n    }\n\n    const data = await this.client.api.users(this.client.user.id).channels.post({\n      data: {\n        recipient_id: id\n      }\n    });\n    return this.client.channels._add(data, null, {\n      cache\n    });\n  }\n  /**\n   * Deletes a {@link DMChannel} (if one exists) between the client and a user. Resolves with the channel if successful.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @returns {Promise<DMChannel>}\n   */\n\n\n  async deleteDM(user) {\n    const id = this.resolveId(user);\n    const dmChannel = this.dmChannel(id);\n    if (!dmChannel) throw new Error('USER_NO_DM_CHANNEL');\n    await this.client.api.channels(dmChannel.id).delete();\n\n    this.client.channels._remove(dmChannel.id);\n\n    return dmChannel;\n  }\n  /**\n   * Obtains a user from Discord, or the user cache if it's already available.\n   * @param {UserResolvable} user The user to fetch\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<User>}\n   */\n\n\n  async fetch(user) {\n    let {\n      cache = true,\n      force = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const id = this.resolveId(user);\n\n    if (!force) {\n      const existing = this.cache.get(id);\n      if (existing && !existing.partial) return existing;\n    }\n\n    const data = await this.client.api.users(id).get();\n    return this._add(data, cache);\n  }\n  /**\n   * Fetches a user's flags.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<UserFlags>}\n   */\n\n\n  async fetchFlags(user, options) {\n    return (await this.fetch(user, options)).flags;\n  }\n  /**\n   * Sends a message to a user.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @param {string|MessagePayload|MessageOptions} options The options to provide\n   * @returns {Promise<Message>}\n   */\n\n\n  async send(user, options) {\n    return (await this.createDM(user)).send(options);\n  }\n  /**\n   * Resolves a {@link UserResolvable} to a {@link User} object.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @returns {?User}\n   */\n\n\n  resolve(user) {\n    if (user instanceof GuildMember || user instanceof ThreadMember) return user.user;\n    if (user instanceof Message) return user.author;\n    return super.resolve(user);\n  }\n  /**\n   * Resolves a {@link UserResolvable} to a {@link User} id.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @returns {?Snowflake}\n   */\n\n\n  resolveId(user) {\n    if (user instanceof ThreadMember) return user.id;\n    if (user instanceof GuildMember) return user.user.id;\n    if (user instanceof Message) return user.author.id;\n    return super.resolveId(user);\n  }\n\n}\n\nmodule.exports = UserManager;","map":{"version":3,"names":["CachedManager","require","GuildMember","Message","ThreadMember","User","UserManager","constructor","client","iterable","dmChannel","userId","channels","cache","find","c","type","recipient","id","createDM","user","force","resolveId","partial","data","api","users","post","recipient_id","_add","deleteDM","Error","delete","_remove","fetch","existing","get","fetchFlags","options","flags","send","resolve","author","module","exports"],"sources":["C:/Users/xsxsam/node_modules/discord.js/src/managers/UserManager.js"],"sourcesContent":["'use strict';\n\nconst CachedManager = require('./CachedManager');\nconst { GuildMember } = require('../structures/GuildMember');\nconst { Message } = require('../structures/Message');\nconst ThreadMember = require('../structures/ThreadMember');\nconst User = require('../structures/User');\n\n/**\n * Manages API methods for users and stores their cache.\n * @extends {CachedManager}\n */\nclass UserManager extends CachedManager {\n  constructor(client, iterable) {\n    super(client, User, iterable);\n  }\n\n  /**\n   * The cache of this manager\n   * @type {Collection<Snowflake, User>}\n   * @name UserManager#cache\n   */\n\n  /**\n   * Data that resolves to give a User object. This can be:\n   * * A User object\n   * * A Snowflake\n   * * A Message object (resolves to the message author)\n   * * A GuildMember object\n   * * A ThreadMember object\n   * @typedef {User|Snowflake|Message|GuildMember|ThreadMember} UserResolvable\n   */\n\n  /**\n   * The DM between the client's user and a user\n   * @param {Snowflake} userId The user id\n   * @returns {?DMChannel}\n   * @private\n   */\n  dmChannel(userId) {\n    return this.client.channels.cache.find(c => c.type === 'DM' && c.recipient.id === userId) ?? null;\n  }\n\n  /**\n   * Creates a {@link DMChannel} between the client and a user.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<DMChannel>}\n   */\n  async createDM(user, { cache = true, force = false } = {}) {\n    const id = this.resolveId(user);\n\n    if (!force) {\n      const dmChannel = this.dmChannel(id);\n      if (dmChannel && !dmChannel.partial) return dmChannel;\n    }\n\n    const data = await this.client.api.users(this.client.user.id).channels.post({\n      data: {\n        recipient_id: id,\n      },\n    });\n    return this.client.channels._add(data, null, { cache });\n  }\n\n  /**\n   * Deletes a {@link DMChannel} (if one exists) between the client and a user. Resolves with the channel if successful.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @returns {Promise<DMChannel>}\n   */\n  async deleteDM(user) {\n    const id = this.resolveId(user);\n    const dmChannel = this.dmChannel(id);\n    if (!dmChannel) throw new Error('USER_NO_DM_CHANNEL');\n    await this.client.api.channels(dmChannel.id).delete();\n    this.client.channels._remove(dmChannel.id);\n    return dmChannel;\n  }\n\n  /**\n   * Obtains a user from Discord, or the user cache if it's already available.\n   * @param {UserResolvable} user The user to fetch\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<User>}\n   */\n  async fetch(user, { cache = true, force = false } = {}) {\n    const id = this.resolveId(user);\n    if (!force) {\n      const existing = this.cache.get(id);\n      if (existing && !existing.partial) return existing;\n    }\n\n    const data = await this.client.api.users(id).get();\n    return this._add(data, cache);\n  }\n\n  /**\n   * Fetches a user's flags.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<UserFlags>}\n   */\n  async fetchFlags(user, options) {\n    return (await this.fetch(user, options)).flags;\n  }\n\n  /**\n   * Sends a message to a user.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @param {string|MessagePayload|MessageOptions} options The options to provide\n   * @returns {Promise<Message>}\n   */\n  async send(user, options) {\n    return (await this.createDM(user)).send(options);\n  }\n\n  /**\n   * Resolves a {@link UserResolvable} to a {@link User} object.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @returns {?User}\n   */\n  resolve(user) {\n    if (user instanceof GuildMember || user instanceof ThreadMember) return user.user;\n    if (user instanceof Message) return user.author;\n    return super.resolve(user);\n  }\n\n  /**\n   * Resolves a {@link UserResolvable} to a {@link User} id.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @returns {?Snowflake}\n   */\n  resolveId(user) {\n    if (user instanceof ThreadMember) return user.id;\n    if (user instanceof GuildMember) return user.user.id;\n    if (user instanceof Message) return user.author.id;\n    return super.resolveId(user);\n  }\n}\n\nmodule.exports = UserManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}