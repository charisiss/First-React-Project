{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('node:events');\n\nconst {\n  setImmediate\n} = require('node:timers');\n\nconst {\n  setTimeout: sleep\n} = require('node:timers/promises');\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst {\n  RPCErrorCodes\n} = require('discord-api-types/v9');\n\nconst WebSocketShard = require('./WebSocketShard');\n\nconst PacketHandlers = require('./handlers');\n\nconst {\n  Error\n} = require('../../errors');\n\nconst {\n  Events,\n  ShardEvents,\n  Status,\n  WSCodes,\n  WSEvents\n} = require('../../util/Constants');\n\nconst BeforeReadyWhitelist = [WSEvents.READY, WSEvents.RESUMED, WSEvents.GUILD_CREATE, WSEvents.GUILD_DELETE, WSEvents.GUILD_MEMBERS_CHUNK, WSEvents.GUILD_MEMBER_ADD, WSEvents.GUILD_MEMBER_REMOVE];\nconst UNRECOVERABLE_CLOSE_CODES = Object.keys(WSCodes).slice(1).map(Number);\nconst UNRESUMABLE_CLOSE_CODES = [RPCErrorCodes.UnknownError, RPCErrorCodes.InvalidPermissions, RPCErrorCodes.InvalidClientId];\n/**\n * The WebSocket manager for this client.\n * <info>This class forwards raw dispatch events,\n * read more about it here {@link https://discord.com/developers/docs/topics/gateway}</info>\n * @extends EventEmitter\n */\n\nclass WebSocketManager extends EventEmitter {\n  constructor(client) {\n    super();\n    /**\n     * The client that instantiated this WebSocketManager\n     * @type {Client}\n     * @readonly\n     * @name WebSocketManager#client\n     */\n\n    Object.defineProperty(this, 'client', {\n      value: client\n    });\n    /**\n     * The gateway this manager uses\n     * @type {?string}\n     */\n\n    this.gateway = null;\n    /**\n     * The amount of shards this manager handles\n     * @private\n     * @type {number}\n     */\n\n    this.totalShards = this.client.options.shards.length;\n    /**\n     * A collection of all shards this manager handles\n     * @type {Collection<number, WebSocketShard>}\n     */\n\n    this.shards = new Collection();\n    /**\n     * An array of shards to be connected or that need to reconnect\n     * @type {Set<WebSocketShard>}\n     * @private\n     * @name WebSocketManager#shardQueue\n     */\n\n    Object.defineProperty(this, 'shardQueue', {\n      value: new Set(),\n      writable: true\n    });\n    /**\n     * An array of queued events before this WebSocketManager became ready\n     * @type {Object[]}\n     * @private\n     * @name WebSocketManager#packetQueue\n     */\n\n    Object.defineProperty(this, 'packetQueue', {\n      value: []\n    });\n    /**\n     * The current status of this WebSocketManager\n     * @type {Status}\n     */\n\n    this.status = Status.IDLE;\n    /**\n     * If this manager was destroyed. It will prevent shards from reconnecting\n     * @type {boolean}\n     * @private\n     */\n\n    this.destroyed = false;\n    /**\n     * If this manager is currently reconnecting one or multiple shards\n     * @type {boolean}\n     * @private\n     */\n\n    this.reconnecting = false;\n  }\n  /**\n   * The average ping of all WebSocketShards\n   * @type {number}\n   * @readonly\n   */\n\n\n  get ping() {\n    const sum = this.shards.reduce((a, b) => a + b.ping, 0);\n    return sum / this.shards.size;\n  }\n  /**\n   * Emits a debug message.\n   * @param {string} message The debug message\n   * @param {?WebSocketShard} [shard] The shard that emitted this message, if any\n   * @private\n   */\n\n\n  debug(message, shard) {\n    this.client.emit(Events.DEBUG, `[WS => ${shard ? `Shard ${shard.id}` : 'Manager'}] ${message}`);\n  }\n  /**\n   * Connects this manager to the gateway.\n   * @private\n   */\n\n\n  async connect() {\n    const invalidToken = new Error(WSCodes[4004]);\n    const {\n      url: gatewayURL,\n      shards: recommendedShards,\n      session_start_limit: sessionStartLimit\n    } = await this.client.api.gateway.bot.get().catch(error => {\n      throw error.httpStatus === 401 ? invalidToken : error;\n    });\n    const {\n      total,\n      remaining\n    } = sessionStartLimit;\n    this.debug(`Fetched Gateway Information\n    URL: ${gatewayURL}\n    Recommended Shards: ${recommendedShards}`);\n    this.debug(`Session Limit Information\n    Total: ${total}\n    Remaining: ${remaining}`);\n    this.gateway = `${gatewayURL}/`;\n    let {\n      shards\n    } = this.client.options;\n\n    if (shards === 'auto') {\n      this.debug(`Using the recommended shard count provided by Discord: ${recommendedShards}`);\n      this.totalShards = this.client.options.shardCount = recommendedShards;\n      shards = this.client.options.shards = Array.from({\n        length: recommendedShards\n      }, (_, i) => i);\n    }\n\n    this.totalShards = shards.length;\n    this.debug(`Spawning shards: ${shards.join(', ')}`);\n    this.shardQueue = new Set(shards.map(id => new WebSocketShard(this, id)));\n    return this.createShards();\n  }\n  /**\n   * Handles the creation of a shard.\n   * @returns {Promise<boolean>}\n   * @private\n   */\n\n\n  async createShards() {\n    // If we don't have any shards to handle, return\n    if (!this.shardQueue.size) return false;\n    const [shard] = this.shardQueue;\n    this.shardQueue.delete(shard);\n\n    if (!shard.eventsAttached) {\n      shard.on(ShardEvents.ALL_READY, unavailableGuilds => {\n        /**\n         * Emitted when a shard turns ready.\n         * @event Client#shardReady\n         * @param {number} id The shard id that turned ready\n         * @param {?Set<Snowflake>} unavailableGuilds Set of unavailable guild ids, if any\n         */\n        this.client.emit(Events.SHARD_READY, shard.id, unavailableGuilds);\n        if (!this.shardQueue.size) this.reconnecting = false;\n        this.checkShardsReady();\n      });\n      shard.on(ShardEvents.CLOSE, event => {\n        if (event.code === 1_000 ? this.destroyed : UNRECOVERABLE_CLOSE_CODES.includes(event.code)) {\n          /**\n           * Emitted when a shard's WebSocket disconnects and will no longer reconnect.\n           * @event Client#shardDisconnect\n           * @param {CloseEvent} event The WebSocket close event\n           * @param {number} id The shard id that disconnected\n           */\n          this.client.emit(Events.SHARD_DISCONNECT, event, shard.id);\n          this.debug(WSCodes[event.code], shard);\n          return;\n        }\n\n        if (UNRESUMABLE_CLOSE_CODES.includes(event.code)) {\n          // These event codes cannot be resumed\n          shard.sessionId = null;\n        }\n        /**\n         * Emitted when a shard is attempting to reconnect or re-identify.\n         * @event Client#shardReconnecting\n         * @param {number} id The shard id that is attempting to reconnect\n         */\n\n\n        this.client.emit(Events.SHARD_RECONNECTING, shard.id);\n        this.shardQueue.add(shard);\n\n        if (shard.sessionId) {\n          this.debug(`Session id is present, attempting an immediate reconnect...`, shard);\n          this.reconnect();\n        } else {\n          shard.destroy({\n            reset: true,\n            emit: false,\n            log: false\n          });\n          this.reconnect();\n        }\n      });\n      shard.on(ShardEvents.INVALID_SESSION, () => {\n        this.client.emit(Events.SHARD_RECONNECTING, shard.id);\n      });\n      shard.on(ShardEvents.DESTROYED, () => {\n        this.debug('Shard was destroyed but no WebSocket connection was present! Reconnecting...', shard);\n        this.client.emit(Events.SHARD_RECONNECTING, shard.id);\n        this.shardQueue.add(shard);\n        this.reconnect();\n      });\n      shard.eventsAttached = true;\n    }\n\n    this.shards.set(shard.id, shard);\n\n    try {\n      await shard.connect();\n    } catch (error) {\n      if (error?.code && UNRECOVERABLE_CLOSE_CODES.includes(error.code)) {\n        throw new Error(WSCodes[error.code]); // Undefined if session is invalid, error event for regular closes\n      } else if (!error || error.code) {\n        this.debug('Failed to connect to the gateway, requeueing...', shard);\n        this.shardQueue.add(shard);\n      } else {\n        throw error;\n      }\n    } // If we have more shards, add a 5s delay\n\n\n    if (this.shardQueue.size) {\n      this.debug(`Shard Queue Size: ${this.shardQueue.size}; continuing in 5 seconds...`);\n      await sleep(5_000);\n      return this.createShards();\n    }\n\n    return true;\n  }\n  /**\n   * Handles reconnects for this manager.\n   * @private\n   * @returns {Promise<boolean>}\n   */\n\n\n  async reconnect() {\n    if (this.reconnecting || this.status !== Status.READY) return false;\n    this.reconnecting = true;\n\n    try {\n      await this.createShards();\n    } catch (error) {\n      this.debug(`Couldn't reconnect or fetch information about the gateway. ${error}`);\n\n      if (error.httpStatus !== 401) {\n        this.debug(`Possible network error occurred. Retrying in 5s...`);\n        await sleep(5_000);\n        this.reconnecting = false;\n        return this.reconnect();\n      } // If we get an error at this point, it means we cannot reconnect anymore\n\n\n      if (this.client.listenerCount(Events.INVALIDATED)) {\n        /**\n         * Emitted when the client's session becomes invalidated.\n         * You are expected to handle closing the process gracefully and preventing a boot loop\n         * if you are listening to this event.\n         * @event Client#invalidated\n         */\n        this.client.emit(Events.INVALIDATED); // Destroy just the shards. This means you have to handle the cleanup yourself\n\n        this.destroy();\n      } else {\n        this.client.destroy();\n      }\n    } finally {\n      this.reconnecting = false;\n    }\n\n    return true;\n  }\n  /**\n   * Broadcasts a packet to every shard this manager handles.\n   * @param {Object} packet The packet to send\n   * @private\n   */\n\n\n  broadcast(packet) {\n    for (const shard of this.shards.values()) shard.send(packet);\n  }\n  /**\n   * Destroys this manager and all its shards.\n   * @private\n   */\n\n\n  destroy() {\n    if (this.destroyed) return;\n    this.debug(`Manager was destroyed. Called by:\\n${new Error('MANAGER_DESTROYED').stack}`);\n    this.destroyed = true;\n    this.shardQueue.clear();\n\n    for (const shard of this.shards.values()) shard.destroy({\n      closeCode: 1_000,\n      reset: true,\n      emit: false,\n      log: false\n    });\n  }\n  /**\n   * Processes a packet and queues it if this WebSocketManager is not ready.\n   * @param {Object} [packet] The packet to be handled\n   * @param {WebSocketShard} [shard] The shard that will handle this packet\n   * @returns {boolean}\n   * @private\n   */\n\n\n  handlePacket(packet, shard) {\n    if (packet && this.status !== Status.READY) {\n      if (!BeforeReadyWhitelist.includes(packet.t)) {\n        this.packetQueue.push({\n          packet,\n          shard\n        });\n        return false;\n      }\n    }\n\n    if (this.packetQueue.length) {\n      const item = this.packetQueue.shift();\n      setImmediate(() => {\n        this.handlePacket(item.packet, item.shard);\n      }).unref();\n    }\n\n    if (packet && PacketHandlers[packet.t]) {\n      PacketHandlers[packet.t](this.client, packet, shard);\n    }\n\n    return true;\n  }\n  /**\n   * Checks whether the client is ready to be marked as ready.\n   * @private\n   */\n\n\n  checkShardsReady() {\n    if (this.status === Status.READY) return;\n\n    if (this.shards.size !== this.totalShards || this.shards.some(s => s.status !== Status.READY)) {\n      return;\n    }\n\n    this.triggerClientReady();\n  }\n  /**\n   * Causes the client to be marked as ready and emits the ready event.\n   * @private\n   */\n\n\n  triggerClientReady() {\n    this.status = Status.READY;\n    this.client.readyAt = new Date();\n    /**\n     * Emitted when the client becomes ready to start working.\n     * @event Client#ready\n     * @param {Client} client The client\n     */\n\n    this.client.emit(Events.CLIENT_READY, this.client);\n    this.handlePacket();\n  }\n\n}\n\nmodule.exports = WebSocketManager;","map":{"version":3,"names":["EventEmitter","require","setImmediate","setTimeout","sleep","Collection","RPCErrorCodes","WebSocketShard","PacketHandlers","Error","Events","ShardEvents","Status","WSCodes","WSEvents","BeforeReadyWhitelist","READY","RESUMED","GUILD_CREATE","GUILD_DELETE","GUILD_MEMBERS_CHUNK","GUILD_MEMBER_ADD","GUILD_MEMBER_REMOVE","UNRECOVERABLE_CLOSE_CODES","Object","keys","slice","map","Number","UNRESUMABLE_CLOSE_CODES","UnknownError","InvalidPermissions","InvalidClientId","WebSocketManager","constructor","client","defineProperty","value","gateway","totalShards","options","shards","length","Set","writable","status","IDLE","destroyed","reconnecting","ping","sum","reduce","a","b","size","debug","message","shard","emit","DEBUG","id","connect","invalidToken","url","gatewayURL","recommendedShards","session_start_limit","sessionStartLimit","api","bot","get","catch","error","httpStatus","total","remaining","shardCount","Array","from","_","i","join","shardQueue","createShards","delete","eventsAttached","on","ALL_READY","unavailableGuilds","SHARD_READY","checkShardsReady","CLOSE","event","code","includes","SHARD_DISCONNECT","sessionId","SHARD_RECONNECTING","add","reconnect","destroy","reset","log","INVALID_SESSION","DESTROYED","set","listenerCount","INVALIDATED","broadcast","packet","values","send","stack","clear","closeCode","handlePacket","t","packetQueue","push","item","shift","unref","some","s","triggerClientReady","readyAt","Date","CLIENT_READY","module","exports"],"sources":["C:/Users/xsxsam/node_modules/discord.js/src/client/websocket/WebSocketManager.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('node:events');\nconst { setImmediate } = require('node:timers');\nconst { setTimeout: sleep } = require('node:timers/promises');\nconst { Collection } = require('@discordjs/collection');\nconst { RPCErrorCodes } = require('discord-api-types/v9');\nconst WebSocketShard = require('./WebSocketShard');\nconst PacketHandlers = require('./handlers');\nconst { Error } = require('../../errors');\nconst { Events, ShardEvents, Status, WSCodes, WSEvents } = require('../../util/Constants');\n\nconst BeforeReadyWhitelist = [\n  WSEvents.READY,\n  WSEvents.RESUMED,\n  WSEvents.GUILD_CREATE,\n  WSEvents.GUILD_DELETE,\n  WSEvents.GUILD_MEMBERS_CHUNK,\n  WSEvents.GUILD_MEMBER_ADD,\n  WSEvents.GUILD_MEMBER_REMOVE,\n];\n\nconst UNRECOVERABLE_CLOSE_CODES = Object.keys(WSCodes).slice(1).map(Number);\nconst UNRESUMABLE_CLOSE_CODES = [\n  RPCErrorCodes.UnknownError,\n  RPCErrorCodes.InvalidPermissions,\n  RPCErrorCodes.InvalidClientId,\n];\n\n/**\n * The WebSocket manager for this client.\n * <info>This class forwards raw dispatch events,\n * read more about it here {@link https://discord.com/developers/docs/topics/gateway}</info>\n * @extends EventEmitter\n */\nclass WebSocketManager extends EventEmitter {\n  constructor(client) {\n    super();\n\n    /**\n     * The client that instantiated this WebSocketManager\n     * @type {Client}\n     * @readonly\n     * @name WebSocketManager#client\n     */\n    Object.defineProperty(this, 'client', { value: client });\n\n    /**\n     * The gateway this manager uses\n     * @type {?string}\n     */\n    this.gateway = null;\n\n    /**\n     * The amount of shards this manager handles\n     * @private\n     * @type {number}\n     */\n    this.totalShards = this.client.options.shards.length;\n\n    /**\n     * A collection of all shards this manager handles\n     * @type {Collection<number, WebSocketShard>}\n     */\n    this.shards = new Collection();\n\n    /**\n     * An array of shards to be connected or that need to reconnect\n     * @type {Set<WebSocketShard>}\n     * @private\n     * @name WebSocketManager#shardQueue\n     */\n    Object.defineProperty(this, 'shardQueue', { value: new Set(), writable: true });\n\n    /**\n     * An array of queued events before this WebSocketManager became ready\n     * @type {Object[]}\n     * @private\n     * @name WebSocketManager#packetQueue\n     */\n    Object.defineProperty(this, 'packetQueue', { value: [] });\n\n    /**\n     * The current status of this WebSocketManager\n     * @type {Status}\n     */\n    this.status = Status.IDLE;\n\n    /**\n     * If this manager was destroyed. It will prevent shards from reconnecting\n     * @type {boolean}\n     * @private\n     */\n    this.destroyed = false;\n\n    /**\n     * If this manager is currently reconnecting one or multiple shards\n     * @type {boolean}\n     * @private\n     */\n    this.reconnecting = false;\n  }\n\n  /**\n   * The average ping of all WebSocketShards\n   * @type {number}\n   * @readonly\n   */\n  get ping() {\n    const sum = this.shards.reduce((a, b) => a + b.ping, 0);\n    return sum / this.shards.size;\n  }\n\n  /**\n   * Emits a debug message.\n   * @param {string} message The debug message\n   * @param {?WebSocketShard} [shard] The shard that emitted this message, if any\n   * @private\n   */\n  debug(message, shard) {\n    this.client.emit(Events.DEBUG, `[WS => ${shard ? `Shard ${shard.id}` : 'Manager'}] ${message}`);\n  }\n\n  /**\n   * Connects this manager to the gateway.\n   * @private\n   */\n  async connect() {\n    const invalidToken = new Error(WSCodes[4004]);\n    const {\n      url: gatewayURL,\n      shards: recommendedShards,\n      session_start_limit: sessionStartLimit,\n    } = await this.client.api.gateway.bot.get().catch(error => {\n      throw error.httpStatus === 401 ? invalidToken : error;\n    });\n\n    const { total, remaining } = sessionStartLimit;\n\n    this.debug(`Fetched Gateway Information\n    URL: ${gatewayURL}\n    Recommended Shards: ${recommendedShards}`);\n\n    this.debug(`Session Limit Information\n    Total: ${total}\n    Remaining: ${remaining}`);\n\n    this.gateway = `${gatewayURL}/`;\n\n    let { shards } = this.client.options;\n\n    if (shards === 'auto') {\n      this.debug(`Using the recommended shard count provided by Discord: ${recommendedShards}`);\n      this.totalShards = this.client.options.shardCount = recommendedShards;\n      shards = this.client.options.shards = Array.from({ length: recommendedShards }, (_, i) => i);\n    }\n\n    this.totalShards = shards.length;\n    this.debug(`Spawning shards: ${shards.join(', ')}`);\n    this.shardQueue = new Set(shards.map(id => new WebSocketShard(this, id)));\n\n    return this.createShards();\n  }\n\n  /**\n   * Handles the creation of a shard.\n   * @returns {Promise<boolean>}\n   * @private\n   */\n  async createShards() {\n    // If we don't have any shards to handle, return\n    if (!this.shardQueue.size) return false;\n\n    const [shard] = this.shardQueue;\n\n    this.shardQueue.delete(shard);\n\n    if (!shard.eventsAttached) {\n      shard.on(ShardEvents.ALL_READY, unavailableGuilds => {\n        /**\n         * Emitted when a shard turns ready.\n         * @event Client#shardReady\n         * @param {number} id The shard id that turned ready\n         * @param {?Set<Snowflake>} unavailableGuilds Set of unavailable guild ids, if any\n         */\n        this.client.emit(Events.SHARD_READY, shard.id, unavailableGuilds);\n\n        if (!this.shardQueue.size) this.reconnecting = false;\n        this.checkShardsReady();\n      });\n\n      shard.on(ShardEvents.CLOSE, event => {\n        if (event.code === 1_000 ? this.destroyed : UNRECOVERABLE_CLOSE_CODES.includes(event.code)) {\n          /**\n           * Emitted when a shard's WebSocket disconnects and will no longer reconnect.\n           * @event Client#shardDisconnect\n           * @param {CloseEvent} event The WebSocket close event\n           * @param {number} id The shard id that disconnected\n           */\n          this.client.emit(Events.SHARD_DISCONNECT, event, shard.id);\n          this.debug(WSCodes[event.code], shard);\n          return;\n        }\n\n        if (UNRESUMABLE_CLOSE_CODES.includes(event.code)) {\n          // These event codes cannot be resumed\n          shard.sessionId = null;\n        }\n\n        /**\n         * Emitted when a shard is attempting to reconnect or re-identify.\n         * @event Client#shardReconnecting\n         * @param {number} id The shard id that is attempting to reconnect\n         */\n        this.client.emit(Events.SHARD_RECONNECTING, shard.id);\n\n        this.shardQueue.add(shard);\n\n        if (shard.sessionId) {\n          this.debug(`Session id is present, attempting an immediate reconnect...`, shard);\n          this.reconnect();\n        } else {\n          shard.destroy({ reset: true, emit: false, log: false });\n          this.reconnect();\n        }\n      });\n\n      shard.on(ShardEvents.INVALID_SESSION, () => {\n        this.client.emit(Events.SHARD_RECONNECTING, shard.id);\n      });\n\n      shard.on(ShardEvents.DESTROYED, () => {\n        this.debug('Shard was destroyed but no WebSocket connection was present! Reconnecting...', shard);\n\n        this.client.emit(Events.SHARD_RECONNECTING, shard.id);\n\n        this.shardQueue.add(shard);\n        this.reconnect();\n      });\n\n      shard.eventsAttached = true;\n    }\n\n    this.shards.set(shard.id, shard);\n\n    try {\n      await shard.connect();\n    } catch (error) {\n      if (error?.code && UNRECOVERABLE_CLOSE_CODES.includes(error.code)) {\n        throw new Error(WSCodes[error.code]);\n        // Undefined if session is invalid, error event for regular closes\n      } else if (!error || error.code) {\n        this.debug('Failed to connect to the gateway, requeueing...', shard);\n        this.shardQueue.add(shard);\n      } else {\n        throw error;\n      }\n    }\n    // If we have more shards, add a 5s delay\n    if (this.shardQueue.size) {\n      this.debug(`Shard Queue Size: ${this.shardQueue.size}; continuing in 5 seconds...`);\n      await sleep(5_000);\n      return this.createShards();\n    }\n\n    return true;\n  }\n\n  /**\n   * Handles reconnects for this manager.\n   * @private\n   * @returns {Promise<boolean>}\n   */\n  async reconnect() {\n    if (this.reconnecting || this.status !== Status.READY) return false;\n    this.reconnecting = true;\n    try {\n      await this.createShards();\n    } catch (error) {\n      this.debug(`Couldn't reconnect or fetch information about the gateway. ${error}`);\n      if (error.httpStatus !== 401) {\n        this.debug(`Possible network error occurred. Retrying in 5s...`);\n        await sleep(5_000);\n        this.reconnecting = false;\n        return this.reconnect();\n      }\n      // If we get an error at this point, it means we cannot reconnect anymore\n      if (this.client.listenerCount(Events.INVALIDATED)) {\n        /**\n         * Emitted when the client's session becomes invalidated.\n         * You are expected to handle closing the process gracefully and preventing a boot loop\n         * if you are listening to this event.\n         * @event Client#invalidated\n         */\n        this.client.emit(Events.INVALIDATED);\n        // Destroy just the shards. This means you have to handle the cleanup yourself\n        this.destroy();\n      } else {\n        this.client.destroy();\n      }\n    } finally {\n      this.reconnecting = false;\n    }\n    return true;\n  }\n\n  /**\n   * Broadcasts a packet to every shard this manager handles.\n   * @param {Object} packet The packet to send\n   * @private\n   */\n  broadcast(packet) {\n    for (const shard of this.shards.values()) shard.send(packet);\n  }\n\n  /**\n   * Destroys this manager and all its shards.\n   * @private\n   */\n  destroy() {\n    if (this.destroyed) return;\n    this.debug(`Manager was destroyed. Called by:\\n${new Error('MANAGER_DESTROYED').stack}`);\n    this.destroyed = true;\n    this.shardQueue.clear();\n    for (const shard of this.shards.values()) shard.destroy({ closeCode: 1_000, reset: true, emit: false, log: false });\n  }\n\n  /**\n   * Processes a packet and queues it if this WebSocketManager is not ready.\n   * @param {Object} [packet] The packet to be handled\n   * @param {WebSocketShard} [shard] The shard that will handle this packet\n   * @returns {boolean}\n   * @private\n   */\n  handlePacket(packet, shard) {\n    if (packet && this.status !== Status.READY) {\n      if (!BeforeReadyWhitelist.includes(packet.t)) {\n        this.packetQueue.push({ packet, shard });\n        return false;\n      }\n    }\n\n    if (this.packetQueue.length) {\n      const item = this.packetQueue.shift();\n      setImmediate(() => {\n        this.handlePacket(item.packet, item.shard);\n      }).unref();\n    }\n\n    if (packet && PacketHandlers[packet.t]) {\n      PacketHandlers[packet.t](this.client, packet, shard);\n    }\n\n    return true;\n  }\n\n  /**\n   * Checks whether the client is ready to be marked as ready.\n   * @private\n   */\n  checkShardsReady() {\n    if (this.status === Status.READY) return;\n    if (this.shards.size !== this.totalShards || this.shards.some(s => s.status !== Status.READY)) {\n      return;\n    }\n\n    this.triggerClientReady();\n  }\n\n  /**\n   * Causes the client to be marked as ready and emits the ready event.\n   * @private\n   */\n  triggerClientReady() {\n    this.status = Status.READY;\n\n    this.client.readyAt = new Date();\n\n    /**\n     * Emitted when the client becomes ready to start working.\n     * @event Client#ready\n     * @param {Client} client The client\n     */\n    this.client.emit(Events.CLIENT_READY, this.client);\n\n    this.handlePacket();\n  }\n}\n\nmodule.exports = WebSocketManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}