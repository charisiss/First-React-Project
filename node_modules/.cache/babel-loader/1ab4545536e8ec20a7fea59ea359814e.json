{"ast":null,"code":"'use strict';\n\nconst process = require('node:process');\n\nconst MessagePayload = require('./MessagePayload');\n\nconst {\n  Error\n} = require('../errors');\n\nconst {\n  WebhookTypes\n} = require('../util/Constants');\n\nconst DataResolver = require('../util/DataResolver');\n\nconst SnowflakeUtil = require('../util/SnowflakeUtil');\n\nlet deprecationEmittedForFetchMessage = false;\n/**\n * Represents a webhook.\n */\n\nclass Webhook {\n  constructor(client, data) {\n    /**\n     * The client that instantiated the webhook\n     * @name Webhook#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', {\n      value: client\n    });\n    if (data) this._patch(data);\n  }\n\n  _patch(data) {\n    if ('name' in data) {\n      /**\n       * The name of the webhook\n       * @type {string}\n       */\n      this.name = data.name;\n    }\n    /**\n     * The token for the webhook, unavailable for follower webhooks and webhooks owned by another application.\n     * @name Webhook#token\n     * @type {?string}\n     */\n\n\n    Object.defineProperty(this, 'token', {\n      value: data.token ?? null,\n      writable: true,\n      configurable: true\n    });\n\n    if ('avatar' in data) {\n      /**\n       * The avatar for the webhook\n       * @type {?string}\n       */\n      this.avatar = data.avatar;\n    }\n    /**\n     * The webhook's id\n     * @type {Snowflake}\n     */\n\n\n    this.id = data.id;\n\n    if ('type' in data) {\n      /**\n       * The type of the webhook\n       * @type {WebhookType}\n       */\n      this.type = WebhookTypes[data.type];\n    }\n\n    if ('guild_id' in data) {\n      /**\n       * The guild the webhook belongs to\n       * @type {Snowflake}\n       */\n      this.guildId = data.guild_id;\n    }\n\n    if ('channel_id' in data) {\n      /**\n       * The channel the webhook belongs to\n       * @type {Snowflake}\n       */\n      this.channelId = data.channel_id;\n    }\n\n    if ('user' in data) {\n      /**\n       * The owner of the webhook\n       * @type {?(User|APIUser)}\n       */\n      this.owner = this.client.users?._add(data.user) ?? data.user;\n    } else {\n      this.owner ??= null;\n    }\n\n    if ('source_guild' in data) {\n      /**\n       * The source guild of the webhook\n       * @type {?(Guild|APIGuild)}\n       */\n      this.sourceGuild = this.client.guilds?.resolve(data.source_guild.id) ?? data.source_guild;\n    } else {\n      this.sourceGuild ??= null;\n    }\n\n    if ('source_channel' in data) {\n      /**\n       * The source channel of the webhook\n       * @type {?(NewsChannel|APIChannel)}\n       */\n      this.sourceChannel = this.client.channels?.resolve(data.source_channel?.id) ?? data.source_channel;\n    } else {\n      this.sourceChannel ??= null;\n    }\n  }\n  /**\n   * Options that can be passed into send.\n   * @typedef {BaseMessageOptions} WebhookMessageOptions\n   * @property {string} [username=this.name] Username override for the message\n   * @property {string} [avatarURL] Avatar URL override for the message\n   * @property {Snowflake} [threadId] The id of the thread in the channel to send to.\n   * <info>For interaction webhooks, this property is ignored</info>\n   */\n\n  /**\n   * Options that can be passed into editMessage.\n   * @typedef {Object} WebhookEditMessageOptions\n   * @property {MessageEmbed[]|APIEmbed[]} [embeds] See {@link WebhookMessageOptions#embeds}\n   * @property {string} [content] See {@link BaseMessageOptions#content}\n   * @property {FileOptions[]|BufferResolvable[]|MessageAttachment[]} [files] See {@link BaseMessageOptions#files}\n   * @property {MessageMentionOptions} [allowedMentions] See {@link BaseMessageOptions#allowedMentions}\n   * @property {MessageAttachment[]} [attachments] Attachments to send with the message\n   * @property {MessageActionRow[]|MessageActionRowOptions[]} [components]\n   * Action rows containing interactive components for the message (buttons, select menus)\n   * @property {Snowflake} [threadId] The id of the thread this message belongs to\n   * <info>For interaction webhooks, this property is ignored</info>\n   */\n\n  /**\n   * Sends a message with this webhook.\n   * @param {string|MessagePayload|WebhookMessageOptions} options The options to provide\n   * @returns {Promise<Message|APIMessage>}\n   * @example\n   * // Send a basic message\n   * webhook.send('hello!')\n   *   .then(message => console.log(`Sent message: ${message.content}`))\n   *   .catch(console.error);\n   * @example\n   * // Send a basic message in a thread\n   * webhook.send({ content: 'hello!', threadId: '836856309672348295' })\n   *   .then(message => console.log(`Sent message: ${message.content}`))\n   *   .catch(console.error);\n   * @example\n   * // Send a remote file\n   * webhook.send({\n   *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send a local file\n   * webhook.send({\n   *   files: [{\n   *     attachment: 'entire/path/to/file.jpg',\n   *     name: 'file.jpg'\n   *   }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send an embed with a local image inside\n   * webhook.send({\n   *   content: 'This is an embed',\n   *   embeds: [{\n   *     thumbnail: {\n   *          url: 'attachment://file.jpg'\n   *       }\n   *    }],\n   *    files: [{\n   *       attachment: 'entire/path/to/file.jpg',\n   *       name: 'file.jpg'\n   *    }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  async send(options) {\n    if (!this.token) throw new Error('WEBHOOK_TOKEN_UNAVAILABLE');\n    let messagePayload;\n\n    if (options instanceof MessagePayload) {\n      messagePayload = options.resolveData();\n    } else {\n      messagePayload = MessagePayload.create(this, options).resolveData();\n    }\n\n    const {\n      data,\n      files\n    } = await messagePayload.resolveFiles();\n    const d = await this.client.api.webhooks(this.id, this.token).post({\n      data,\n      files,\n      query: {\n        thread_id: messagePayload.options.threadId,\n        wait: true\n      },\n      auth: false\n    });\n    return this.client.channels?.cache.get(d.channel_id)?.messages._add(d, false) ?? d;\n  }\n  /**\n   * Sends a raw slack message with this webhook.\n   * @param {Object} body The raw body to send\n   * @returns {Promise<boolean>}\n   * @example\n   * // Send a slack message\n   * webhook.sendSlackMessage({\n   *   'username': 'Wumpus',\n   *   'attachments': [{\n   *     'pretext': 'this looks pretty cool',\n   *     'color': '#F0F',\n   *     'footer_icon': 'http://snek.s3.amazonaws.com/topSnek.png',\n   *     'footer': 'Powered by sneks',\n   *     'ts': Date.now() / 1_000\n   *   }]\n   * }).catch(console.error);\n   * @see {@link https://api.slack.com/messaging/webhooks}\n   */\n\n\n  async sendSlackMessage(body) {\n    if (!this.token) throw new Error('WEBHOOK_TOKEN_UNAVAILABLE');\n    const data = await this.client.api.webhooks(this.id, this.token).slack.post({\n      query: {\n        wait: true\n      },\n      auth: false,\n      data: body\n    });\n    return data.toString() === 'ok';\n  }\n  /**\n   * Options used to edit a {@link Webhook}.\n   * @typedef {Object} WebhookEditData\n   * @property {string} [name=this.name] The new name for the webhook\n   * @property {?(BufferResolvable)} [avatar] The new avatar for the webhook\n   * @property {GuildTextChannelResolvable} [channel] The new channel for the webhook\n   */\n\n  /**\n   * Edits this webhook.\n   * @param {WebhookEditData} options Options for editing the webhook\n   * @param {string} [reason] Reason for editing the webhook\n   * @returns {Promise<Webhook>}\n   */\n\n\n  async edit(_ref, reason) {\n    let {\n      name = this.name,\n      avatar,\n      channel\n    } = _ref;\n\n    if (avatar && !(typeof avatar === 'string' && avatar.startsWith('data:'))) {\n      avatar = await DataResolver.resolveImage(avatar);\n    }\n\n    channel &&= channel.id ?? channel;\n    const data = await this.client.api.webhooks(this.id, channel ? undefined : this.token).patch({\n      data: {\n        name,\n        avatar,\n        channel_id: channel\n      },\n      reason,\n      auth: !this.token || Boolean(channel)\n    });\n    this.name = data.name;\n    this.avatar = data.avatar;\n    this.channelId = data.channel_id;\n    return this;\n  }\n  /**\n   * Options that can be passed into fetchMessage.\n   * @typedef {options} WebhookFetchMessageOptions\n   * @property {boolean} [cache=true] Whether to cache the message.\n   * @property {Snowflake} [threadId] The id of the thread this message belongs to.\n   * <info>For interaction webhooks, this property is ignored</info>\n   */\n\n  /**\n   * Gets a message that was sent by this webhook.\n   * @param {Snowflake|'@original'} message The id of the message to fetch\n   * @param {WebhookFetchMessageOptions|boolean} [cacheOrOptions={}] The options to provide to fetch the message.\n   * <warn>A **deprecated** boolean may be passed instead to specify whether to cache the message.</warn>\n   * @returns {Promise<Message|APIMessage>} Returns the raw message data if the webhook was instantiated as a\n   * {@link WebhookClient} or if the channel is uncached, otherwise a {@link Message} will be returned\n   */\n\n\n  async fetchMessage(message) {\n    let cacheOrOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      cache: true\n    };\n\n    if (typeof cacheOrOptions === 'boolean') {\n      if (!deprecationEmittedForFetchMessage) {\n        process.emitWarning('Passing a boolean to cache the message in Webhook#fetchMessage is deprecated. Pass an object instead.', 'DeprecationWarning');\n        deprecationEmittedForFetchMessage = true;\n      }\n\n      cacheOrOptions = {\n        cache: cacheOrOptions\n      };\n    }\n\n    if (!this.token) throw new Error('WEBHOOK_TOKEN_UNAVAILABLE');\n    const data = await this.client.api.webhooks(this.id, this.token).messages(message).get({\n      query: {\n        thread_id: cacheOrOptions.threadId\n      },\n      auth: false\n    });\n    return this.client.channels?.cache.get(data.channel_id)?.messages._add(data, cacheOrOptions.cache) ?? data;\n  }\n  /**\n   * Edits a message that was sent by this webhook.\n   * @param {MessageResolvable|'@original'} message The message to edit\n   * @param {string|MessagePayload|WebhookEditMessageOptions} options The options to provide\n   * @returns {Promise<Message|APIMessage>} Returns the raw message data if the webhook was instantiated as a\n   * {@link WebhookClient} or if the channel is uncached, otherwise a {@link Message} will be returned\n   */\n\n\n  async editMessage(message, options) {\n    if (!this.token) throw new Error('WEBHOOK_TOKEN_UNAVAILABLE');\n    let messagePayload;\n    if (options instanceof MessagePayload) messagePayload = options;else messagePayload = MessagePayload.create(this, options);\n    const {\n      data,\n      files\n    } = await messagePayload.resolveData().resolveFiles();\n    const d = await this.client.api.webhooks(this.id, this.token).messages(typeof message === 'string' ? message : message.id).patch({\n      data,\n      files,\n      query: {\n        thread_id: messagePayload.options.threadId\n      },\n      auth: false\n    });\n    const messageManager = this.client.channels?.cache.get(d.channel_id)?.messages;\n    if (!messageManager) return d;\n    const existing = messageManager.cache.get(d.id);\n    if (!existing) return messageManager._add(d);\n\n    const clone = existing._clone();\n\n    clone._patch(d);\n\n    return clone;\n  }\n  /**\n   * Deletes the webhook.\n   * @param {string} [reason] Reason for deleting this webhook\n   * @returns {Promise<void>}\n   */\n\n\n  async delete(reason) {\n    await this.client.api.webhooks(this.id, this.token).delete({\n      reason,\n      auth: !this.token\n    });\n  }\n  /**\n   * Delete a message that was sent by this webhook.\n   * @param {MessageResolvable|'@original'} message The message to delete\n   * @param {Snowflake} [threadId] The id of the thread this message belongs to\n   * @returns {Promise<void>}\n   */\n\n\n  async deleteMessage(message, threadId) {\n    if (!this.token) throw new Error('WEBHOOK_TOKEN_UNAVAILABLE');\n    await this.client.api.webhooks(this.id, this.token).messages(typeof message === 'string' ? message : message.id).delete({\n      query: {\n        thread_id: threadId\n      },\n      auth: false\n    });\n  }\n  /**\n   * The timestamp the webhook was created at\n   * @type {number}\n   * @readonly\n   */\n\n\n  get createdTimestamp() {\n    return SnowflakeUtil.timestampFrom(this.id);\n  }\n  /**\n   * The time the webhook was created at\n   * @type {Date}\n   * @readonly\n   */\n\n\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n  /**\n   * The URL of this webhook\n   * @type {string}\n   * @readonly\n   */\n\n\n  get url() {\n    return this.client.options.http.api + this.client.api.webhooks(this.id, this.token);\n  }\n  /**\n   * A link to the webhook's avatar.\n   * @param {StaticImageURLOptions} [options={}] Options for the Image URL\n   * @returns {?string}\n   */\n\n\n  avatarURL() {\n    let {\n      format,\n      size\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!this.avatar) return null;\n    return this.client.rest.cdn.Avatar(this.id, this.avatar, format, size);\n  }\n  /**\n   * Whether or not this webhook is a channel follower webhook.\n   * @returns {boolean}\n   */\n\n\n  isChannelFollower() {\n    return this.type === 'Channel Follower';\n  }\n  /**\n   * Whether or not this webhook is an incoming webhook.\n   * @returns {boolean}\n   */\n\n\n  isIncoming() {\n    return this.type === 'Incoming';\n  }\n\n  static applyToClass(structure) {\n    let ignore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    for (const prop of ['send', 'sendSlackMessage', 'fetchMessage', 'edit', 'editMessage', 'delete', 'deleteMessage', 'createdTimestamp', 'createdAt', 'url']) {\n      if (ignore.includes(prop)) continue;\n      Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(Webhook.prototype, prop));\n    }\n  }\n\n}\n\nmodule.exports = Webhook;","map":{"version":3,"names":["process","require","MessagePayload","Error","WebhookTypes","DataResolver","SnowflakeUtil","deprecationEmittedForFetchMessage","Webhook","constructor","client","data","Object","defineProperty","value","_patch","name","token","writable","configurable","avatar","id","type","guildId","guild_id","channelId","channel_id","owner","users","_add","user","sourceGuild","guilds","resolve","source_guild","sourceChannel","channels","source_channel","send","options","messagePayload","resolveData","create","files","resolveFiles","d","api","webhooks","post","query","thread_id","threadId","wait","auth","cache","get","messages","sendSlackMessage","body","slack","toString","edit","reason","channel","startsWith","resolveImage","undefined","patch","Boolean","fetchMessage","message","cacheOrOptions","emitWarning","editMessage","messageManager","existing","clone","_clone","delete","deleteMessage","createdTimestamp","timestampFrom","createdAt","Date","url","http","avatarURL","format","size","rest","cdn","Avatar","isChannelFollower","isIncoming","applyToClass","structure","ignore","prop","includes","prototype","getOwnPropertyDescriptor","module","exports"],"sources":["C:/Users/xsxsam/node_modules/discord.js/src/structures/Webhook.js"],"sourcesContent":["'use strict';\n\nconst process = require('node:process');\nconst MessagePayload = require('./MessagePayload');\nconst { Error } = require('../errors');\nconst { WebhookTypes } = require('../util/Constants');\nconst DataResolver = require('../util/DataResolver');\nconst SnowflakeUtil = require('../util/SnowflakeUtil');\n\nlet deprecationEmittedForFetchMessage = false;\n\n/**\n * Represents a webhook.\n */\nclass Webhook {\n  constructor(client, data) {\n    /**\n     * The client that instantiated the webhook\n     * @name Webhook#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', { value: client });\n    if (data) this._patch(data);\n  }\n\n  _patch(data) {\n    if ('name' in data) {\n      /**\n       * The name of the webhook\n       * @type {string}\n       */\n      this.name = data.name;\n    }\n\n    /**\n     * The token for the webhook, unavailable for follower webhooks and webhooks owned by another application.\n     * @name Webhook#token\n     * @type {?string}\n     */\n    Object.defineProperty(this, 'token', { value: data.token ?? null, writable: true, configurable: true });\n\n    if ('avatar' in data) {\n      /**\n       * The avatar for the webhook\n       * @type {?string}\n       */\n      this.avatar = data.avatar;\n    }\n\n    /**\n     * The webhook's id\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n\n    if ('type' in data) {\n      /**\n       * The type of the webhook\n       * @type {WebhookType}\n       */\n      this.type = WebhookTypes[data.type];\n    }\n\n    if ('guild_id' in data) {\n      /**\n       * The guild the webhook belongs to\n       * @type {Snowflake}\n       */\n      this.guildId = data.guild_id;\n    }\n\n    if ('channel_id' in data) {\n      /**\n       * The channel the webhook belongs to\n       * @type {Snowflake}\n       */\n      this.channelId = data.channel_id;\n    }\n\n    if ('user' in data) {\n      /**\n       * The owner of the webhook\n       * @type {?(User|APIUser)}\n       */\n      this.owner = this.client.users?._add(data.user) ?? data.user;\n    } else {\n      this.owner ??= null;\n    }\n\n    if ('source_guild' in data) {\n      /**\n       * The source guild of the webhook\n       * @type {?(Guild|APIGuild)}\n       */\n      this.sourceGuild = this.client.guilds?.resolve(data.source_guild.id) ?? data.source_guild;\n    } else {\n      this.sourceGuild ??= null;\n    }\n\n    if ('source_channel' in data) {\n      /**\n       * The source channel of the webhook\n       * @type {?(NewsChannel|APIChannel)}\n       */\n      this.sourceChannel = this.client.channels?.resolve(data.source_channel?.id) ?? data.source_channel;\n    } else {\n      this.sourceChannel ??= null;\n    }\n  }\n\n  /**\n   * Options that can be passed into send.\n   * @typedef {BaseMessageOptions} WebhookMessageOptions\n   * @property {string} [username=this.name] Username override for the message\n   * @property {string} [avatarURL] Avatar URL override for the message\n   * @property {Snowflake} [threadId] The id of the thread in the channel to send to.\n   * <info>For interaction webhooks, this property is ignored</info>\n   */\n\n  /**\n   * Options that can be passed into editMessage.\n   * @typedef {Object} WebhookEditMessageOptions\n   * @property {MessageEmbed[]|APIEmbed[]} [embeds] See {@link WebhookMessageOptions#embeds}\n   * @property {string} [content] See {@link BaseMessageOptions#content}\n   * @property {FileOptions[]|BufferResolvable[]|MessageAttachment[]} [files] See {@link BaseMessageOptions#files}\n   * @property {MessageMentionOptions} [allowedMentions] See {@link BaseMessageOptions#allowedMentions}\n   * @property {MessageAttachment[]} [attachments] Attachments to send with the message\n   * @property {MessageActionRow[]|MessageActionRowOptions[]} [components]\n   * Action rows containing interactive components for the message (buttons, select menus)\n   * @property {Snowflake} [threadId] The id of the thread this message belongs to\n   * <info>For interaction webhooks, this property is ignored</info>\n   */\n\n  /**\n   * Sends a message with this webhook.\n   * @param {string|MessagePayload|WebhookMessageOptions} options The options to provide\n   * @returns {Promise<Message|APIMessage>}\n   * @example\n   * // Send a basic message\n   * webhook.send('hello!')\n   *   .then(message => console.log(`Sent message: ${message.content}`))\n   *   .catch(console.error);\n   * @example\n   * // Send a basic message in a thread\n   * webhook.send({ content: 'hello!', threadId: '836856309672348295' })\n   *   .then(message => console.log(`Sent message: ${message.content}`))\n   *   .catch(console.error);\n   * @example\n   * // Send a remote file\n   * webhook.send({\n   *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send a local file\n   * webhook.send({\n   *   files: [{\n   *     attachment: 'entire/path/to/file.jpg',\n   *     name: 'file.jpg'\n   *   }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send an embed with a local image inside\n   * webhook.send({\n   *   content: 'This is an embed',\n   *   embeds: [{\n   *     thumbnail: {\n   *          url: 'attachment://file.jpg'\n   *       }\n   *    }],\n   *    files: [{\n   *       attachment: 'entire/path/to/file.jpg',\n   *       name: 'file.jpg'\n   *    }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async send(options) {\n    if (!this.token) throw new Error('WEBHOOK_TOKEN_UNAVAILABLE');\n\n    let messagePayload;\n\n    if (options instanceof MessagePayload) {\n      messagePayload = options.resolveData();\n    } else {\n      messagePayload = MessagePayload.create(this, options).resolveData();\n    }\n\n    const { data, files } = await messagePayload.resolveFiles();\n    const d = await this.client.api.webhooks(this.id, this.token).post({\n      data,\n      files,\n      query: { thread_id: messagePayload.options.threadId, wait: true },\n      auth: false,\n    });\n    return this.client.channels?.cache.get(d.channel_id)?.messages._add(d, false) ?? d;\n  }\n\n  /**\n   * Sends a raw slack message with this webhook.\n   * @param {Object} body The raw body to send\n   * @returns {Promise<boolean>}\n   * @example\n   * // Send a slack message\n   * webhook.sendSlackMessage({\n   *   'username': 'Wumpus',\n   *   'attachments': [{\n   *     'pretext': 'this looks pretty cool',\n   *     'color': '#F0F',\n   *     'footer_icon': 'http://snek.s3.amazonaws.com/topSnek.png',\n   *     'footer': 'Powered by sneks',\n   *     'ts': Date.now() / 1_000\n   *   }]\n   * }).catch(console.error);\n   * @see {@link https://api.slack.com/messaging/webhooks}\n   */\n  async sendSlackMessage(body) {\n    if (!this.token) throw new Error('WEBHOOK_TOKEN_UNAVAILABLE');\n\n    const data = await this.client.api.webhooks(this.id, this.token).slack.post({\n      query: { wait: true },\n      auth: false,\n      data: body,\n    });\n    return data.toString() === 'ok';\n  }\n\n  /**\n   * Options used to edit a {@link Webhook}.\n   * @typedef {Object} WebhookEditData\n   * @property {string} [name=this.name] The new name for the webhook\n   * @property {?(BufferResolvable)} [avatar] The new avatar for the webhook\n   * @property {GuildTextChannelResolvable} [channel] The new channel for the webhook\n   */\n\n  /**\n   * Edits this webhook.\n   * @param {WebhookEditData} options Options for editing the webhook\n   * @param {string} [reason] Reason for editing the webhook\n   * @returns {Promise<Webhook>}\n   */\n  async edit({ name = this.name, avatar, channel }, reason) {\n    if (avatar && !(typeof avatar === 'string' && avatar.startsWith('data:'))) {\n      avatar = await DataResolver.resolveImage(avatar);\n    }\n    channel &&= channel.id ?? channel;\n    const data = await this.client.api.webhooks(this.id, channel ? undefined : this.token).patch({\n      data: { name, avatar, channel_id: channel },\n      reason,\n      auth: !this.token || Boolean(channel),\n    });\n\n    this.name = data.name;\n    this.avatar = data.avatar;\n    this.channelId = data.channel_id;\n    return this;\n  }\n\n  /**\n   * Options that can be passed into fetchMessage.\n   * @typedef {options} WebhookFetchMessageOptions\n   * @property {boolean} [cache=true] Whether to cache the message.\n   * @property {Snowflake} [threadId] The id of the thread this message belongs to.\n   * <info>For interaction webhooks, this property is ignored</info>\n   */\n\n  /**\n   * Gets a message that was sent by this webhook.\n   * @param {Snowflake|'@original'} message The id of the message to fetch\n   * @param {WebhookFetchMessageOptions|boolean} [cacheOrOptions={}] The options to provide to fetch the message.\n   * <warn>A **deprecated** boolean may be passed instead to specify whether to cache the message.</warn>\n   * @returns {Promise<Message|APIMessage>} Returns the raw message data if the webhook was instantiated as a\n   * {@link WebhookClient} or if the channel is uncached, otherwise a {@link Message} will be returned\n   */\n  async fetchMessage(message, cacheOrOptions = { cache: true }) {\n    if (typeof cacheOrOptions === 'boolean') {\n      if (!deprecationEmittedForFetchMessage) {\n        process.emitWarning(\n          'Passing a boolean to cache the message in Webhook#fetchMessage is deprecated. Pass an object instead.',\n          'DeprecationWarning',\n        );\n\n        deprecationEmittedForFetchMessage = true;\n      }\n\n      cacheOrOptions = { cache: cacheOrOptions };\n    }\n\n    if (!this.token) throw new Error('WEBHOOK_TOKEN_UNAVAILABLE');\n\n    const data = await this.client.api\n      .webhooks(this.id, this.token)\n      .messages(message)\n      .get({\n        query: {\n          thread_id: cacheOrOptions.threadId,\n        },\n        auth: false,\n      });\n    return this.client.channels?.cache.get(data.channel_id)?.messages._add(data, cacheOrOptions.cache) ?? data;\n  }\n\n  /**\n   * Edits a message that was sent by this webhook.\n   * @param {MessageResolvable|'@original'} message The message to edit\n   * @param {string|MessagePayload|WebhookEditMessageOptions} options The options to provide\n   * @returns {Promise<Message|APIMessage>} Returns the raw message data if the webhook was instantiated as a\n   * {@link WebhookClient} or if the channel is uncached, otherwise a {@link Message} will be returned\n   */\n  async editMessage(message, options) {\n    if (!this.token) throw new Error('WEBHOOK_TOKEN_UNAVAILABLE');\n\n    let messagePayload;\n\n    if (options instanceof MessagePayload) messagePayload = options;\n    else messagePayload = MessagePayload.create(this, options);\n\n    const { data, files } = await messagePayload.resolveData().resolveFiles();\n\n    const d = await this.client.api\n      .webhooks(this.id, this.token)\n      .messages(typeof message === 'string' ? message : message.id)\n      .patch({\n        data,\n        files,\n        query: {\n          thread_id: messagePayload.options.threadId,\n        },\n        auth: false,\n      });\n\n    const messageManager = this.client.channels?.cache.get(d.channel_id)?.messages;\n    if (!messageManager) return d;\n\n    const existing = messageManager.cache.get(d.id);\n    if (!existing) return messageManager._add(d);\n\n    const clone = existing._clone();\n    clone._patch(d);\n    return clone;\n  }\n\n  /**\n   * Deletes the webhook.\n   * @param {string} [reason] Reason for deleting this webhook\n   * @returns {Promise<void>}\n   */\n  async delete(reason) {\n    await this.client.api.webhooks(this.id, this.token).delete({ reason, auth: !this.token });\n  }\n\n  /**\n   * Delete a message that was sent by this webhook.\n   * @param {MessageResolvable|'@original'} message The message to delete\n   * @param {Snowflake} [threadId] The id of the thread this message belongs to\n   * @returns {Promise<void>}\n   */\n  async deleteMessage(message, threadId) {\n    if (!this.token) throw new Error('WEBHOOK_TOKEN_UNAVAILABLE');\n\n    await this.client.api\n      .webhooks(this.id, this.token)\n      .messages(typeof message === 'string' ? message : message.id)\n      .delete({\n        query: {\n          thread_id: threadId,\n        },\n        auth: false,\n      });\n  }\n\n  /**\n   * The timestamp the webhook was created at\n   * @type {number}\n   * @readonly\n   */\n  get createdTimestamp() {\n    return SnowflakeUtil.timestampFrom(this.id);\n  }\n\n  /**\n   * The time the webhook was created at\n   * @type {Date}\n   * @readonly\n   */\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The URL of this webhook\n   * @type {string}\n   * @readonly\n   */\n  get url() {\n    return this.client.options.http.api + this.client.api.webhooks(this.id, this.token);\n  }\n\n  /**\n   * A link to the webhook's avatar.\n   * @param {StaticImageURLOptions} [options={}] Options for the Image URL\n   * @returns {?string}\n   */\n  avatarURL({ format, size } = {}) {\n    if (!this.avatar) return null;\n    return this.client.rest.cdn.Avatar(this.id, this.avatar, format, size);\n  }\n\n  /**\n   * Whether or not this webhook is a channel follower webhook.\n   * @returns {boolean}\n   */\n  isChannelFollower() {\n    return this.type === 'Channel Follower';\n  }\n\n  /**\n   * Whether or not this webhook is an incoming webhook.\n   * @returns {boolean}\n   */\n  isIncoming() {\n    return this.type === 'Incoming';\n  }\n\n  static applyToClass(structure, ignore = []) {\n    for (const prop of [\n      'send',\n      'sendSlackMessage',\n      'fetchMessage',\n      'edit',\n      'editMessage',\n      'delete',\n      'deleteMessage',\n      'createdTimestamp',\n      'createdAt',\n      'url',\n    ]) {\n      if (ignore.includes(prop)) continue;\n      Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(Webhook.prototype, prop));\n    }\n  }\n}\n\nmodule.exports = Webhook;\n"],"mappings":"AAAA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,cAAD,CAAvB;;AACA,MAAMC,cAAc,GAAGD,OAAO,CAAC,kBAAD,CAA9B;;AACA,MAAM;EAAEE;AAAF,IAAYF,OAAO,CAAC,WAAD,CAAzB;;AACA,MAAM;EAAEG;AAAF,IAAmBH,OAAO,CAAC,mBAAD,CAAhC;;AACA,MAAMI,YAAY,GAAGJ,OAAO,CAAC,sBAAD,CAA5B;;AACA,MAAMK,aAAa,GAAGL,OAAO,CAAC,uBAAD,CAA7B;;AAEA,IAAIM,iCAAiC,GAAG,KAAxC;AAEA;AACA;AACA;;AACA,MAAMC,OAAN,CAAc;EACZC,WAAW,CAACC,MAAD,EAASC,IAAT,EAAe;IACxB;AACJ;AACA;AACA;AACA;AACA;IACIC,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,QAA5B,EAAsC;MAAEC,KAAK,EAAEJ;IAAT,CAAtC;IACA,IAAIC,IAAJ,EAAU,KAAKI,MAAL,CAAYJ,IAAZ;EACX;;EAEDI,MAAM,CAACJ,IAAD,EAAO;IACX,IAAI,UAAUA,IAAd,EAAoB;MAClB;AACN;AACA;AACA;MACM,KAAKK,IAAL,GAAYL,IAAI,CAACK,IAAjB;IACD;IAED;AACJ;AACA;AACA;AACA;;;IACIJ,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,OAA5B,EAAqC;MAAEC,KAAK,EAAEH,IAAI,CAACM,KAAL,IAAc,IAAvB;MAA6BC,QAAQ,EAAE,IAAvC;MAA6CC,YAAY,EAAE;IAA3D,CAArC;;IAEA,IAAI,YAAYR,IAAhB,EAAsB;MACpB;AACN;AACA;AACA;MACM,KAAKS,MAAL,GAAcT,IAAI,CAACS,MAAnB;IACD;IAED;AACJ;AACA;AACA;;;IACI,KAAKC,EAAL,GAAUV,IAAI,CAACU,EAAf;;IAEA,IAAI,UAAUV,IAAd,EAAoB;MAClB;AACN;AACA;AACA;MACM,KAAKW,IAAL,GAAYlB,YAAY,CAACO,IAAI,CAACW,IAAN,CAAxB;IACD;;IAED,IAAI,cAAcX,IAAlB,EAAwB;MACtB;AACN;AACA;AACA;MACM,KAAKY,OAAL,GAAeZ,IAAI,CAACa,QAApB;IACD;;IAED,IAAI,gBAAgBb,IAApB,EAA0B;MACxB;AACN;AACA;AACA;MACM,KAAKc,SAAL,GAAiBd,IAAI,CAACe,UAAtB;IACD;;IAED,IAAI,UAAUf,IAAd,EAAoB;MAClB;AACN;AACA;AACA;MACM,KAAKgB,KAAL,GAAa,KAAKjB,MAAL,CAAYkB,KAAZ,EAAmBC,IAAnB,CAAwBlB,IAAI,CAACmB,IAA7B,KAAsCnB,IAAI,CAACmB,IAAxD;IACD,CAND,MAMO;MACL,KAAKH,KAAL,KAAe,IAAf;IACD;;IAED,IAAI,kBAAkBhB,IAAtB,EAA4B;MAC1B;AACN;AACA;AACA;MACM,KAAKoB,WAAL,GAAmB,KAAKrB,MAAL,CAAYsB,MAAZ,EAAoBC,OAApB,CAA4BtB,IAAI,CAACuB,YAAL,CAAkBb,EAA9C,KAAqDV,IAAI,CAACuB,YAA7E;IACD,CAND,MAMO;MACL,KAAKH,WAAL,KAAqB,IAArB;IACD;;IAED,IAAI,oBAAoBpB,IAAxB,EAA8B;MAC5B;AACN;AACA;AACA;MACM,KAAKwB,aAAL,GAAqB,KAAKzB,MAAL,CAAY0B,QAAZ,EAAsBH,OAAtB,CAA8BtB,IAAI,CAAC0B,cAAL,EAAqBhB,EAAnD,KAA0DV,IAAI,CAAC0B,cAApF;IACD,CAND,MAMO;MACL,KAAKF,aAAL,KAAuB,IAAvB;IACD;EACF;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACY,MAAJG,IAAI,CAACC,OAAD,EAAU;IAClB,IAAI,CAAC,KAAKtB,KAAV,EAAiB,MAAM,IAAId,KAAJ,CAAU,2BAAV,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"},"metadata":{},"sourceType":"script"}