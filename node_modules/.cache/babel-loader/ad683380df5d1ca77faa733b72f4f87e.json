{"ast":null,"code":"'use strict';\n\nconst {\n  Channel\n} = require('./Channel');\n\nconst PermissionOverwrites = require('./PermissionOverwrites');\n\nconst {\n  Error\n} = require('../errors');\n\nconst PermissionOverwriteManager = require('../managers/PermissionOverwriteManager');\n\nconst {\n  ChannelTypes,\n  VoiceBasedChannelTypes\n} = require('../util/Constants');\n\nconst Permissions = require('../util/Permissions');\n\nconst Util = require('../util/Util');\n/**\n * Represents a guild channel from any of the following:\n * - {@link TextChannel}\n * - {@link VoiceChannel}\n * - {@link CategoryChannel}\n * - {@link NewsChannel}\n * - {@link StoreChannel}\n * - {@link StageChannel}\n * @extends {Channel}\n * @abstract\n */\n\n\nclass GuildChannel extends Channel {\n  constructor(guild, data, client) {\n    let immediatePatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    super(guild?.client ?? client, data, false);\n    /**\n     * The guild the channel is in\n     * @type {Guild}\n     */\n\n    this.guild = guild;\n    /**\n     * The id of the guild the channel is in\n     * @type {Snowflake}\n     */\n\n    this.guildId = guild?.id ?? data.guild_id;\n    this.parentId = this.parentId ?? null;\n    /**\n     * A manager of permission overwrites that belong to this channel\n     * @type {PermissionOverwriteManager}\n     */\n\n    this.permissionOverwrites = new PermissionOverwriteManager(this);\n    if (data && immediatePatch) this._patch(data);\n  }\n\n  _patch(data) {\n    super._patch(data);\n\n    if ('name' in data) {\n      /**\n       * The name of the guild channel\n       * @type {string}\n       */\n      this.name = data.name;\n    }\n\n    if ('position' in data) {\n      /**\n       * The raw position of the channel from Discord\n       * @type {number}\n       */\n      this.rawPosition = data.position;\n    }\n\n    if ('guild_id' in data) {\n      this.guildId = data.guild_id;\n    }\n\n    if ('parent_id' in data) {\n      /**\n       * The id of the category parent of this channel\n       * @type {?Snowflake}\n       */\n      this.parentId = data.parent_id;\n    }\n\n    if ('permission_overwrites' in data) {\n      this.permissionOverwrites.cache.clear();\n\n      for (const overwrite of data.permission_overwrites) {\n        this.permissionOverwrites._add(overwrite);\n      }\n    }\n  }\n\n  _clone() {\n    const clone = super._clone();\n\n    clone.permissionOverwrites = new PermissionOverwriteManager(clone, this.permissionOverwrites.cache.values());\n    return clone;\n  }\n  /**\n   * The category parent of this channel\n   * @type {?CategoryChannel}\n   * @readonly\n   */\n\n\n  get parent() {\n    return this.guild.channels.resolve(this.parentId);\n  }\n  /**\n   * If the permissionOverwrites match the parent channel, null if no parent\n   * @type {?boolean}\n   * @readonly\n   */\n\n\n  get permissionsLocked() {\n    if (!this.parent) return null; // Get all overwrites\n\n    const overwriteIds = new Set([...this.permissionOverwrites.cache.keys(), ...this.parent.permissionOverwrites.cache.keys()]); // Compare all overwrites\n\n    return [...overwriteIds].every(key => {\n      const channelVal = this.permissionOverwrites.cache.get(key);\n      const parentVal = this.parent.permissionOverwrites.cache.get(key); // Handle empty overwrite\n\n      if (!channelVal && parentVal.deny.bitfield === Permissions.defaultBit && parentVal.allow.bitfield === Permissions.defaultBit || !parentVal && channelVal.deny.bitfield === Permissions.defaultBit && channelVal.allow.bitfield === Permissions.defaultBit) {\n        return true;\n      } // Compare overwrites\n\n\n      return typeof channelVal !== 'undefined' && typeof parentVal !== 'undefined' && channelVal.deny.bitfield === parentVal.deny.bitfield && channelVal.allow.bitfield === parentVal.allow.bitfield;\n    });\n  }\n  /**\n   * The position of the channel\n   * @type {number}\n   * @readonly\n   */\n\n\n  get position() {\n    const sorted = this.guild._sortedChannels(this);\n\n    return [...sorted.values()].indexOf(sorted.get(this.id));\n  }\n  /**\n   * Gets the overall set of permissions for a member or role in this channel, taking into account channel overwrites.\n   * @param {GuildMemberResolvable|RoleResolvable} memberOrRole The member or role to obtain the overall permissions for\n   * @param {boolean} [checkAdmin=true] Whether having `ADMINISTRATOR` will return all permissions\n   * @returns {?Readonly<Permissions>}\n   */\n\n\n  permissionsFor(memberOrRole) {\n    let checkAdmin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const member = this.guild.members.resolve(memberOrRole);\n    if (member) return this.memberPermissions(member, checkAdmin);\n    const role = this.guild.roles.resolve(memberOrRole);\n    return role && this.rolePermissions(role, checkAdmin);\n  }\n\n  overwritesFor(member) {\n    let verified = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let roles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    if (!verified) member = this.guild.members.resolve(member);\n    if (!member) return [];\n    roles ??= member.roles.cache;\n    const roleOverwrites = [];\n    let memberOverwrites;\n    let everyoneOverwrites;\n\n    for (const overwrite of this.permissionOverwrites.cache.values()) {\n      if (overwrite.id === this.guild.id) {\n        everyoneOverwrites = overwrite;\n      } else if (roles.has(overwrite.id)) {\n        roleOverwrites.push(overwrite);\n      } else if (overwrite.id === member.id) {\n        memberOverwrites = overwrite;\n      }\n    }\n\n    return {\n      everyone: everyoneOverwrites,\n      roles: roleOverwrites,\n      member: memberOverwrites\n    };\n  }\n  /**\n   * Gets the overall set of permissions for a member in this channel, taking into account channel overwrites.\n   * @param {GuildMember} member The member to obtain the overall permissions for\n   * @param {boolean} checkAdmin=true Whether having `ADMINISTRATOR` will return all permissions\n   * @returns {Readonly<Permissions>}\n   * @private\n   */\n\n\n  memberPermissions(member, checkAdmin) {\n    if (checkAdmin && member.id === this.guild.ownerId) return new Permissions(Permissions.ALL).freeze();\n    const roles = member.roles.cache;\n    const permissions = new Permissions(roles.map(role => role.permissions));\n\n    if (checkAdmin && permissions.has(Permissions.FLAGS.ADMINISTRATOR)) {\n      return new Permissions(Permissions.ALL).freeze();\n    }\n\n    const overwrites = this.overwritesFor(member, true, roles);\n    return permissions.remove(overwrites.everyone?.deny ?? Permissions.defaultBit).add(overwrites.everyone?.allow ?? Permissions.defaultBit).remove(overwrites.roles.length > 0 ? overwrites.roles.map(role => role.deny) : Permissions.defaultBit).add(overwrites.roles.length > 0 ? overwrites.roles.map(role => role.allow) : Permissions.defaultBit).remove(overwrites.member?.deny ?? Permissions.defaultBit).add(overwrites.member?.allow ?? Permissions.defaultBit).freeze();\n  }\n  /**\n   * Gets the overall set of permissions for a role in this channel, taking into account channel overwrites.\n   * @param {Role} role The role to obtain the overall permissions for\n   * @param {boolean} checkAdmin Whether having `ADMINISTRATOR` will return all permissions\n   * @returns {Readonly<Permissions>}\n   * @private\n   */\n\n\n  rolePermissions(role, checkAdmin) {\n    if (checkAdmin && role.permissions.has(Permissions.FLAGS.ADMINISTRATOR)) {\n      return new Permissions(Permissions.ALL).freeze();\n    }\n\n    const everyoneOverwrites = this.permissionOverwrites.cache.get(this.guild.id);\n    const roleOverwrites = this.permissionOverwrites.cache.get(role.id);\n    return role.permissions.remove(everyoneOverwrites?.deny ?? Permissions.defaultBit).add(everyoneOverwrites?.allow ?? Permissions.defaultBit).remove(roleOverwrites?.deny ?? Permissions.defaultBit).add(roleOverwrites?.allow ?? Permissions.defaultBit).freeze();\n  }\n  /**\n   * Locks in the permission overwrites from the parent channel.\n   * @returns {Promise<GuildChannel>}\n   */\n\n\n  lockPermissions() {\n    if (!this.parent) return Promise.reject(new Error('GUILD_CHANNEL_ORPHAN'));\n    const permissionOverwrites = this.parent.permissionOverwrites.cache.map(overwrite => overwrite.toJSON());\n    return this.edit({\n      permissionOverwrites\n    });\n  }\n  /**\n   * A collection of cached members of this channel, mapped by their ids.\n   * Members that can view this channel, if the channel is text-based.\n   * Members in the channel, if the channel is voice-based.\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n\n\n  get members() {\n    return this.guild.members.cache.filter(m => this.permissionsFor(m).has(Permissions.FLAGS.VIEW_CHANNEL, false));\n  }\n  /**\n   * The data for a guild channel.\n   * @typedef {Object} ChannelData\n   * @property {string} [name] The name of the channel\n   * @property {ChannelType} [type] The type of the channel (only conversion between text and news is supported)\n   * @property {number} [position] The position of the channel\n   * @property {string} [topic] The topic of the text channel\n   * @property {boolean} [nsfw] Whether the channel is NSFW\n   * @property {number} [bitrate] The bitrate of the voice channel\n   * @property {number} [userLimit] The user limit of the voice channel\n   * @property {?CategoryChannelResolvable} [parent] The parent of the channel\n   * @property {boolean} [lockPermissions]\n   * Lock the permissions of the channel to what the parent's permissions are\n   * @property {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} [permissionOverwrites]\n   * Permission overwrites for the channel\n   * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the channel in seconds\n   * @property {ThreadAutoArchiveDuration} [defaultAutoArchiveDuration]\n   * The default auto archive duration for all new threads in this channel\n   * @property {?string} [rtcRegion] The RTC region of the channel\n   */\n\n  /**\n   * Edits the channel.\n   * @param {ChannelData} data The new data for the channel\n   * @param {string} [reason] Reason for editing this channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Edit a channel\n   * channel.edit({ name: 'new-channel' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  async edit(data, reason) {\n    data.parent &&= this.client.channels.resolveId(data.parent);\n\n    if (typeof data.position !== 'undefined') {\n      const updatedChannels = await Util.setPosition(this, data.position, false, this.guild._sortedChannels(this), this.client.api.guilds(this.guild.id).channels, reason);\n      this.client.actions.GuildChannelsPositionUpdate.handle({\n        guild_id: this.guild.id,\n        channels: updatedChannels\n      });\n    }\n\n    let permission_overwrites;\n\n    if (data.permissionOverwrites) {\n      permission_overwrites = data.permissionOverwrites.map(o => PermissionOverwrites.resolve(o, this.guild));\n    }\n\n    if (data.lockPermissions) {\n      if (data.parent) {\n        const newParent = this.guild.channels.resolve(data.parent);\n\n        if (newParent?.type === 'GUILD_CATEGORY') {\n          permission_overwrites = newParent.permissionOverwrites.cache.map(o => PermissionOverwrites.resolve(o, this.guild));\n        }\n      } else if (this.parent) {\n        permission_overwrites = this.parent.permissionOverwrites.cache.map(o => PermissionOverwrites.resolve(o, this.guild));\n      }\n    }\n\n    const newData = await this.client.api.channels(this.id).patch({\n      data: {\n        name: (data.name ?? this.name).trim(),\n        type: ChannelTypes[data.type],\n        topic: data.topic,\n        nsfw: data.nsfw,\n        bitrate: data.bitrate ?? this.bitrate,\n        user_limit: data.userLimit ?? this.userLimit,\n        rtc_region: data.rtcRegion ?? this.rtcRegion,\n        parent_id: data.parent,\n        lock_permissions: data.lockPermissions,\n        rate_limit_per_user: data.rateLimitPerUser,\n        default_auto_archive_duration: data.defaultAutoArchiveDuration,\n        permission_overwrites\n      },\n      reason\n    });\n    return this.client.actions.ChannelUpdate.handle(newData).updated;\n  }\n  /**\n   * Sets a new name for the guild channel.\n   * @param {string} name The new name for the guild channel\n   * @param {string} [reason] Reason for changing the guild channel's name\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel name\n   * channel.setName('not_general')\n   *   .then(newChannel => console.log(`Channel's new name is ${newChannel.name}`))\n   *   .catch(console.error);\n   */\n\n\n  setName(name, reason) {\n    return this.edit({\n      name\n    }, reason);\n  }\n  /**\n   * Options used to set the parent of a channel.\n   * @typedef {Object} SetParentOptions\n   * @property {boolean} [lockPermissions=true] Whether to lock the permissions to what the parent's permissions are\n   * @property {string} [reason] The reason for modifying the parent of the channel\n   */\n\n  /**\n   * Sets the parent of this channel.\n   * @param {?CategoryChannelResolvable} channel The category channel to set as the parent\n   * @param {SetParentOptions} [options={}] The options for setting the parent\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Add a parent to a channel\n   * message.channel.setParent('355908108431917066', { lockPermissions: false })\n   *   .then(channel => console.log(`New parent of ${message.channel.name}: ${channel.name}`))\n   *   .catch(console.error);\n   */\n\n\n  setParent(channel) {\n    let {\n      lockPermissions = true,\n      reason\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.edit({\n      parent: channel ?? null,\n      lockPermissions\n    }, reason);\n  }\n  /**\n   * Options used to set the position of a channel.\n   * @typedef {Object} SetChannelPositionOptions\n   * @property {boolean} [relative=false] Whether or not to change the position relative to its current value\n   * @property {string} [reason] The reason for changing the position\n   */\n\n  /**\n   * Sets a new position for the guild channel.\n   * @param {number} position The new position for the guild channel\n   * @param {SetChannelPositionOptions} [options] Options for setting position\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel position\n   * channel.setPosition(2)\n   *   .then(newChannel => console.log(`Channel's new position is ${newChannel.position}`))\n   *   .catch(console.error);\n   */\n\n\n  async setPosition(position) {\n    let {\n      relative,\n      reason\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const updatedChannels = await Util.setPosition(this, position, relative, this.guild._sortedChannels(this), this.client.api.guilds(this.guild.id).channels, reason);\n    this.client.actions.GuildChannelsPositionUpdate.handle({\n      guild_id: this.guild.id,\n      channels: updatedChannels\n    });\n    return this;\n  }\n  /**\n   * Data that can be resolved to an Application. This can be:\n   * * An Application\n   * * An Activity with associated Application\n   * * A Snowflake\n   * @typedef {Application|Snowflake} ApplicationResolvable\n   */\n\n  /**\n   * Options used to clone a guild channel.\n   * @typedef {GuildChannelCreateOptions} GuildChannelCloneOptions\n   * @property {string} [name=this.name] Name of the new channel\n   */\n\n  /**\n   * Clones this channel.\n   * @param {GuildChannelCloneOptions} [options] The options for cloning this channel\n   * @returns {Promise<GuildChannel>}\n   */\n\n\n  clone() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.guild.channels.create(options.name ?? this.name, {\n      permissionOverwrites: this.permissionOverwrites.cache,\n      topic: this.topic,\n      type: this.type,\n      nsfw: this.nsfw,\n      parent: this.parent,\n      bitrate: this.bitrate,\n      userLimit: this.userLimit,\n      rateLimitPerUser: this.rateLimitPerUser,\n      position: this.rawPosition,\n      reason: null,\n      ...options\n    });\n  }\n  /**\n   * Checks if this channel has the same type, topic, position, name, overwrites, and id as another channel.\n   * In most cases, a simple `channel.id === channel2.id` will do, and is much faster too.\n   * @param {GuildChannel} channel Channel to compare with\n   * @returns {boolean}\n   */\n\n\n  equals(channel) {\n    let equal = channel && this.id === channel.id && this.type === channel.type && this.topic === channel.topic && this.position === channel.position && this.name === channel.name;\n\n    if (equal) {\n      if (this.permissionOverwrites && channel.permissionOverwrites) {\n        equal = this.permissionOverwrites.cache.equals(channel.permissionOverwrites.cache);\n      } else {\n        equal = !this.permissionOverwrites && !channel.permissionOverwrites;\n      }\n    }\n\n    return equal;\n  }\n  /**\n   * Whether the channel is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get deletable() {\n    return this.manageable && this.guild.rulesChannelId !== this.id && this.guild.publicUpdatesChannelId !== this.id;\n  }\n  /**\n   * Whether the channel is manageable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get manageable() {\n    if (this.client.user.id === this.guild.ownerId) return true;\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false; // This flag allows managing even if timed out\n\n    if (permissions.has(Permissions.FLAGS.ADMINISTRATOR, false)) return true;\n    if (this.guild.me.communicationDisabledUntilTimestamp > Date.now()) return false;\n    const bitfield = VoiceBasedChannelTypes.includes(this.type) ? Permissions.FLAGS.MANAGE_CHANNELS | Permissions.FLAGS.CONNECT : Permissions.FLAGS.VIEW_CHANNEL | Permissions.FLAGS.MANAGE_CHANNELS;\n    return permissions.has(bitfield, false);\n  }\n  /**\n   * Whether the channel is viewable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get viewable() {\n    if (this.client.user.id === this.guild.ownerId) return true;\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    return permissions.has(Permissions.FLAGS.VIEW_CHANNEL, false);\n  }\n  /**\n   * Deletes this channel.\n   * @param {string} [reason] Reason for deleting this channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Delete the channel\n   * channel.delete('making room for new channels')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  async delete(reason) {\n    await this.client.api.channels(this.id).delete({\n      reason\n    });\n    return this;\n  }\n\n}\n\nmodule.exports = GuildChannel;","map":{"version":3,"names":["Channel","require","PermissionOverwrites","Error","PermissionOverwriteManager","ChannelTypes","VoiceBasedChannelTypes","Permissions","Util","GuildChannel","constructor","guild","data","client","immediatePatch","guildId","id","guild_id","parentId","permissionOverwrites","_patch","name","rawPosition","position","parent_id","cache","clear","overwrite","permission_overwrites","_add","_clone","clone","values","parent","channels","resolve","permissionsLocked","overwriteIds","Set","keys","every","key","channelVal","get","parentVal","deny","bitfield","defaultBit","allow","sorted","_sortedChannels","indexOf","permissionsFor","memberOrRole","checkAdmin","member","members","memberPermissions","role","roles","rolePermissions","overwritesFor","verified","roleOverwrites","memberOverwrites","everyoneOverwrites","has","push","everyone","ownerId","ALL","freeze","permissions","map","FLAGS","ADMINISTRATOR","overwrites","remove","add","length","lockPermissions","Promise","reject","toJSON","edit","filter","m","VIEW_CHANNEL","reason","resolveId","updatedChannels","setPosition","api","guilds","actions","GuildChannelsPositionUpdate","handle","o","newParent","type","newData","patch","trim","topic","nsfw","bitrate","user_limit","userLimit","rtc_region","rtcRegion","lock_permissions","rate_limit_per_user","rateLimitPerUser","default_auto_archive_duration","defaultAutoArchiveDuration","ChannelUpdate","updated","setName","setParent","channel","relative","options","create","equals","equal","deletable","manageable","rulesChannelId","publicUpdatesChannelId","user","me","communicationDisabledUntilTimestamp","Date","now","includes","MANAGE_CHANNELS","CONNECT","viewable","delete","module","exports"],"sources":["C:/Users/xsxsam/node_modules/discord.js/src/structures/GuildChannel.js"],"sourcesContent":["'use strict';\n\nconst { Channel } = require('./Channel');\nconst PermissionOverwrites = require('./PermissionOverwrites');\nconst { Error } = require('../errors');\nconst PermissionOverwriteManager = require('../managers/PermissionOverwriteManager');\nconst { ChannelTypes, VoiceBasedChannelTypes } = require('../util/Constants');\nconst Permissions = require('../util/Permissions');\nconst Util = require('../util/Util');\n\n/**\n * Represents a guild channel from any of the following:\n * - {@link TextChannel}\n * - {@link VoiceChannel}\n * - {@link CategoryChannel}\n * - {@link NewsChannel}\n * - {@link StoreChannel}\n * - {@link StageChannel}\n * @extends {Channel}\n * @abstract\n */\nclass GuildChannel extends Channel {\n  constructor(guild, data, client, immediatePatch = true) {\n    super(guild?.client ?? client, data, false);\n\n    /**\n     * The guild the channel is in\n     * @type {Guild}\n     */\n    this.guild = guild;\n\n    /**\n     * The id of the guild the channel is in\n     * @type {Snowflake}\n     */\n    this.guildId = guild?.id ?? data.guild_id;\n\n    this.parentId = this.parentId ?? null;\n    /**\n     * A manager of permission overwrites that belong to this channel\n     * @type {PermissionOverwriteManager}\n     */\n    this.permissionOverwrites = new PermissionOverwriteManager(this);\n\n    if (data && immediatePatch) this._patch(data);\n  }\n\n  _patch(data) {\n    super._patch(data);\n\n    if ('name' in data) {\n      /**\n       * The name of the guild channel\n       * @type {string}\n       */\n      this.name = data.name;\n    }\n\n    if ('position' in data) {\n      /**\n       * The raw position of the channel from Discord\n       * @type {number}\n       */\n      this.rawPosition = data.position;\n    }\n\n    if ('guild_id' in data) {\n      this.guildId = data.guild_id;\n    }\n\n    if ('parent_id' in data) {\n      /**\n       * The id of the category parent of this channel\n       * @type {?Snowflake}\n       */\n      this.parentId = data.parent_id;\n    }\n\n    if ('permission_overwrites' in data) {\n      this.permissionOverwrites.cache.clear();\n      for (const overwrite of data.permission_overwrites) {\n        this.permissionOverwrites._add(overwrite);\n      }\n    }\n  }\n\n  _clone() {\n    const clone = super._clone();\n    clone.permissionOverwrites = new PermissionOverwriteManager(clone, this.permissionOverwrites.cache.values());\n    return clone;\n  }\n\n  /**\n   * The category parent of this channel\n   * @type {?CategoryChannel}\n   * @readonly\n   */\n  get parent() {\n    return this.guild.channels.resolve(this.parentId);\n  }\n\n  /**\n   * If the permissionOverwrites match the parent channel, null if no parent\n   * @type {?boolean}\n   * @readonly\n   */\n  get permissionsLocked() {\n    if (!this.parent) return null;\n\n    // Get all overwrites\n    const overwriteIds = new Set([\n      ...this.permissionOverwrites.cache.keys(),\n      ...this.parent.permissionOverwrites.cache.keys(),\n    ]);\n\n    // Compare all overwrites\n    return [...overwriteIds].every(key => {\n      const channelVal = this.permissionOverwrites.cache.get(key);\n      const parentVal = this.parent.permissionOverwrites.cache.get(key);\n\n      // Handle empty overwrite\n      if (\n        (!channelVal &&\n          parentVal.deny.bitfield === Permissions.defaultBit &&\n          parentVal.allow.bitfield === Permissions.defaultBit) ||\n        (!parentVal &&\n          channelVal.deny.bitfield === Permissions.defaultBit &&\n          channelVal.allow.bitfield === Permissions.defaultBit)\n      ) {\n        return true;\n      }\n\n      // Compare overwrites\n      return (\n        typeof channelVal !== 'undefined' &&\n        typeof parentVal !== 'undefined' &&\n        channelVal.deny.bitfield === parentVal.deny.bitfield &&\n        channelVal.allow.bitfield === parentVal.allow.bitfield\n      );\n    });\n  }\n\n  /**\n   * The position of the channel\n   * @type {number}\n   * @readonly\n   */\n  get position() {\n    const sorted = this.guild._sortedChannels(this);\n    return [...sorted.values()].indexOf(sorted.get(this.id));\n  }\n\n  /**\n   * Gets the overall set of permissions for a member or role in this channel, taking into account channel overwrites.\n   * @param {GuildMemberResolvable|RoleResolvable} memberOrRole The member or role to obtain the overall permissions for\n   * @param {boolean} [checkAdmin=true] Whether having `ADMINISTRATOR` will return all permissions\n   * @returns {?Readonly<Permissions>}\n   */\n  permissionsFor(memberOrRole, checkAdmin = true) {\n    const member = this.guild.members.resolve(memberOrRole);\n    if (member) return this.memberPermissions(member, checkAdmin);\n    const role = this.guild.roles.resolve(memberOrRole);\n    return role && this.rolePermissions(role, checkAdmin);\n  }\n\n  overwritesFor(member, verified = false, roles = null) {\n    if (!verified) member = this.guild.members.resolve(member);\n    if (!member) return [];\n\n    roles ??= member.roles.cache;\n    const roleOverwrites = [];\n    let memberOverwrites;\n    let everyoneOverwrites;\n\n    for (const overwrite of this.permissionOverwrites.cache.values()) {\n      if (overwrite.id === this.guild.id) {\n        everyoneOverwrites = overwrite;\n      } else if (roles.has(overwrite.id)) {\n        roleOverwrites.push(overwrite);\n      } else if (overwrite.id === member.id) {\n        memberOverwrites = overwrite;\n      }\n    }\n\n    return {\n      everyone: everyoneOverwrites,\n      roles: roleOverwrites,\n      member: memberOverwrites,\n    };\n  }\n\n  /**\n   * Gets the overall set of permissions for a member in this channel, taking into account channel overwrites.\n   * @param {GuildMember} member The member to obtain the overall permissions for\n   * @param {boolean} checkAdmin=true Whether having `ADMINISTRATOR` will return all permissions\n   * @returns {Readonly<Permissions>}\n   * @private\n   */\n  memberPermissions(member, checkAdmin) {\n    if (checkAdmin && member.id === this.guild.ownerId) return new Permissions(Permissions.ALL).freeze();\n\n    const roles = member.roles.cache;\n    const permissions = new Permissions(roles.map(role => role.permissions));\n\n    if (checkAdmin && permissions.has(Permissions.FLAGS.ADMINISTRATOR)) {\n      return new Permissions(Permissions.ALL).freeze();\n    }\n\n    const overwrites = this.overwritesFor(member, true, roles);\n\n    return permissions\n      .remove(overwrites.everyone?.deny ?? Permissions.defaultBit)\n      .add(overwrites.everyone?.allow ?? Permissions.defaultBit)\n      .remove(overwrites.roles.length > 0 ? overwrites.roles.map(role => role.deny) : Permissions.defaultBit)\n      .add(overwrites.roles.length > 0 ? overwrites.roles.map(role => role.allow) : Permissions.defaultBit)\n      .remove(overwrites.member?.deny ?? Permissions.defaultBit)\n      .add(overwrites.member?.allow ?? Permissions.defaultBit)\n      .freeze();\n  }\n\n  /**\n   * Gets the overall set of permissions for a role in this channel, taking into account channel overwrites.\n   * @param {Role} role The role to obtain the overall permissions for\n   * @param {boolean} checkAdmin Whether having `ADMINISTRATOR` will return all permissions\n   * @returns {Readonly<Permissions>}\n   * @private\n   */\n  rolePermissions(role, checkAdmin) {\n    if (checkAdmin && role.permissions.has(Permissions.FLAGS.ADMINISTRATOR)) {\n      return new Permissions(Permissions.ALL).freeze();\n    }\n\n    const everyoneOverwrites = this.permissionOverwrites.cache.get(this.guild.id);\n    const roleOverwrites = this.permissionOverwrites.cache.get(role.id);\n\n    return role.permissions\n      .remove(everyoneOverwrites?.deny ?? Permissions.defaultBit)\n      .add(everyoneOverwrites?.allow ?? Permissions.defaultBit)\n      .remove(roleOverwrites?.deny ?? Permissions.defaultBit)\n      .add(roleOverwrites?.allow ?? Permissions.defaultBit)\n      .freeze();\n  }\n\n  /**\n   * Locks in the permission overwrites from the parent channel.\n   * @returns {Promise<GuildChannel>}\n   */\n  lockPermissions() {\n    if (!this.parent) return Promise.reject(new Error('GUILD_CHANNEL_ORPHAN'));\n    const permissionOverwrites = this.parent.permissionOverwrites.cache.map(overwrite => overwrite.toJSON());\n    return this.edit({ permissionOverwrites });\n  }\n\n  /**\n   * A collection of cached members of this channel, mapped by their ids.\n   * Members that can view this channel, if the channel is text-based.\n   * Members in the channel, if the channel is voice-based.\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n  get members() {\n    return this.guild.members.cache.filter(m => this.permissionsFor(m).has(Permissions.FLAGS.VIEW_CHANNEL, false));\n  }\n\n  /**\n   * The data for a guild channel.\n   * @typedef {Object} ChannelData\n   * @property {string} [name] The name of the channel\n   * @property {ChannelType} [type] The type of the channel (only conversion between text and news is supported)\n   * @property {number} [position] The position of the channel\n   * @property {string} [topic] The topic of the text channel\n   * @property {boolean} [nsfw] Whether the channel is NSFW\n   * @property {number} [bitrate] The bitrate of the voice channel\n   * @property {number} [userLimit] The user limit of the voice channel\n   * @property {?CategoryChannelResolvable} [parent] The parent of the channel\n   * @property {boolean} [lockPermissions]\n   * Lock the permissions of the channel to what the parent's permissions are\n   * @property {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} [permissionOverwrites]\n   * Permission overwrites for the channel\n   * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the channel in seconds\n   * @property {ThreadAutoArchiveDuration} [defaultAutoArchiveDuration]\n   * The default auto archive duration for all new threads in this channel\n   * @property {?string} [rtcRegion] The RTC region of the channel\n   */\n\n  /**\n   * Edits the channel.\n   * @param {ChannelData} data The new data for the channel\n   * @param {string} [reason] Reason for editing this channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Edit a channel\n   * channel.edit({ name: 'new-channel' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async edit(data, reason) {\n    data.parent &&= this.client.channels.resolveId(data.parent);\n\n    if (typeof data.position !== 'undefined') {\n      const updatedChannels = await Util.setPosition(\n        this,\n        data.position,\n        false,\n        this.guild._sortedChannels(this),\n        this.client.api.guilds(this.guild.id).channels,\n        reason,\n      );\n      this.client.actions.GuildChannelsPositionUpdate.handle({\n        guild_id: this.guild.id,\n        channels: updatedChannels,\n      });\n    }\n\n    let permission_overwrites;\n\n    if (data.permissionOverwrites) {\n      permission_overwrites = data.permissionOverwrites.map(o => PermissionOverwrites.resolve(o, this.guild));\n    }\n\n    if (data.lockPermissions) {\n      if (data.parent) {\n        const newParent = this.guild.channels.resolve(data.parent);\n        if (newParent?.type === 'GUILD_CATEGORY') {\n          permission_overwrites = newParent.permissionOverwrites.cache.map(o =>\n            PermissionOverwrites.resolve(o, this.guild),\n          );\n        }\n      } else if (this.parent) {\n        permission_overwrites = this.parent.permissionOverwrites.cache.map(o =>\n          PermissionOverwrites.resolve(o, this.guild),\n        );\n      }\n    }\n\n    const newData = await this.client.api.channels(this.id).patch({\n      data: {\n        name: (data.name ?? this.name).trim(),\n        type: ChannelTypes[data.type],\n        topic: data.topic,\n        nsfw: data.nsfw,\n        bitrate: data.bitrate ?? this.bitrate,\n        user_limit: data.userLimit ?? this.userLimit,\n        rtc_region: data.rtcRegion ?? this.rtcRegion,\n        parent_id: data.parent,\n        lock_permissions: data.lockPermissions,\n        rate_limit_per_user: data.rateLimitPerUser,\n        default_auto_archive_duration: data.defaultAutoArchiveDuration,\n        permission_overwrites,\n      },\n      reason,\n    });\n\n    return this.client.actions.ChannelUpdate.handle(newData).updated;\n  }\n\n  /**\n   * Sets a new name for the guild channel.\n   * @param {string} name The new name for the guild channel\n   * @param {string} [reason] Reason for changing the guild channel's name\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel name\n   * channel.setName('not_general')\n   *   .then(newChannel => console.log(`Channel's new name is ${newChannel.name}`))\n   *   .catch(console.error);\n   */\n  setName(name, reason) {\n    return this.edit({ name }, reason);\n  }\n\n  /**\n   * Options used to set the parent of a channel.\n   * @typedef {Object} SetParentOptions\n   * @property {boolean} [lockPermissions=true] Whether to lock the permissions to what the parent's permissions are\n   * @property {string} [reason] The reason for modifying the parent of the channel\n   */\n\n  /**\n   * Sets the parent of this channel.\n   * @param {?CategoryChannelResolvable} channel The category channel to set as the parent\n   * @param {SetParentOptions} [options={}] The options for setting the parent\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Add a parent to a channel\n   * message.channel.setParent('355908108431917066', { lockPermissions: false })\n   *   .then(channel => console.log(`New parent of ${message.channel.name}: ${channel.name}`))\n   *   .catch(console.error);\n   */\n  setParent(channel, { lockPermissions = true, reason } = {}) {\n    return this.edit(\n      {\n        parent: channel ?? null,\n        lockPermissions,\n      },\n      reason,\n    );\n  }\n\n  /**\n   * Options used to set the position of a channel.\n   * @typedef {Object} SetChannelPositionOptions\n   * @property {boolean} [relative=false] Whether or not to change the position relative to its current value\n   * @property {string} [reason] The reason for changing the position\n   */\n\n  /**\n   * Sets a new position for the guild channel.\n   * @param {number} position The new position for the guild channel\n   * @param {SetChannelPositionOptions} [options] Options for setting position\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel position\n   * channel.setPosition(2)\n   *   .then(newChannel => console.log(`Channel's new position is ${newChannel.position}`))\n   *   .catch(console.error);\n   */\n  async setPosition(position, { relative, reason } = {}) {\n    const updatedChannels = await Util.setPosition(\n      this,\n      position,\n      relative,\n      this.guild._sortedChannels(this),\n      this.client.api.guilds(this.guild.id).channels,\n      reason,\n    );\n    this.client.actions.GuildChannelsPositionUpdate.handle({\n      guild_id: this.guild.id,\n      channels: updatedChannels,\n    });\n    return this;\n  }\n\n  /**\n   * Data that can be resolved to an Application. This can be:\n   * * An Application\n   * * An Activity with associated Application\n   * * A Snowflake\n   * @typedef {Application|Snowflake} ApplicationResolvable\n   */\n\n  /**\n   * Options used to clone a guild channel.\n   * @typedef {GuildChannelCreateOptions} GuildChannelCloneOptions\n   * @property {string} [name=this.name] Name of the new channel\n   */\n\n  /**\n   * Clones this channel.\n   * @param {GuildChannelCloneOptions} [options] The options for cloning this channel\n   * @returns {Promise<GuildChannel>}\n   */\n  clone(options = {}) {\n    return this.guild.channels.create(options.name ?? this.name, {\n      permissionOverwrites: this.permissionOverwrites.cache,\n      topic: this.topic,\n      type: this.type,\n      nsfw: this.nsfw,\n      parent: this.parent,\n      bitrate: this.bitrate,\n      userLimit: this.userLimit,\n      rateLimitPerUser: this.rateLimitPerUser,\n      position: this.rawPosition,\n      reason: null,\n      ...options,\n    });\n  }\n\n  /**\n   * Checks if this channel has the same type, topic, position, name, overwrites, and id as another channel.\n   * In most cases, a simple `channel.id === channel2.id` will do, and is much faster too.\n   * @param {GuildChannel} channel Channel to compare with\n   * @returns {boolean}\n   */\n  equals(channel) {\n    let equal =\n      channel &&\n      this.id === channel.id &&\n      this.type === channel.type &&\n      this.topic === channel.topic &&\n      this.position === channel.position &&\n      this.name === channel.name;\n\n    if (equal) {\n      if (this.permissionOverwrites && channel.permissionOverwrites) {\n        equal = this.permissionOverwrites.cache.equals(channel.permissionOverwrites.cache);\n      } else {\n        equal = !this.permissionOverwrites && !channel.permissionOverwrites;\n      }\n    }\n\n    return equal;\n  }\n\n  /**\n   * Whether the channel is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get deletable() {\n    return this.manageable && this.guild.rulesChannelId !== this.id && this.guild.publicUpdatesChannelId !== this.id;\n  }\n\n  /**\n   * Whether the channel is manageable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get manageable() {\n    if (this.client.user.id === this.guild.ownerId) return true;\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false;\n\n    // This flag allows managing even if timed out\n    if (permissions.has(Permissions.FLAGS.ADMINISTRATOR, false)) return true;\n    if (this.guild.me.communicationDisabledUntilTimestamp > Date.now()) return false;\n\n    const bitfield = VoiceBasedChannelTypes.includes(this.type)\n      ? Permissions.FLAGS.MANAGE_CHANNELS | Permissions.FLAGS.CONNECT\n      : Permissions.FLAGS.VIEW_CHANNEL | Permissions.FLAGS.MANAGE_CHANNELS;\n    return permissions.has(bitfield, false);\n  }\n\n  /**\n   * Whether the channel is viewable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get viewable() {\n    if (this.client.user.id === this.guild.ownerId) return true;\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    return permissions.has(Permissions.FLAGS.VIEW_CHANNEL, false);\n  }\n\n  /**\n   * Deletes this channel.\n   * @param {string} [reason] Reason for deleting this channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Delete the channel\n   * channel.delete('making room for new channels')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async delete(reason) {\n    await this.client.api.channels(this.id).delete({ reason });\n    return this;\n  }\n}\n\nmodule.exports = GuildChannel;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}