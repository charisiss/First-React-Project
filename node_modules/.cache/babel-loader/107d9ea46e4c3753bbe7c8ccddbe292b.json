{"ast":null,"code":"'use strict';\n\nconst {\n  parse\n} = require('node:path');\n\nconst process = require('node:process');\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst fetch = require('node-fetch');\n\nconst {\n  Colors,\n  Endpoints\n} = require('./Constants');\n\nconst Options = require('./Options');\n\nconst {\n  Error: DiscordError,\n  RangeError,\n  TypeError\n} = require('../errors');\n\nconst has = (o, k) => Object.prototype.hasOwnProperty.call(o, k);\n\nconst isObject = d => typeof d === 'object' && d !== null;\n\nlet deprecationEmittedForRemoveMentions = false;\n/**\n * Contains various general-purpose utility methods.\n */\n\nclass Util extends null {\n  /**\n   * Flatten an object. Any properties that are collections will get converted to an array of keys.\n   * @param {Object} obj The object to flatten.\n   * @param {...Object<string, boolean|string>} [props] Specific properties to include/exclude.\n   * @returns {Object}\n   */\n  static flatten(obj) {\n    for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      props[_key - 1] = arguments[_key];\n    }\n\n    if (!isObject(obj)) return obj;\n    const objProps = Object.keys(obj).filter(k => !k.startsWith('_')).map(k => ({\n      [k]: true\n    }));\n    props = objProps.length ? Object.assign(...objProps, ...props) : Object.assign({}, ...props);\n    const out = {};\n\n    for (let [prop, newProp] of Object.entries(props)) {\n      if (!newProp) continue;\n      newProp = newProp === true ? prop : newProp;\n      const element = obj[prop];\n      const elemIsObj = isObject(element);\n      const valueOf = elemIsObj && typeof element.valueOf === 'function' ? element.valueOf() : null; // If it's a Collection, make the array of keys\n\n      if (element instanceof Collection) out[newProp] = Array.from(element.keys()); // If the valueOf is a Collection, use its array of keys\n      else if (valueOf instanceof Collection) out[newProp] = Array.from(valueOf.keys()); // If it's an array, flatten each element\n      else if (Array.isArray(element)) out[newProp] = element.map(e => Util.flatten(e)); // If it's an object with a primitive `valueOf`, use that value\n      else if (typeof valueOf !== 'object') out[newProp] = valueOf; // If it's a primitive\n      else if (!elemIsObj) out[newProp] = element;\n    }\n\n    return out;\n  }\n  /**\n   * Options for splitting a message.\n   * @typedef {Object} SplitOptions\n   * @property {number} [maxLength=2000] Maximum character length per message piece\n   * @property {string|string[]|RegExp|RegExp[]} [char='\\n'] Character(s) or Regex(es) to split the message with,\n   * an array can be used to split multiple times\n   * @property {string} [prepend=''] Text to prepend to every piece except the first\n   * @property {string} [append=''] Text to append to every piece except the last\n   */\n\n  /**\n   * Splits a string into multiple chunks at a designated character that do not exceed a specific length.\n   * @param {string} text Content to split\n   * @param {SplitOptions} [options] Options controlling the behavior of the split\n   * @returns {string[]}\n   */\n\n\n  static splitMessage(text) {\n    let {\n      maxLength = 2_000,\n      char = '\\n',\n      prepend = '',\n      append = ''\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    text = Util.verifyString(text);\n    if (text.length <= maxLength) return [text];\n    let splitText = [text];\n\n    if (Array.isArray(char)) {\n      while (char.length > 0 && splitText.some(elem => elem.length > maxLength)) {\n        const currentChar = char.shift();\n\n        if (currentChar instanceof RegExp) {\n          splitText = splitText.flatMap(chunk => chunk.match(currentChar));\n        } else {\n          splitText = splitText.flatMap(chunk => chunk.split(currentChar));\n        }\n      }\n    } else {\n      splitText = text.split(char);\n    }\n\n    if (splitText.some(elem => elem.length > maxLength)) throw new RangeError('SPLIT_MAX_LEN');\n    const messages = [];\n    let msg = '';\n\n    for (const chunk of splitText) {\n      if (msg && (msg + char + chunk + append).length > maxLength) {\n        messages.push(msg + append);\n        msg = prepend;\n      }\n\n      msg += (msg && msg !== prepend ? char : '') + chunk;\n    }\n\n    return messages.concat(msg).filter(m => m);\n  }\n  /**\n   * Options used to escape markdown.\n   * @typedef {Object} EscapeMarkdownOptions\n   * @property {boolean} [codeBlock=true] Whether to escape code blocks or not\n   * @property {boolean} [inlineCode=true] Whether to escape inline code or not\n   * @property {boolean} [bold=true] Whether to escape bolds or not\n   * @property {boolean} [italic=true] Whether to escape italics or not\n   * @property {boolean} [underline=true] Whether to escape underlines or not\n   * @property {boolean} [strikethrough=true] Whether to escape strikethroughs or not\n   * @property {boolean} [spoiler=true] Whether to escape spoilers or not\n   * @property {boolean} [codeBlockContent=true] Whether to escape text inside code blocks or not\n   * @property {boolean} [inlineCodeContent=true] Whether to escape text inside inline code or not\n   */\n\n  /**\n   * Escapes any Discord-flavour markdown in a string.\n   * @param {string} text Content to escape\n   * @param {EscapeMarkdownOptions} [options={}] Options for escaping the markdown\n   * @returns {string}\n   */\n\n\n  static escapeMarkdown(text) {\n    let {\n      codeBlock = true,\n      inlineCode = true,\n      bold = true,\n      italic = true,\n      underline = true,\n      strikethrough = true,\n      spoiler = true,\n      codeBlockContent = true,\n      inlineCodeContent = true\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!codeBlockContent) {\n      return text.split('```').map((subString, index, array) => {\n        if (index % 2 && index !== array.length - 1) return subString;\n        return Util.escapeMarkdown(subString, {\n          inlineCode,\n          bold,\n          italic,\n          underline,\n          strikethrough,\n          spoiler,\n          inlineCodeContent\n        });\n      }).join(codeBlock ? '\\\\`\\\\`\\\\`' : '```');\n    }\n\n    if (!inlineCodeContent) {\n      return text.split(/(?<=^|[^`])`(?=[^`]|$)/g).map((subString, index, array) => {\n        if (index % 2 && index !== array.length - 1) return subString;\n        return Util.escapeMarkdown(subString, {\n          codeBlock,\n          bold,\n          italic,\n          underline,\n          strikethrough,\n          spoiler\n        });\n      }).join(inlineCode ? '\\\\`' : '`');\n    }\n\n    if (inlineCode) text = Util.escapeInlineCode(text);\n    if (codeBlock) text = Util.escapeCodeBlock(text);\n    if (italic) text = Util.escapeItalic(text);\n    if (bold) text = Util.escapeBold(text);\n    if (underline) text = Util.escapeUnderline(text);\n    if (strikethrough) text = Util.escapeStrikethrough(text);\n    if (spoiler) text = Util.escapeSpoiler(text);\n    return text;\n  }\n  /**\n   * Escapes code block markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n\n\n  static escapeCodeBlock(text) {\n    return text.replaceAll('```', '\\\\`\\\\`\\\\`');\n  }\n  /**\n   * Escapes inline code markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n\n\n  static escapeInlineCode(text) {\n    return text.replace(/(?<=^|[^`])`(?=[^`]|$)/g, '\\\\`');\n  }\n  /**\n   * Escapes italic markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n\n\n  static escapeItalic(text) {\n    let i = 0;\n    text = text.replace(/(?<=^|[^*])\\*([^*]|\\*\\*|$)/g, (_, match) => {\n      if (match === '**') return ++i % 2 ? `\\\\*${match}` : `${match}\\\\*`;\n      return `\\\\*${match}`;\n    });\n    i = 0;\n    return text.replace(/(?<=^|[^_])_([^_]|__|$)/g, (_, match) => {\n      if (match === '__') return ++i % 2 ? `\\\\_${match}` : `${match}\\\\_`;\n      return `\\\\_${match}`;\n    });\n  }\n  /**\n   * Escapes bold markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n\n\n  static escapeBold(text) {\n    let i = 0;\n    return text.replace(/\\*\\*(\\*)?/g, (_, match) => {\n      if (match) return ++i % 2 ? `${match}\\\\*\\\\*` : `\\\\*\\\\*${match}`;\n      return '\\\\*\\\\*';\n    });\n  }\n  /**\n   * Escapes underline markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n\n\n  static escapeUnderline(text) {\n    let i = 0;\n    return text.replace(/__(_)?/g, (_, match) => {\n      if (match) return ++i % 2 ? `${match}\\\\_\\\\_` : `\\\\_\\\\_${match}`;\n      return '\\\\_\\\\_';\n    });\n  }\n  /**\n   * Escapes strikethrough markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n\n\n  static escapeStrikethrough(text) {\n    return text.replaceAll('~~', '\\\\~\\\\~');\n  }\n  /**\n   * Escapes spoiler markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n\n\n  static escapeSpoiler(text) {\n    return text.replaceAll('||', '\\\\|\\\\|');\n  }\n  /**\n   * @typedef {Object} FetchRecommendedShardsOptions\n   * @property {number} [guildsPerShard=1000] Number of guilds assigned per shard\n   * @property {number} [multipleOf=1] The multiple the shard count should round up to. (16 for large bot sharding)\n   */\n\n  /**\n   * Gets the recommended shard count from Discord.\n   * @param {string} token Discord auth token\n   * @param {FetchRecommendedShardsOptions} [options] Options for fetching the recommended shard count\n   * @returns {Promise<number>} The recommended number of shards\n   */\n\n\n  static async fetchRecommendedShards(token) {\n    let {\n      guildsPerShard = 1_000,\n      multipleOf = 1\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!token) throw new DiscordError('TOKEN_MISSING');\n    const defaults = Options.createDefault();\n    const response = await fetch(`${defaults.http.api}/v${defaults.http.version}${Endpoints.botGateway}`, {\n      method: 'GET',\n      headers: {\n        Authorization: `Bot ${token.replace(/^Bot\\s*/i, '')}`\n      }\n    });\n\n    if (!response.ok) {\n      if (response.status === 401) throw new DiscordError('TOKEN_INVALID');\n      throw response;\n    }\n\n    const {\n      shards\n    } = await response.json();\n    return Math.ceil(shards * (1_000 / guildsPerShard) / multipleOf) * multipleOf;\n  }\n  /**\n   * Parses emoji info out of a string. The string must be one of:\n   * * A UTF-8 emoji (no id)\n   * * A URL-encoded UTF-8 emoji (no id)\n   * * A Discord custom emoji (`<:name:id>` or `<a:name:id>`)\n   * @param {string} text Emoji string to parse\n   * @returns {APIEmoji} Object with `animated`, `name`, and `id` properties\n   * @private\n   */\n\n\n  static parseEmoji(text) {\n    if (text.includes('%')) text = decodeURIComponent(text);\n    if (!text.includes(':')) return {\n      animated: false,\n      name: text,\n      id: null\n    };\n    const match = text.match(/<?(?:(a):)?(\\w{2,32}):(\\d{17,19})?>?/);\n    return match && {\n      animated: Boolean(match[1]),\n      name: match[2],\n      id: match[3] ?? null\n    };\n  }\n  /**\n   * Resolves a partial emoji object from an {@link EmojiIdentifierResolvable}, without checking a Client.\n   * @param {EmojiIdentifierResolvable} emoji Emoji identifier to resolve\n   * @returns {?RawEmoji}\n   * @private\n   */\n\n\n  static resolvePartialEmoji(emoji) {\n    if (!emoji) return null;\n    if (typeof emoji === 'string') return /^\\d{17,19}$/.test(emoji) ? {\n      id: emoji\n    } : Util.parseEmoji(emoji);\n    const {\n      id,\n      name,\n      animated\n    } = emoji;\n    if (!id && !name) return null;\n    return {\n      id,\n      name,\n      animated: Boolean(animated)\n    };\n  }\n  /**\n   * Shallow-copies an object with its class/prototype intact.\n   * @param {Object} obj Object to clone\n   * @returns {Object}\n   * @private\n   */\n\n\n  static cloneObject(obj) {\n    return Object.assign(Object.create(obj), obj);\n  }\n  /**\n   * Sets default properties on an object that aren't already specified.\n   * @param {Object} def Default properties\n   * @param {Object} given Object to assign defaults to\n   * @returns {Object}\n   * @private\n   */\n\n\n  static mergeDefault(def, given) {\n    if (!given) return def;\n\n    for (const key in def) {\n      if (!has(given, key) || given[key] === undefined) {\n        given[key] = def[key];\n      } else if (given[key] === Object(given[key])) {\n        given[key] = Util.mergeDefault(def[key], given[key]);\n      }\n    }\n\n    return given;\n  }\n  /**\n   * Options used to make an error object.\n   * @typedef {Object} MakeErrorOptions\n   * @property {string} name Error type\n   * @property {string} message Message for the error\n   * @property {string} stack Stack for the error\n   */\n\n  /**\n   * Makes an Error from a plain info object.\n   * @param {MakeErrorOptions} obj Error info\n   * @returns {Error}\n   * @private\n   */\n\n\n  static makeError(obj) {\n    const err = new Error(obj.message);\n    err.name = obj.name;\n    err.stack = obj.stack;\n    return err;\n  }\n  /**\n   * Makes a plain error info object from an Error.\n   * @param {Error} err Error to get info from\n   * @returns {MakeErrorOptions}\n   * @private\n   */\n\n\n  static makePlainError(err) {\n    return {\n      name: err.name,\n      message: err.message,\n      stack: err.stack\n    };\n  }\n  /**\n   * Moves an element in an array *in place*.\n   * @param {Array<*>} array Array to modify\n   * @param {*} element Element to move\n   * @param {number} newIndex Index or offset to move the element to\n   * @param {boolean} [offset=false] Move the element by an offset amount rather than to a set index\n   * @returns {number}\n   * @private\n   */\n\n\n  static moveElementInArray(array, element, newIndex) {\n    let offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const index = array.indexOf(element);\n    newIndex = (offset ? index : 0) + newIndex;\n\n    if (newIndex > -1 && newIndex < array.length) {\n      const removedElement = array.splice(index, 1)[0];\n      array.splice(newIndex, 0, removedElement);\n    }\n\n    return array.indexOf(element);\n  }\n  /**\n   * Verifies the provided data is a string, otherwise throws provided error.\n   * @param {string} data The string resolvable to resolve\n   * @param {Function} [error] The Error constructor to instantiate. Defaults to Error\n   * @param {string} [errorMessage] The error message to throw with. Defaults to \"Expected string, got <data> instead.\"\n   * @param {boolean} [allowEmpty=true] Whether an empty string should be allowed\n   * @returns {string}\n   */\n\n\n  static verifyString(data) {\n    let error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Error;\n    let errorMessage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : `Expected a string, got ${data} instead.`;\n    let allowEmpty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    if (typeof data !== 'string') throw new error(errorMessage);\n    if (!allowEmpty && data.length === 0) throw new error(errorMessage);\n    return data;\n  }\n  /**\n   * Can be a number, hex string, an RGB array like:\n   * ```js\n   * [255, 0, 255] // purple\n   * ```\n   * or one of the following strings:\n   * - `DEFAULT`\n   * - `WHITE`\n   * - `AQUA`\n   * - `GREEN`\n   * - `BLUE`\n   * - `YELLOW`\n   * - `PURPLE`\n   * - `LUMINOUS_VIVID_PINK`\n   * - `FUCHSIA`\n   * - `GOLD`\n   * - `ORANGE`\n   * - `RED`\n   * - `GREY`\n   * - `NAVY`\n   * - `DARK_AQUA`\n   * - `DARK_GREEN`\n   * - `DARK_BLUE`\n   * - `DARK_PURPLE`\n   * - `DARK_VIVID_PINK`\n   * - `DARK_GOLD`\n   * - `DARK_ORANGE`\n   * - `DARK_RED`\n   * - `DARK_GREY`\n   * - `DARKER_GREY`\n   * - `LIGHT_GREY`\n   * - `DARK_NAVY`\n   * - `BLURPLE`\n   * - `GREYPLE`\n   * - `DARK_BUT_NOT_BLACK`\n   * - `NOT_QUITE_BLACK`\n   * - `RANDOM`\n   * @typedef {string|number|number[]} ColorResolvable\n   */\n\n  /**\n   * Resolves a ColorResolvable into a color number.\n   * @param {ColorResolvable} color Color to resolve\n   * @returns {number} A color\n   */\n\n\n  static resolveColor(color) {\n    if (typeof color === 'string') {\n      if (color === 'RANDOM') return Math.floor(Math.random() * (0xffffff + 1));\n      if (color === 'DEFAULT') return 0;\n      color = Colors[color] ?? parseInt(color.replace('#', ''), 16);\n    } else if (Array.isArray(color)) {\n      color = (color[0] << 16) + (color[1] << 8) + color[2];\n    }\n\n    if (color < 0 || color > 0xffffff) throw new RangeError('COLOR_RANGE');else if (Number.isNaN(color)) throw new TypeError('COLOR_CONVERT');\n    return color;\n  }\n  /**\n   * Sorts by Discord's position and id.\n   * @param {Collection} collection Collection of objects to sort\n   * @returns {Collection}\n   */\n\n\n  static discordSort(collection) {\n    const isGuildChannel = collection.first() instanceof GuildChannel;\n    return collection.sorted(isGuildChannel ? (a, b) => a.rawPosition - b.rawPosition || Number(BigInt(a.id) - BigInt(b.id)) : (a, b) => a.rawPosition - b.rawPosition || Number(BigInt(b.id) - BigInt(a.id)));\n  }\n  /**\n   * Sets the position of a Channel or Role.\n   * @param {Channel|Role} item Object to set the position of\n   * @param {number} position New position for the object\n   * @param {boolean} relative Whether `position` is relative to its current position\n   * @param {Collection<string, Channel|Role>} sorted A collection of the objects sorted properly\n   * @param {APIRouter} route Route to call PATCH on\n   * @param {string} [reason] Reason for the change\n   * @returns {Promise<Channel[]|Role[]>} Updated item list, with `id` and `position` properties\n   * @private\n   */\n\n\n  static async setPosition(item, position, relative, sorted, route, reason) {\n    let updatedItems = [...sorted.values()];\n    Util.moveElementInArray(updatedItems, item, position, relative);\n    updatedItems = updatedItems.map((r, i) => ({\n      id: r.id,\n      position: i\n    }));\n    await route.patch({\n      data: updatedItems,\n      reason\n    });\n    return updatedItems;\n  }\n  /**\n   * Alternative to Node's `path.basename`, removing query string after the extension if it exists.\n   * @param {string} path Path to get the basename of\n   * @param {string} [ext] File extension to remove\n   * @returns {string} Basename of the path\n   * @private\n   */\n\n\n  static basename(path, ext) {\n    const res = parse(path);\n    return ext && res.ext.startsWith(ext) ? res.name : res.base.split('?')[0];\n  }\n  /**\n   * Breaks user, role and everyone/here mentions by adding a zero width space after every @ character\n   * @param {string} str The string to sanitize\n   * @returns {string}\n   * @deprecated Use {@link BaseMessageOptions#allowedMentions} instead.\n   */\n\n\n  static removeMentions(str) {\n    if (!deprecationEmittedForRemoveMentions) {\n      process.emitWarning('The Util.removeMentions method is deprecated. Use MessageOptions#allowedMentions instead.', 'DeprecationWarning');\n      deprecationEmittedForRemoveMentions = true;\n    }\n\n    return Util._removeMentions(str);\n  }\n\n  static _removeMentions(str) {\n    return str.replaceAll('@', '@\\u200b');\n  }\n  /**\n   * The content to have all mentions replaced by the equivalent text.\n   * <warn>When {@link Util.removeMentions} is removed, this method will no longer sanitize mentions.\n   * Use {@link BaseMessageOptions#allowedMentions} instead to prevent mentions when sending a message.</warn>\n   * @param {string} str The string to be converted\n   * @param {TextBasedChannels} channel The channel the string was sent in\n   * @returns {string}\n   */\n\n\n  static cleanContent(str, channel) {\n    str = str.replace(/<@!?[0-9]+>/g, input => {\n      const id = input.replace(/<|!|>|@/g, '');\n\n      if (channel.type === 'DM') {\n        const user = channel.client.users.cache.get(id);\n        return user ? Util._removeMentions(`@${user.username}`) : input;\n      }\n\n      const member = channel.guild.members.cache.get(id);\n\n      if (member) {\n        return Util._removeMentions(`@${member.displayName}`);\n      } else {\n        const user = channel.client.users.cache.get(id);\n        return user ? Util._removeMentions(`@${user.username}`) : input;\n      }\n    }).replace(/<#[0-9]+>/g, input => {\n      const mentionedChannel = channel.client.channels.cache.get(input.replace(/<|#|>/g, ''));\n      return mentionedChannel ? `#${mentionedChannel.name}` : input;\n    }).replace(/<@&[0-9]+>/g, input => {\n      if (channel.type === 'DM') return input;\n      const role = channel.guild.roles.cache.get(input.replace(/<|@|>|&/g, ''));\n      return role ? `@${role.name}` : input;\n    });\n    return str;\n  }\n  /**\n   * The content to put in a code block with all code block fences replaced by the equivalent backticks.\n   * @param {string} text The string to be converted\n   * @returns {string}\n   */\n\n\n  static cleanCodeBlockContent(text) {\n    return text.replaceAll('```', '`\\u200b``');\n  }\n  /**\n   * Creates a sweep filter that sweeps archived threads\n   * @param {number} [lifetime=14400] How long a thread has to be archived to be valid for sweeping\n   * @deprecated When not using with `makeCache` use `Sweepers.archivedThreadSweepFilter` instead\n   * @returns {SweepFilter}\n   */\n\n\n  static archivedThreadSweepFilter() {\n    let lifetime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 14400;\n\n    const filter = require('./Sweepers').archivedThreadSweepFilter(lifetime);\n\n    filter.isDefault = true;\n    return filter;\n  }\n\n}\n\nmodule.exports = Util; // Fixes Circular\n\nconst GuildChannel = require('../structures/GuildChannel');","map":{"version":3,"names":["parse","require","process","Collection","fetch","Colors","Endpoints","Options","Error","DiscordError","RangeError","TypeError","has","o","k","Object","prototype","hasOwnProperty","call","isObject","d","deprecationEmittedForRemoveMentions","Util","flatten","obj","props","objProps","keys","filter","startsWith","map","length","assign","out","prop","newProp","entries","element","elemIsObj","valueOf","Array","from","isArray","e","splitMessage","text","maxLength","char","prepend","append","verifyString","splitText","some","elem","currentChar","shift","RegExp","flatMap","chunk","match","split","messages","msg","push","concat","m","escapeMarkdown","codeBlock","inlineCode","bold","italic","underline","strikethrough","spoiler","codeBlockContent","inlineCodeContent","subString","index","array","join","escapeInlineCode","escapeCodeBlock","escapeItalic","escapeBold","escapeUnderline","escapeStrikethrough","escapeSpoiler","replaceAll","replace","i","_","fetchRecommendedShards","token","guildsPerShard","multipleOf","defaults","createDefault","response","http","api","version","botGateway","method","headers","Authorization","ok","status","shards","json","Math","ceil","parseEmoji","includes","decodeURIComponent","animated","name","id","Boolean","resolvePartialEmoji","emoji","test","cloneObject","create","mergeDefault","def","given","key","undefined","makeError","err","message","stack","makePlainError","moveElementInArray","newIndex","offset","indexOf","removedElement","splice","data","error","errorMessage","allowEmpty","resolveColor","color","floor","random","parseInt","Number","isNaN","discordSort","collection","isGuildChannel","first","GuildChannel","sorted","a","b","rawPosition","BigInt","setPosition","item","position","relative","route","reason","updatedItems","values","r","patch","basename","path","ext","res","base","removeMentions","str","emitWarning","_removeMentions","cleanContent","channel","input","type","user","client","users","cache","get","username","member","guild","members","displayName","mentionedChannel","channels","role","roles","cleanCodeBlockContent","archivedThreadSweepFilter","lifetime","isDefault","module","exports"],"sources":["C:/Users/xsxsam/node_modules/discord.js/src/util/Util.js"],"sourcesContent":["'use strict';\n\nconst { parse } = require('node:path');\nconst process = require('node:process');\nconst { Collection } = require('@discordjs/collection');\nconst fetch = require('node-fetch');\nconst { Colors, Endpoints } = require('./Constants');\nconst Options = require('./Options');\nconst { Error: DiscordError, RangeError, TypeError } = require('../errors');\nconst has = (o, k) => Object.prototype.hasOwnProperty.call(o, k);\nconst isObject = d => typeof d === 'object' && d !== null;\n\nlet deprecationEmittedForRemoveMentions = false;\n\n/**\n * Contains various general-purpose utility methods.\n */\nclass Util extends null {\n  /**\n   * Flatten an object. Any properties that are collections will get converted to an array of keys.\n   * @param {Object} obj The object to flatten.\n   * @param {...Object<string, boolean|string>} [props] Specific properties to include/exclude.\n   * @returns {Object}\n   */\n  static flatten(obj, ...props) {\n    if (!isObject(obj)) return obj;\n\n    const objProps = Object.keys(obj)\n      .filter(k => !k.startsWith('_'))\n      .map(k => ({ [k]: true }));\n\n    props = objProps.length ? Object.assign(...objProps, ...props) : Object.assign({}, ...props);\n\n    const out = {};\n\n    for (let [prop, newProp] of Object.entries(props)) {\n      if (!newProp) continue;\n      newProp = newProp === true ? prop : newProp;\n\n      const element = obj[prop];\n      const elemIsObj = isObject(element);\n      const valueOf = elemIsObj && typeof element.valueOf === 'function' ? element.valueOf() : null;\n\n      // If it's a Collection, make the array of keys\n      if (element instanceof Collection) out[newProp] = Array.from(element.keys());\n      // If the valueOf is a Collection, use its array of keys\n      else if (valueOf instanceof Collection) out[newProp] = Array.from(valueOf.keys());\n      // If it's an array, flatten each element\n      else if (Array.isArray(element)) out[newProp] = element.map(e => Util.flatten(e));\n      // If it's an object with a primitive `valueOf`, use that value\n      else if (typeof valueOf !== 'object') out[newProp] = valueOf;\n      // If it's a primitive\n      else if (!elemIsObj) out[newProp] = element;\n    }\n\n    return out;\n  }\n\n  /**\n   * Options for splitting a message.\n   * @typedef {Object} SplitOptions\n   * @property {number} [maxLength=2000] Maximum character length per message piece\n   * @property {string|string[]|RegExp|RegExp[]} [char='\\n'] Character(s) or Regex(es) to split the message with,\n   * an array can be used to split multiple times\n   * @property {string} [prepend=''] Text to prepend to every piece except the first\n   * @property {string} [append=''] Text to append to every piece except the last\n   */\n\n  /**\n   * Splits a string into multiple chunks at a designated character that do not exceed a specific length.\n   * @param {string} text Content to split\n   * @param {SplitOptions} [options] Options controlling the behavior of the split\n   * @returns {string[]}\n   */\n  static splitMessage(text, { maxLength = 2_000, char = '\\n', prepend = '', append = '' } = {}) {\n    text = Util.verifyString(text);\n    if (text.length <= maxLength) return [text];\n    let splitText = [text];\n    if (Array.isArray(char)) {\n      while (char.length > 0 && splitText.some(elem => elem.length > maxLength)) {\n        const currentChar = char.shift();\n        if (currentChar instanceof RegExp) {\n          splitText = splitText.flatMap(chunk => chunk.match(currentChar));\n        } else {\n          splitText = splitText.flatMap(chunk => chunk.split(currentChar));\n        }\n      }\n    } else {\n      splitText = text.split(char);\n    }\n    if (splitText.some(elem => elem.length > maxLength)) throw new RangeError('SPLIT_MAX_LEN');\n    const messages = [];\n    let msg = '';\n    for (const chunk of splitText) {\n      if (msg && (msg + char + chunk + append).length > maxLength) {\n        messages.push(msg + append);\n        msg = prepend;\n      }\n      msg += (msg && msg !== prepend ? char : '') + chunk;\n    }\n    return messages.concat(msg).filter(m => m);\n  }\n\n  /**\n   * Options used to escape markdown.\n   * @typedef {Object} EscapeMarkdownOptions\n   * @property {boolean} [codeBlock=true] Whether to escape code blocks or not\n   * @property {boolean} [inlineCode=true] Whether to escape inline code or not\n   * @property {boolean} [bold=true] Whether to escape bolds or not\n   * @property {boolean} [italic=true] Whether to escape italics or not\n   * @property {boolean} [underline=true] Whether to escape underlines or not\n   * @property {boolean} [strikethrough=true] Whether to escape strikethroughs or not\n   * @property {boolean} [spoiler=true] Whether to escape spoilers or not\n   * @property {boolean} [codeBlockContent=true] Whether to escape text inside code blocks or not\n   * @property {boolean} [inlineCodeContent=true] Whether to escape text inside inline code or not\n   */\n\n  /**\n   * Escapes any Discord-flavour markdown in a string.\n   * @param {string} text Content to escape\n   * @param {EscapeMarkdownOptions} [options={}] Options for escaping the markdown\n   * @returns {string}\n   */\n  static escapeMarkdown(\n    text,\n    {\n      codeBlock = true,\n      inlineCode = true,\n      bold = true,\n      italic = true,\n      underline = true,\n      strikethrough = true,\n      spoiler = true,\n      codeBlockContent = true,\n      inlineCodeContent = true,\n    } = {},\n  ) {\n    if (!codeBlockContent) {\n      return text\n        .split('```')\n        .map((subString, index, array) => {\n          if (index % 2 && index !== array.length - 1) return subString;\n          return Util.escapeMarkdown(subString, {\n            inlineCode,\n            bold,\n            italic,\n            underline,\n            strikethrough,\n            spoiler,\n            inlineCodeContent,\n          });\n        })\n        .join(codeBlock ? '\\\\`\\\\`\\\\`' : '```');\n    }\n    if (!inlineCodeContent) {\n      return text\n        .split(/(?<=^|[^`])`(?=[^`]|$)/g)\n        .map((subString, index, array) => {\n          if (index % 2 && index !== array.length - 1) return subString;\n          return Util.escapeMarkdown(subString, {\n            codeBlock,\n            bold,\n            italic,\n            underline,\n            strikethrough,\n            spoiler,\n          });\n        })\n        .join(inlineCode ? '\\\\`' : '`');\n    }\n    if (inlineCode) text = Util.escapeInlineCode(text);\n    if (codeBlock) text = Util.escapeCodeBlock(text);\n    if (italic) text = Util.escapeItalic(text);\n    if (bold) text = Util.escapeBold(text);\n    if (underline) text = Util.escapeUnderline(text);\n    if (strikethrough) text = Util.escapeStrikethrough(text);\n    if (spoiler) text = Util.escapeSpoiler(text);\n    return text;\n  }\n\n  /**\n   * Escapes code block markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeCodeBlock(text) {\n    return text.replaceAll('```', '\\\\`\\\\`\\\\`');\n  }\n\n  /**\n   * Escapes inline code markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeInlineCode(text) {\n    return text.replace(/(?<=^|[^`])`(?=[^`]|$)/g, '\\\\`');\n  }\n\n  /**\n   * Escapes italic markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeItalic(text) {\n    let i = 0;\n    text = text.replace(/(?<=^|[^*])\\*([^*]|\\*\\*|$)/g, (_, match) => {\n      if (match === '**') return ++i % 2 ? `\\\\*${match}` : `${match}\\\\*`;\n      return `\\\\*${match}`;\n    });\n    i = 0;\n    return text.replace(/(?<=^|[^_])_([^_]|__|$)/g, (_, match) => {\n      if (match === '__') return ++i % 2 ? `\\\\_${match}` : `${match}\\\\_`;\n      return `\\\\_${match}`;\n    });\n  }\n\n  /**\n   * Escapes bold markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeBold(text) {\n    let i = 0;\n    return text.replace(/\\*\\*(\\*)?/g, (_, match) => {\n      if (match) return ++i % 2 ? `${match}\\\\*\\\\*` : `\\\\*\\\\*${match}`;\n      return '\\\\*\\\\*';\n    });\n  }\n\n  /**\n   * Escapes underline markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeUnderline(text) {\n    let i = 0;\n    return text.replace(/__(_)?/g, (_, match) => {\n      if (match) return ++i % 2 ? `${match}\\\\_\\\\_` : `\\\\_\\\\_${match}`;\n      return '\\\\_\\\\_';\n    });\n  }\n\n  /**\n   * Escapes strikethrough markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeStrikethrough(text) {\n    return text.replaceAll('~~', '\\\\~\\\\~');\n  }\n\n  /**\n   * Escapes spoiler markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeSpoiler(text) {\n    return text.replaceAll('||', '\\\\|\\\\|');\n  }\n\n  /**\n   * @typedef {Object} FetchRecommendedShardsOptions\n   * @property {number} [guildsPerShard=1000] Number of guilds assigned per shard\n   * @property {number} [multipleOf=1] The multiple the shard count should round up to. (16 for large bot sharding)\n   */\n\n  /**\n   * Gets the recommended shard count from Discord.\n   * @param {string} token Discord auth token\n   * @param {FetchRecommendedShardsOptions} [options] Options for fetching the recommended shard count\n   * @returns {Promise<number>} The recommended number of shards\n   */\n  static async fetchRecommendedShards(token, { guildsPerShard = 1_000, multipleOf = 1 } = {}) {\n    if (!token) throw new DiscordError('TOKEN_MISSING');\n    const defaults = Options.createDefault();\n    const response = await fetch(`${defaults.http.api}/v${defaults.http.version}${Endpoints.botGateway}`, {\n      method: 'GET',\n      headers: { Authorization: `Bot ${token.replace(/^Bot\\s*/i, '')}` },\n    });\n    if (!response.ok) {\n      if (response.status === 401) throw new DiscordError('TOKEN_INVALID');\n      throw response;\n    }\n    const { shards } = await response.json();\n    return Math.ceil((shards * (1_000 / guildsPerShard)) / multipleOf) * multipleOf;\n  }\n\n  /**\n   * Parses emoji info out of a string. The string must be one of:\n   * * A UTF-8 emoji (no id)\n   * * A URL-encoded UTF-8 emoji (no id)\n   * * A Discord custom emoji (`<:name:id>` or `<a:name:id>`)\n   * @param {string} text Emoji string to parse\n   * @returns {APIEmoji} Object with `animated`, `name`, and `id` properties\n   * @private\n   */\n  static parseEmoji(text) {\n    if (text.includes('%')) text = decodeURIComponent(text);\n    if (!text.includes(':')) return { animated: false, name: text, id: null };\n    const match = text.match(/<?(?:(a):)?(\\w{2,32}):(\\d{17,19})?>?/);\n    return match && { animated: Boolean(match[1]), name: match[2], id: match[3] ?? null };\n  }\n\n  /**\n   * Resolves a partial emoji object from an {@link EmojiIdentifierResolvable}, without checking a Client.\n   * @param {EmojiIdentifierResolvable} emoji Emoji identifier to resolve\n   * @returns {?RawEmoji}\n   * @private\n   */\n  static resolvePartialEmoji(emoji) {\n    if (!emoji) return null;\n    if (typeof emoji === 'string') return /^\\d{17,19}$/.test(emoji) ? { id: emoji } : Util.parseEmoji(emoji);\n    const { id, name, animated } = emoji;\n    if (!id && !name) return null;\n    return { id, name, animated: Boolean(animated) };\n  }\n\n  /**\n   * Shallow-copies an object with its class/prototype intact.\n   * @param {Object} obj Object to clone\n   * @returns {Object}\n   * @private\n   */\n  static cloneObject(obj) {\n    return Object.assign(Object.create(obj), obj);\n  }\n\n  /**\n   * Sets default properties on an object that aren't already specified.\n   * @param {Object} def Default properties\n   * @param {Object} given Object to assign defaults to\n   * @returns {Object}\n   * @private\n   */\n  static mergeDefault(def, given) {\n    if (!given) return def;\n    for (const key in def) {\n      if (!has(given, key) || given[key] === undefined) {\n        given[key] = def[key];\n      } else if (given[key] === Object(given[key])) {\n        given[key] = Util.mergeDefault(def[key], given[key]);\n      }\n    }\n\n    return given;\n  }\n\n  /**\n   * Options used to make an error object.\n   * @typedef {Object} MakeErrorOptions\n   * @property {string} name Error type\n   * @property {string} message Message for the error\n   * @property {string} stack Stack for the error\n   */\n\n  /**\n   * Makes an Error from a plain info object.\n   * @param {MakeErrorOptions} obj Error info\n   * @returns {Error}\n   * @private\n   */\n  static makeError(obj) {\n    const err = new Error(obj.message);\n    err.name = obj.name;\n    err.stack = obj.stack;\n    return err;\n  }\n\n  /**\n   * Makes a plain error info object from an Error.\n   * @param {Error} err Error to get info from\n   * @returns {MakeErrorOptions}\n   * @private\n   */\n  static makePlainError(err) {\n    return {\n      name: err.name,\n      message: err.message,\n      stack: err.stack,\n    };\n  }\n\n  /**\n   * Moves an element in an array *in place*.\n   * @param {Array<*>} array Array to modify\n   * @param {*} element Element to move\n   * @param {number} newIndex Index or offset to move the element to\n   * @param {boolean} [offset=false] Move the element by an offset amount rather than to a set index\n   * @returns {number}\n   * @private\n   */\n  static moveElementInArray(array, element, newIndex, offset = false) {\n    const index = array.indexOf(element);\n    newIndex = (offset ? index : 0) + newIndex;\n    if (newIndex > -1 && newIndex < array.length) {\n      const removedElement = array.splice(index, 1)[0];\n      array.splice(newIndex, 0, removedElement);\n    }\n    return array.indexOf(element);\n  }\n\n  /**\n   * Verifies the provided data is a string, otherwise throws provided error.\n   * @param {string} data The string resolvable to resolve\n   * @param {Function} [error] The Error constructor to instantiate. Defaults to Error\n   * @param {string} [errorMessage] The error message to throw with. Defaults to \"Expected string, got <data> instead.\"\n   * @param {boolean} [allowEmpty=true] Whether an empty string should be allowed\n   * @returns {string}\n   */\n  static verifyString(\n    data,\n    error = Error,\n    errorMessage = `Expected a string, got ${data} instead.`,\n    allowEmpty = true,\n  ) {\n    if (typeof data !== 'string') throw new error(errorMessage);\n    if (!allowEmpty && data.length === 0) throw new error(errorMessage);\n    return data;\n  }\n\n  /**\n   * Can be a number, hex string, an RGB array like:\n   * ```js\n   * [255, 0, 255] // purple\n   * ```\n   * or one of the following strings:\n   * - `DEFAULT`\n   * - `WHITE`\n   * - `AQUA`\n   * - `GREEN`\n   * - `BLUE`\n   * - `YELLOW`\n   * - `PURPLE`\n   * - `LUMINOUS_VIVID_PINK`\n   * - `FUCHSIA`\n   * - `GOLD`\n   * - `ORANGE`\n   * - `RED`\n   * - `GREY`\n   * - `NAVY`\n   * - `DARK_AQUA`\n   * - `DARK_GREEN`\n   * - `DARK_BLUE`\n   * - `DARK_PURPLE`\n   * - `DARK_VIVID_PINK`\n   * - `DARK_GOLD`\n   * - `DARK_ORANGE`\n   * - `DARK_RED`\n   * - `DARK_GREY`\n   * - `DARKER_GREY`\n   * - `LIGHT_GREY`\n   * - `DARK_NAVY`\n   * - `BLURPLE`\n   * - `GREYPLE`\n   * - `DARK_BUT_NOT_BLACK`\n   * - `NOT_QUITE_BLACK`\n   * - `RANDOM`\n   * @typedef {string|number|number[]} ColorResolvable\n   */\n\n  /**\n   * Resolves a ColorResolvable into a color number.\n   * @param {ColorResolvable} color Color to resolve\n   * @returns {number} A color\n   */\n  static resolveColor(color) {\n    if (typeof color === 'string') {\n      if (color === 'RANDOM') return Math.floor(Math.random() * (0xffffff + 1));\n      if (color === 'DEFAULT') return 0;\n      color = Colors[color] ?? parseInt(color.replace('#', ''), 16);\n    } else if (Array.isArray(color)) {\n      color = (color[0] << 16) + (color[1] << 8) + color[2];\n    }\n\n    if (color < 0 || color > 0xffffff) throw new RangeError('COLOR_RANGE');\n    else if (Number.isNaN(color)) throw new TypeError('COLOR_CONVERT');\n\n    return color;\n  }\n\n  /**\n   * Sorts by Discord's position and id.\n   * @param {Collection} collection Collection of objects to sort\n   * @returns {Collection}\n   */\n  static discordSort(collection) {\n    const isGuildChannel = collection.first() instanceof GuildChannel;\n    return collection.sorted(\n      isGuildChannel\n        ? (a, b) => a.rawPosition - b.rawPosition || Number(BigInt(a.id) - BigInt(b.id))\n        : (a, b) => a.rawPosition - b.rawPosition || Number(BigInt(b.id) - BigInt(a.id)),\n    );\n  }\n\n  /**\n   * Sets the position of a Channel or Role.\n   * @param {Channel|Role} item Object to set the position of\n   * @param {number} position New position for the object\n   * @param {boolean} relative Whether `position` is relative to its current position\n   * @param {Collection<string, Channel|Role>} sorted A collection of the objects sorted properly\n   * @param {APIRouter} route Route to call PATCH on\n   * @param {string} [reason] Reason for the change\n   * @returns {Promise<Channel[]|Role[]>} Updated item list, with `id` and `position` properties\n   * @private\n   */\n  static async setPosition(item, position, relative, sorted, route, reason) {\n    let updatedItems = [...sorted.values()];\n    Util.moveElementInArray(updatedItems, item, position, relative);\n    updatedItems = updatedItems.map((r, i) => ({ id: r.id, position: i }));\n    await route.patch({ data: updatedItems, reason });\n    return updatedItems;\n  }\n\n  /**\n   * Alternative to Node's `path.basename`, removing query string after the extension if it exists.\n   * @param {string} path Path to get the basename of\n   * @param {string} [ext] File extension to remove\n   * @returns {string} Basename of the path\n   * @private\n   */\n  static basename(path, ext) {\n    const res = parse(path);\n    return ext && res.ext.startsWith(ext) ? res.name : res.base.split('?')[0];\n  }\n\n  /**\n   * Breaks user, role and everyone/here mentions by adding a zero width space after every @ character\n   * @param {string} str The string to sanitize\n   * @returns {string}\n   * @deprecated Use {@link BaseMessageOptions#allowedMentions} instead.\n   */\n  static removeMentions(str) {\n    if (!deprecationEmittedForRemoveMentions) {\n      process.emitWarning(\n        'The Util.removeMentions method is deprecated. Use MessageOptions#allowedMentions instead.',\n        'DeprecationWarning',\n      );\n\n      deprecationEmittedForRemoveMentions = true;\n    }\n\n    return Util._removeMentions(str);\n  }\n\n  static _removeMentions(str) {\n    return str.replaceAll('@', '@\\u200b');\n  }\n\n  /**\n   * The content to have all mentions replaced by the equivalent text.\n   * <warn>When {@link Util.removeMentions} is removed, this method will no longer sanitize mentions.\n   * Use {@link BaseMessageOptions#allowedMentions} instead to prevent mentions when sending a message.</warn>\n   * @param {string} str The string to be converted\n   * @param {TextBasedChannels} channel The channel the string was sent in\n   * @returns {string}\n   */\n  static cleanContent(str, channel) {\n    str = str\n      .replace(/<@!?[0-9]+>/g, input => {\n        const id = input.replace(/<|!|>|@/g, '');\n        if (channel.type === 'DM') {\n          const user = channel.client.users.cache.get(id);\n          return user ? Util._removeMentions(`@${user.username}`) : input;\n        }\n\n        const member = channel.guild.members.cache.get(id);\n        if (member) {\n          return Util._removeMentions(`@${member.displayName}`);\n        } else {\n          const user = channel.client.users.cache.get(id);\n          return user ? Util._removeMentions(`@${user.username}`) : input;\n        }\n      })\n      .replace(/<#[0-9]+>/g, input => {\n        const mentionedChannel = channel.client.channels.cache.get(input.replace(/<|#|>/g, ''));\n        return mentionedChannel ? `#${mentionedChannel.name}` : input;\n      })\n      .replace(/<@&[0-9]+>/g, input => {\n        if (channel.type === 'DM') return input;\n        const role = channel.guild.roles.cache.get(input.replace(/<|@|>|&/g, ''));\n        return role ? `@${role.name}` : input;\n      });\n    return str;\n  }\n\n  /**\n   * The content to put in a code block with all code block fences replaced by the equivalent backticks.\n   * @param {string} text The string to be converted\n   * @returns {string}\n   */\n  static cleanCodeBlockContent(text) {\n    return text.replaceAll('```', '`\\u200b``');\n  }\n\n  /**\n   * Creates a sweep filter that sweeps archived threads\n   * @param {number} [lifetime=14400] How long a thread has to be archived to be valid for sweeping\n   * @deprecated When not using with `makeCache` use `Sweepers.archivedThreadSweepFilter` instead\n   * @returns {SweepFilter}\n   */\n  static archivedThreadSweepFilter(lifetime = 14400) {\n    const filter = require('./Sweepers').archivedThreadSweepFilter(lifetime);\n    filter.isDefault = true;\n    return filter;\n  }\n}\n\nmodule.exports = Util;\n\n// Fixes Circular\nconst GuildChannel = require('../structures/GuildChannel');\n"],"mappings":"AAAA;;AAEA,MAAM;EAAEA;AAAF,IAAYC,OAAO,CAAC,WAAD,CAAzB;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,cAAD,CAAvB;;AACA,MAAM;EAAEE;AAAF,IAAiBF,OAAO,CAAC,uBAAD,CAA9B;;AACA,MAAMG,KAAK,GAAGH,OAAO,CAAC,YAAD,CAArB;;AACA,MAAM;EAAEI,MAAF;EAAUC;AAAV,IAAwBL,OAAO,CAAC,aAAD,CAArC;;AACA,MAAMM,OAAO,GAAGN,OAAO,CAAC,WAAD,CAAvB;;AACA,MAAM;EAAEO,KAAK,EAAEC,YAAT;EAAuBC,UAAvB;EAAmCC;AAAnC,IAAiDV,OAAO,CAAC,WAAD,CAA9D;;AACA,MAAMW,GAAG,GAAG,CAACC,CAAD,EAAIC,CAAJ,KAAUC,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCL,CAArC,EAAwCC,CAAxC,CAAtB;;AACA,MAAMK,QAAQ,GAAGC,CAAC,IAAI,OAAOA,CAAP,KAAa,QAAb,IAAyBA,CAAC,KAAK,IAArD;;AAEA,IAAIC,mCAAmC,GAAG,KAA1C;AAEA;AACA;AACA;;AACA,MAAMC,IAAN,SAAmB,IAAnB,CAAwB;EACtB;AACF;AACA;AACA;AACA;AACA;EACgB,OAAPC,OAAO,CAACC,GAAD,EAAgB;IAAA,kCAAPC,KAAO;MAAPA,KAAO;IAAA;;IAC5B,IAAI,CAACN,QAAQ,CAACK,GAAD,CAAb,EAAoB,OAAOA,GAAP;IAEpB,MAAME,QAAQ,GAAGX,MAAM,CAACY,IAAP,CAAYH,GAAZ,EACdI,MADc,CACPd,CAAC,IAAI,CAACA,CAAC,CAACe,UAAF,CAAa,GAAb,CADC,EAEdC,GAFc,CAEVhB,CAAC,KAAK;MAAE,CAACA,CAAD,GAAK;IAAP,CAAL,CAFS,CAAjB;IAIAW,KAAK,GAAGC,QAAQ,CAACK,MAAT,GAAkBhB,MAAM,CAACiB,MAAP,CAAc,GAAGN,QAAjB,EAA2B,GAAGD,KAA9B,CAAlB,GAAyDV,MAAM,CAACiB,MAAP,CAAc,EAAd,EAAkB,GAAGP,KAArB,CAAjE;IAEA,MAAMQ,GAAG,GAAG,EAAZ;;IAEA,KAAK,IAAI,CAACC,IAAD,EAAOC,OAAP,CAAT,IAA4BpB,MAAM,CAACqB,OAAP,CAAeX,KAAf,CAA5B,EAAmD;MACjD,IAAI,CAACU,OAAL,EAAc;MACdA,OAAO,GAAGA,OAAO,KAAK,IAAZ,GAAmBD,IAAnB,GAA0BC,OAApC;MAEA,MAAME,OAAO,GAAGb,GAAG,CAACU,IAAD,CAAnB;MACA,MAAMI,SAAS,GAAGnB,QAAQ,CAACkB,OAAD,CAA1B;MACA,MAAME,OAAO,GAAGD,SAAS,IAAI,OAAOD,OAAO,CAACE,OAAf,KAA2B,UAAxC,GAAqDF,OAAO,CAACE,OAAR,EAArD,GAAyE,IAAzF,CANiD,CAQjD;;MACA,IAAIF,OAAO,YAAYlC,UAAvB,EAAmC8B,GAAG,CAACE,OAAD,CAAH,GAAeK,KAAK,CAACC,IAAN,CAAWJ,OAAO,CAACV,IAAR,EAAX,CAAf,CAAnC,CACA;MADA,KAEK,IAAIY,OAAO,YAAYpC,UAAvB,EAAmC8B,GAAG,CAACE,OAAD,CAAH,GAAeK,KAAK,CAACC,IAAN,CAAWF,OAAO,CAACZ,IAAR,EAAX,CAAf,CAAnC,CACL;MADK,KAEA,IAAIa,KAAK,CAACE,OAAN,CAAcL,OAAd,CAAJ,EAA4BJ,GAAG,CAACE,OAAD,CAAH,GAAeE,OAAO,CAACP,GAAR,CAAYa,CAAC,IAAIrB,IAAI,CAACC,OAAL,CAAaoB,CAAb,CAAjB,CAAf,CAA5B,CACL;MADK,KAEA,IAAI,OAAOJ,OAAP,KAAmB,QAAvB,EAAiCN,GAAG,CAACE,OAAD,CAAH,GAAeI,OAAf,CAAjC,CACL;MADK,KAEA,IAAI,CAACD,SAAL,EAAgBL,GAAG,CAACE,OAAD,CAAH,GAAeE,OAAf;IACtB;;IAED,OAAOJ,GAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;;;EACqB,OAAZW,YAAY,CAACC,IAAD,EAA2E;IAAA,IAApE;MAAEC,SAAS,GAAG,KAAd;MAAqBC,IAAI,GAAG,IAA5B;MAAkCC,OAAO,GAAG,EAA5C;MAAgDC,MAAM,GAAG;IAAzD,CAAoE,uEAAJ,EAAI;IAC5FJ,IAAI,GAAGvB,IAAI,CAAC4B,YAAL,CAAkBL,IAAlB,CAAP;IACA,IAAIA,IAAI,CAACd,MAAL,IAAee,SAAnB,EAA8B,OAAO,CAACD,IAAD,CAAP;IAC9B,IAAIM,SAAS,GAAG,CAACN,IAAD,CAAhB;;IACA,IAAIL,KAAK,CAACE,OAAN,CAAcK,IAAd,CAAJ,EAAyB;MACvB,OAAOA,IAAI,CAAChB,MAAL,GAAc,CAAd,IAAmBoB,SAAS,CAACC,IAAV,CAAeC,IAAI,IAAIA,IAAI,CAACtB,MAAL,GAAce,SAArC,CAA1B,EAA2E;QACzE,MAAMQ,WAAW,GAAGP,IAAI,CAACQ,KAAL,EAApB;;QACA,IAAID,WAAW,YAAYE,MAA3B,EAAmC;UACjCL,SAAS,GAAGA,SAAS,CAACM,OAAV,CAAkBC,KAAK,IAAIA,KAAK,CAACC,KAAN,CAAYL,WAAZ,CAA3B,CAAZ;QACD,CAFD,MAEO;UACLH,SAAS,GAAGA,SAAS,CAACM,OAAV,CAAkBC,KAAK,IAAIA,KAAK,CAACE,KAAN,CAAYN,WAAZ,CAA3B,CAAZ;QACD;MACF;IACF,CATD,MASO;MACLH,SAAS,GAAGN,IAAI,CAACe,KAAL,CAAWb,IAAX,CAAZ;IACD;;IACD,IAAII,SAAS,CAACC,IAAV,CAAeC,IAAI,IAAIA,IAAI,CAACtB,MAAL,GAAce,SAArC,CAAJ,EAAqD,MAAM,IAAIpC,UAAJ,CAAe,eAAf,CAAN;IACrD,MAAMmD,QAAQ,GAAG,EAAjB;IACA,IAAIC,GAAG,GAAG,EAAV;;IACA,KAAK,MAAMJ,KAAX,IAAoBP,SAApB,EAA+B;MAC7B,IAAIW,GAAG,IAAI,CAACA,GAAG,GAAGf,IAAN,GAAaW,KAAb,GAAqBT,MAAtB,EAA8BlB,MAA9B,GAAuCe,SAAlD,EAA6D;QAC3De,QAAQ,CAACE,IAAT,CAAcD,GAAG,GAAGb,MAApB;QACAa,GAAG,GAAGd,OAAN;MACD;;MACDc,GAAG,IAAI,CAACA,GAAG,IAAIA,GAAG,KAAKd,OAAf,GAAyBD,IAAzB,GAAgC,EAAjC,IAAuCW,KAA9C;IACD;;IACD,OAAOG,QAAQ,CAACG,MAAT,CAAgBF,GAAhB,EAAqBlC,MAArB,CAA4BqC,CAAC,IAAIA,CAAjC,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;;;EACuB,OAAdC,cAAc,CACnBrB,IADmB,EAanB;IAAA,IAXA;MACEsB,SAAS,GAAG,IADd;MAEEC,UAAU,GAAG,IAFf;MAGEC,IAAI,GAAG,IAHT;MAIEC,MAAM,GAAG,IAJX;MAKEC,SAAS,GAAG,IALd;MAMEC,aAAa,GAAG,IANlB;MAOEC,OAAO,GAAG,IAPZ;MAQEC,gBAAgB,GAAG,IARrB;MASEC,iBAAiB,GAAG;IATtB,CAWA,uEADI,EACJ;;IACA,IAAI,CAACD,gBAAL,EAAuB;MACrB,OAAO7B,IAAI,CACRe,KADI,CACE,KADF,EAEJ9B,GAFI,CAEA,CAAC8C,SAAD,EAAYC,KAAZ,EAAmBC,KAAnB,KAA6B;QAChC,IAAID,KAAK,GAAG,CAAR,IAAaA,KAAK,KAAKC,KAAK,CAAC/C,MAAN,GAAe,CAA1C,EAA6C,OAAO6C,SAAP;QAC7C,OAAOtD,IAAI,CAAC4C,cAAL,CAAoBU,SAApB,EAA+B;UACpCR,UADoC;UAEpCC,IAFoC;UAGpCC,MAHoC;UAIpCC,SAJoC;UAKpCC,aALoC;UAMpCC,OANoC;UAOpCE;QAPoC,CAA/B,CAAP;MASD,CAbI,EAcJI,IAdI,CAcCZ,SAAS,GAAG,WAAH,GAAiB,KAd3B,CAAP;IAeD;;IACD,IAAI,CAACQ,iBAAL,EAAwB;MACtB,OAAO9B,IAAI,CACRe,KADI,CACE,yBADF,EAEJ9B,GAFI,CAEA,CAAC8C,SAAD,EAAYC,KAAZ,EAAmBC,KAAnB,KAA6B;QAChC,IAAID,KAAK,GAAG,CAAR,IAAaA,KAAK,KAAKC,KAAK,CAAC/C,MAAN,GAAe,CAA1C,EAA6C,OAAO6C,SAAP;QAC7C,OAAOtD,IAAI,CAAC4C,cAAL,CAAoBU,SAApB,EAA+B;UACpCT,SADoC;UAEpCE,IAFoC;UAGpCC,MAHoC;UAIpCC,SAJoC;UAKpCC,aALoC;UAMpCC;QANoC,CAA/B,CAAP;MAQD,CAZI,EAaJM,IAbI,CAaCX,UAAU,GAAG,KAAH,GAAW,GAbtB,CAAP;IAcD;;IACD,IAAIA,UAAJ,EAAgBvB,IAAI,GAAGvB,IAAI,CAAC0D,gBAAL,CAAsBnC,IAAtB,CAAP;IAChB,IAAIsB,SAAJ,EAAetB,IAAI,GAAGvB,IAAI,CAAC2D,eAAL,CAAqBpC,IAArB,CAAP;IACf,IAAIyB,MAAJ,EAAYzB,IAAI,GAAGvB,IAAI,CAAC4D,YAAL,CAAkBrC,IAAlB,CAAP;IACZ,IAAIwB,IAAJ,EAAUxB,IAAI,GAAGvB,IAAI,CAAC6D,UAAL,CAAgBtC,IAAhB,CAAP;IACV,IAAI0B,SAAJ,EAAe1B,IAAI,GAAGvB,IAAI,CAAC8D,eAAL,CAAqBvC,IAArB,CAAP;IACf,IAAI2B,aAAJ,EAAmB3B,IAAI,GAAGvB,IAAI,CAAC+D,mBAAL,CAAyBxC,IAAzB,CAAP;IACnB,IAAI4B,OAAJ,EAAa5B,IAAI,GAAGvB,IAAI,CAACgE,aAAL,CAAmBzC,IAAnB,CAAP;IACb,OAAOA,IAAP;EACD;EAED;AACF;AACA;AACA;AACA;;;EACwB,OAAfoC,eAAe,CAACpC,IAAD,EAAO;IAC3B,OAAOA,IAAI,CAAC0C,UAAL,CAAgB,KAAhB,EAAuB,WAAvB,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;;;EACyB,OAAhBP,gBAAgB,CAACnC,IAAD,EAAO;IAC5B,OAAOA,IAAI,CAAC2C,OAAL,CAAa,yBAAb,EAAwC,KAAxC,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;;;EACqB,OAAZN,YAAY,CAACrC,IAAD,EAAO;IACxB,IAAI4C,CAAC,GAAG,CAAR;IACA5C,IAAI,GAAGA,IAAI,CAAC2C,OAAL,CAAa,6BAAb,EAA4C,CAACE,CAAD,EAAI/B,KAAJ,KAAc;MAC/D,IAAIA,KAAK,KAAK,IAAd,EAAoB,OAAO,EAAE8B,CAAF,GAAM,CAAN,GAAW,MAAK9B,KAAM,EAAtB,GAA2B,GAAEA,KAAM,KAA1C;MACpB,OAAQ,MAAKA,KAAM,EAAnB;IACD,CAHM,CAAP;IAIA8B,CAAC,GAAG,CAAJ;IACA,OAAO5C,IAAI,CAAC2C,OAAL,CAAa,0BAAb,EAAyC,CAACE,CAAD,EAAI/B,KAAJ,KAAc;MAC5D,IAAIA,KAAK,KAAK,IAAd,EAAoB,OAAO,EAAE8B,CAAF,GAAM,CAAN,GAAW,MAAK9B,KAAM,EAAtB,GAA2B,GAAEA,KAAM,KAA1C;MACpB,OAAQ,MAAKA,KAAM,EAAnB;IACD,CAHM,CAAP;EAID;EAED;AACF;AACA;AACA;AACA;;;EACmB,OAAVwB,UAAU,CAACtC,IAAD,EAAO;IACtB,IAAI4C,CAAC,GAAG,CAAR;IACA,OAAO5C,IAAI,CAAC2C,OAAL,CAAa,YAAb,EAA2B,CAACE,CAAD,EAAI/B,KAAJ,KAAc;MAC9C,IAAIA,KAAJ,EAAW,OAAO,EAAE8B,CAAF,GAAM,CAAN,GAAW,GAAE9B,KAAM,QAAnB,GAA8B,SAAQA,KAAM,EAAnD;MACX,OAAO,QAAP;IACD,CAHM,CAAP;EAID;EAED;AACF;AACA;AACA;AACA;;;EACwB,OAAfyB,eAAe,CAACvC,IAAD,EAAO;IAC3B,IAAI4C,CAAC,GAAG,CAAR;IACA,OAAO5C,IAAI,CAAC2C,OAAL,CAAa,SAAb,EAAwB,CAACE,CAAD,EAAI/B,KAAJ,KAAc;MAC3C,IAAIA,KAAJ,EAAW,OAAO,EAAE8B,CAAF,GAAM,CAAN,GAAW,GAAE9B,KAAM,QAAnB,GAA8B,SAAQA,KAAM,EAAnD;MACX,OAAO,QAAP;IACD,CAHM,CAAP;EAID;EAED;AACF;AACA;AACA;AACA;;;EAC4B,OAAnB0B,mBAAmB,CAACxC,IAAD,EAAO;IAC/B,OAAOA,IAAI,CAAC0C,UAAL,CAAgB,IAAhB,EAAsB,QAAtB,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;;;EACsB,OAAbD,aAAa,CAACzC,IAAD,EAAO;IACzB,OAAOA,IAAI,CAAC0C,UAAL,CAAgB,IAAhB,EAAsB,QAAtB,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;;;EACqC,aAAtBI,sBAAsB,CAACC,KAAD,EAAyD;IAAA,IAAjD;MAAEC,cAAc,GAAG,KAAnB;MAA0BC,UAAU,GAAG;IAAvC,CAAiD,uEAAJ,EAAI;IAC1F,IAAI,CAACF,KAAL,EAAY,MAAM,IAAInF,YAAJ,CAAiB,eAAjB,CAAN;IACZ,MAAMsF,QAAQ,GAAGxF,OAAO,CAACyF,aAAR,EAAjB;IACA,MAAMC,QAAQ,GAAG,MAAM7F,KAAK,CAAE,GAAE2F,QAAQ,CAACG,IAAT,CAAcC,GAAI,KAAIJ,QAAQ,CAACG,IAAT,CAAcE,OAAQ,GAAE9F,SAAS,CAAC+F,UAAW,EAAvE,EAA0E;MACpGC,MAAM,EAAE,KAD4F;MAEpGC,OAAO,EAAE;QAAEC,aAAa,EAAG,OAAMZ,KAAK,CAACJ,OAAN,CAAc,UAAd,EAA0B,EAA1B,CAA8B;MAAtD;IAF2F,CAA1E,CAA5B;;IAIA,IAAI,CAACS,QAAQ,CAACQ,EAAd,EAAkB;MAChB,IAAIR,QAAQ,CAACS,MAAT,KAAoB,GAAxB,EAA6B,MAAM,IAAIjG,YAAJ,CAAiB,eAAjB,CAAN;MAC7B,MAAMwF,QAAN;IACD;;IACD,MAAM;MAAEU;IAAF,IAAa,MAAMV,QAAQ,CAACW,IAAT,EAAzB;IACA,OAAOC,IAAI,CAACC,IAAL,CAAWH,MAAM,IAAI,QAAQd,cAAZ,CAAP,GAAsCC,UAAhD,IAA8DA,UAArE;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACmB,OAAViB,UAAU,CAAClE,IAAD,EAAO;IACtB,IAAIA,IAAI,CAACmE,QAAL,CAAc,GAAd,CAAJ,EAAwBnE,IAAI,GAAGoE,kBAAkB,CAACpE,IAAD,CAAzB;IACxB,IAAI,CAACA,IAAI,CAACmE,QAAL,CAAc,GAAd,CAAL,EAAyB,OAAO;MAAEE,QAAQ,EAAE,KAAZ;MAAmBC,IAAI,EAAEtE,IAAzB;MAA+BuE,EAAE,EAAE;IAAnC,CAAP;IACzB,MAAMzD,KAAK,GAAGd,IAAI,CAACc,KAAL,CAAW,sCAAX,CAAd;IACA,OAAOA,KAAK,IAAI;MAAEuD,QAAQ,EAAEG,OAAO,CAAC1D,KAAK,CAAC,CAAD,CAAN,CAAnB;MAA+BwD,IAAI,EAAExD,KAAK,CAAC,CAAD,CAA1C;MAA+CyD,EAAE,EAAEzD,KAAK,CAAC,CAAD,CAAL,IAAY;IAA/D,CAAhB;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EAC4B,OAAnB2D,mBAAmB,CAACC,KAAD,EAAQ;IAChC,IAAI,CAACA,KAAL,EAAY,OAAO,IAAP;IACZ,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B,OAAO,cAAcC,IAAd,CAAmBD,KAAnB,IAA4B;MAAEH,EAAE,EAAEG;IAAN,CAA5B,GAA4CjG,IAAI,CAACyF,UAAL,CAAgBQ,KAAhB,CAAnD;IAC/B,MAAM;MAAEH,EAAF;MAAMD,IAAN;MAAYD;IAAZ,IAAyBK,KAA/B;IACA,IAAI,CAACH,EAAD,IAAO,CAACD,IAAZ,EAAkB,OAAO,IAAP;IAClB,OAAO;MAAEC,EAAF;MAAMD,IAAN;MAAYD,QAAQ,EAAEG,OAAO,CAACH,QAAD;IAA7B,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACoB,OAAXO,WAAW,CAACjG,GAAD,EAAM;IACtB,OAAOT,MAAM,CAACiB,MAAP,CAAcjB,MAAM,CAAC2G,MAAP,CAAclG,GAAd,CAAd,EAAkCA,GAAlC,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;EACqB,OAAZmG,YAAY,CAACC,GAAD,EAAMC,KAAN,EAAa;IAC9B,IAAI,CAACA,KAAL,EAAY,OAAOD,GAAP;;IACZ,KAAK,MAAME,GAAX,IAAkBF,GAAlB,EAAuB;MACrB,IAAI,CAAChH,GAAG,CAACiH,KAAD,EAAQC,GAAR,CAAJ,IAAoBD,KAAK,CAACC,GAAD,CAAL,KAAeC,SAAvC,EAAkD;QAChDF,KAAK,CAACC,GAAD,CAAL,GAAaF,GAAG,CAACE,GAAD,CAAhB;MACD,CAFD,MAEO,IAAID,KAAK,CAACC,GAAD,CAAL,KAAe/G,MAAM,CAAC8G,KAAK,CAACC,GAAD,CAAN,CAAzB,EAAuC;QAC5CD,KAAK,CAACC,GAAD,CAAL,GAAaxG,IAAI,CAACqG,YAAL,CAAkBC,GAAG,CAACE,GAAD,CAArB,EAA4BD,KAAK,CAACC,GAAD,CAAjC,CAAb;MACD;IACF;;IAED,OAAOD,KAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;;;EACkB,OAATG,SAAS,CAACxG,GAAD,EAAM;IACpB,MAAMyG,GAAG,GAAG,IAAIzH,KAAJ,CAAUgB,GAAG,CAAC0G,OAAd,CAAZ;IACAD,GAAG,CAACd,IAAJ,GAAW3F,GAAG,CAAC2F,IAAf;IACAc,GAAG,CAACE,KAAJ,GAAY3G,GAAG,CAAC2G,KAAhB;IACA,OAAOF,GAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACuB,OAAdG,cAAc,CAACH,GAAD,EAAM;IACzB,OAAO;MACLd,IAAI,EAAEc,GAAG,CAACd,IADL;MAELe,OAAO,EAAED,GAAG,CAACC,OAFR;MAGLC,KAAK,EAAEF,GAAG,CAACE;IAHN,CAAP;EAKD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAC2B,OAAlBE,kBAAkB,CAACvD,KAAD,EAAQzC,OAAR,EAAiBiG,QAAjB,EAA2C;IAAA,IAAhBC,MAAgB,uEAAP,KAAO;IAClE,MAAM1D,KAAK,GAAGC,KAAK,CAAC0D,OAAN,CAAcnG,OAAd,CAAd;IACAiG,QAAQ,GAAG,CAACC,MAAM,GAAG1D,KAAH,GAAW,CAAlB,IAAuByD,QAAlC;;IACA,IAAIA,QAAQ,GAAG,CAAC,CAAZ,IAAiBA,QAAQ,GAAGxD,KAAK,CAAC/C,MAAtC,EAA8C;MAC5C,MAAM0G,cAAc,GAAG3D,KAAK,CAAC4D,MAAN,CAAa7D,KAAb,EAAoB,CAApB,EAAuB,CAAvB,CAAvB;MACAC,KAAK,CAAC4D,MAAN,CAAaJ,QAAb,EAAuB,CAAvB,EAA0BG,cAA1B;IACD;;IACD,OAAO3D,KAAK,CAAC0D,OAAN,CAAcnG,OAAd,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;EACqB,OAAZa,YAAY,CACjByF,IADiB,EAKjB;IAAA,IAHAC,KAGA,uEAHQpI,KAGR;IAAA,IAFAqI,YAEA,uEAFgB,0BAAyBF,IAAK,WAE9C;IAAA,IADAG,UACA,uEADa,IACb;IACA,IAAI,OAAOH,IAAP,KAAgB,QAApB,EAA8B,MAAM,IAAIC,KAAJ,CAAUC,YAAV,CAAN;IAC9B,IAAI,CAACC,UAAD,IAAeH,IAAI,CAAC5G,MAAL,KAAgB,CAAnC,EAAsC,MAAM,IAAI6G,KAAJ,CAAUC,YAAV,CAAN;IACtC,OAAOF,IAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;;;EACqB,OAAZI,YAAY,CAACC,KAAD,EAAQ;IACzB,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;MAC7B,IAAIA,KAAK,KAAK,QAAd,EAAwB,OAAOnC,IAAI,CAACoC,KAAL,CAAWpC,IAAI,CAACqC,MAAL,MAAiB,WAAW,CAA5B,CAAX,CAAP;MACxB,IAAIF,KAAK,KAAK,SAAd,EAAyB,OAAO,CAAP;MACzBA,KAAK,GAAG3I,MAAM,CAAC2I,KAAD,CAAN,IAAiBG,QAAQ,CAACH,KAAK,CAACxD,OAAN,CAAc,GAAd,EAAmB,EAAnB,CAAD,EAAyB,EAAzB,CAAjC;IACD,CAJD,MAIO,IAAIhD,KAAK,CAACE,OAAN,CAAcsG,KAAd,CAAJ,EAA0B;MAC/BA,KAAK,GAAG,CAACA,KAAK,CAAC,CAAD,CAAL,IAAY,EAAb,KAAoBA,KAAK,CAAC,CAAD,CAAL,IAAY,CAAhC,IAAqCA,KAAK,CAAC,CAAD,CAAlD;IACD;;IAED,IAAIA,KAAK,GAAG,CAAR,IAAaA,KAAK,GAAG,QAAzB,EAAmC,MAAM,IAAItI,UAAJ,CAAe,aAAf,CAAN,CAAnC,KACK,IAAI0I,MAAM,CAACC,KAAP,CAAaL,KAAb,CAAJ,EAAyB,MAAM,IAAIrI,SAAJ,CAAc,eAAd,CAAN;IAE9B,OAAOqI,KAAP;EACD;EAED;AACF;AACA;AACA;AACA;;;EACoB,OAAXM,WAAW,CAACC,UAAD,EAAa;IAC7B,MAAMC,cAAc,GAAGD,UAAU,CAACE,KAAX,cAA8BC,YAArD;IACA,OAAOH,UAAU,CAACI,MAAX,CACLH,cAAc,GACV,CAACI,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACE,WAAF,GAAgBD,CAAC,CAACC,WAAlB,IAAiCV,MAAM,CAACW,MAAM,CAACH,CAAC,CAACxC,EAAH,CAAN,GAAe2C,MAAM,CAACF,CAAC,CAACzC,EAAH,CAAtB,CADvC,GAEV,CAACwC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACE,WAAF,GAAgBD,CAAC,CAACC,WAAlB,IAAiCV,MAAM,CAACW,MAAM,CAACF,CAAC,CAACzC,EAAH,CAAN,GAAe2C,MAAM,CAACH,CAAC,CAACxC,EAAH,CAAtB,CAHhD,CAAP;EAKD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAC0B,aAAX4C,WAAW,CAACC,IAAD,EAAOC,QAAP,EAAiBC,QAAjB,EAA2BR,MAA3B,EAAmCS,KAAnC,EAA0CC,MAA1C,EAAkD;IACxE,IAAIC,YAAY,GAAG,CAAC,GAAGX,MAAM,CAACY,MAAP,EAAJ,CAAnB;IACAjJ,IAAI,CAAC+G,kBAAL,CAAwBiC,YAAxB,EAAsCL,IAAtC,EAA4CC,QAA5C,EAAsDC,QAAtD;IACAG,YAAY,GAAGA,YAAY,CAACxI,GAAb,CAAiB,CAAC0I,CAAD,EAAI/E,CAAJ,MAAW;MAAE2B,EAAE,EAAEoD,CAAC,CAACpD,EAAR;MAAY8C,QAAQ,EAAEzE;IAAtB,CAAX,CAAjB,CAAf;IACA,MAAM2E,KAAK,CAACK,KAAN,CAAY;MAAE9B,IAAI,EAAE2B,YAAR;MAAsBD;IAAtB,CAAZ,CAAN;IACA,OAAOC,YAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;EACiB,OAARI,QAAQ,CAACC,IAAD,EAAOC,GAAP,EAAY;IACzB,MAAMC,GAAG,GAAG7K,KAAK,CAAC2K,IAAD,CAAjB;IACA,OAAOC,GAAG,IAAIC,GAAG,CAACD,GAAJ,CAAQ/I,UAAR,CAAmB+I,GAAnB,CAAP,GAAiCC,GAAG,CAAC1D,IAArC,GAA4C0D,GAAG,CAACC,IAAJ,CAASlH,KAAT,CAAe,GAAf,EAAoB,CAApB,CAAnD;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACuB,OAAdmH,cAAc,CAACC,GAAD,EAAM;IACzB,IAAI,CAAC3J,mCAAL,EAA0C;MACxCnB,OAAO,CAAC+K,WAAR,CACE,2FADF,EAEE,oBAFF;MAKA5J,mCAAmC,GAAG,IAAtC;IACD;;IAED,OAAOC,IAAI,CAAC4J,eAAL,CAAqBF,GAArB,CAAP;EACD;;EAEqB,OAAfE,eAAe,CAACF,GAAD,EAAM;IAC1B,OAAOA,GAAG,CAACzF,UAAJ,CAAe,GAAf,EAAoB,SAApB,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;EACqB,OAAZ4F,YAAY,CAACH,GAAD,EAAMI,OAAN,EAAe;IAChCJ,GAAG,GAAGA,GAAG,CACNxF,OADG,CACK,cADL,EACqB6F,KAAK,IAAI;MAChC,MAAMjE,EAAE,GAAGiE,KAAK,CAAC7F,OAAN,CAAc,UAAd,EAA0B,EAA1B,CAAX;;MACA,IAAI4F,OAAO,CAACE,IAAR,KAAiB,IAArB,EAA2B;QACzB,MAAMC,IAAI,GAAGH,OAAO,CAACI,MAAR,CAAeC,KAAf,CAAqBC,KAArB,CAA2BC,GAA3B,CAA+BvE,EAA/B,CAAb;QACA,OAAOmE,IAAI,GAAGjK,IAAI,CAAC4J,eAAL,CAAsB,IAAGK,IAAI,CAACK,QAAS,EAAvC,CAAH,GAA+CP,KAA1D;MACD;;MAED,MAAMQ,MAAM,GAAGT,OAAO,CAACU,KAAR,CAAcC,OAAd,CAAsBL,KAAtB,CAA4BC,GAA5B,CAAgCvE,EAAhC,CAAf;;MACA,IAAIyE,MAAJ,EAAY;QACV,OAAOvK,IAAI,CAAC4J,eAAL,CAAsB,IAAGW,MAAM,CAACG,WAAY,EAA5C,CAAP;MACD,CAFD,MAEO;QACL,MAAMT,IAAI,GAAGH,OAAO,CAACI,MAAR,CAAeC,KAAf,CAAqBC,KAArB,CAA2BC,GAA3B,CAA+BvE,EAA/B,CAAb;QACA,OAAOmE,IAAI,GAAGjK,IAAI,CAAC4J,eAAL,CAAsB,IAAGK,IAAI,CAACK,QAAS,EAAvC,CAAH,GAA+CP,KAA1D;MACD;IACF,CAfG,EAgBH7F,OAhBG,CAgBK,YAhBL,EAgBmB6F,KAAK,IAAI;MAC9B,MAAMY,gBAAgB,GAAGb,OAAO,CAACI,MAAR,CAAeU,QAAf,CAAwBR,KAAxB,CAA8BC,GAA9B,CAAkCN,KAAK,CAAC7F,OAAN,CAAc,QAAd,EAAwB,EAAxB,CAAlC,CAAzB;MACA,OAAOyG,gBAAgB,GAAI,IAAGA,gBAAgB,CAAC9E,IAAK,EAA7B,GAAiCkE,KAAxD;IACD,CAnBG,EAoBH7F,OApBG,CAoBK,aApBL,EAoBoB6F,KAAK,IAAI;MAC/B,IAAID,OAAO,CAACE,IAAR,KAAiB,IAArB,EAA2B,OAAOD,KAAP;MAC3B,MAAMc,IAAI,GAAGf,OAAO,CAACU,KAAR,CAAcM,KAAd,CAAoBV,KAApB,CAA0BC,GAA1B,CAA8BN,KAAK,CAAC7F,OAAN,CAAc,UAAd,EAA0B,EAA1B,CAA9B,CAAb;MACA,OAAO2G,IAAI,GAAI,IAAGA,IAAI,CAAChF,IAAK,EAAjB,GAAqBkE,KAAhC;IACD,CAxBG,CAAN;IAyBA,OAAOL,GAAP;EACD;EAED;AACF;AACA;AACA;AACA;;;EAC8B,OAArBqB,qBAAqB,CAACxJ,IAAD,EAAO;IACjC,OAAOA,IAAI,CAAC0C,UAAL,CAAgB,KAAhB,EAAuB,WAAvB,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACkC,OAAzB+G,yBAAyB,GAAmB;IAAA,IAAlBC,QAAkB,uEAAP,KAAO;;IACjD,MAAM3K,MAAM,GAAG3B,OAAO,CAAC,YAAD,CAAP,CAAsBqM,yBAAtB,CAAgDC,QAAhD,CAAf;;IACA3K,MAAM,CAAC4K,SAAP,GAAmB,IAAnB;IACA,OAAO5K,MAAP;EACD;;AA3kBqB;;AA8kBxB6K,MAAM,CAACC,OAAP,GAAiBpL,IAAjB,C,CAEA;;AACA,MAAMoI,YAAY,GAAGzJ,OAAO,CAAC,4BAAD,CAA5B"},"metadata":{},"sourceType":"script"}