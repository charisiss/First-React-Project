{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('node:events');\n\nconst path = require('node:path');\n\nconst process = require('node:process');\n\nconst {\n  setTimeout\n} = require('node:timers');\n\nconst {\n  setTimeout: sleep\n} = require('node:timers/promises');\n\nconst {\n  Error\n} = require('../errors');\n\nconst Util = require('../util/Util');\n\nlet childProcess = null;\nlet Worker = null;\n/**\n * A self-contained shard created by the {@link ShardingManager}. Each one has a {@link ChildProcess} that contains\n * an instance of the bot and its {@link Client}. When its child process/worker exits for any reason, the shard will\n * spawn a new one to replace it as necessary.\n * @extends EventEmitter\n */\n\nclass Shard extends EventEmitter {\n  constructor(manager, id) {\n    super();\n    if (manager.mode === 'process') childProcess = require('node:child_process');else if (manager.mode === 'worker') Worker = require('node:worker_threads').Worker;\n    /**\n     * Manager that created the shard\n     * @type {ShardingManager}\n     */\n\n    this.manager = manager;\n    /**\n     * The shard's id in the manager\n     * @type {number}\n     */\n\n    this.id = id;\n    /**\n     * Arguments for the shard's process (only when {@link ShardingManager#mode} is `process`)\n     * @type {string[]}\n     */\n\n    this.args = manager.shardArgs ?? [];\n    /**\n     * Arguments for the shard's process executable (only when {@link ShardingManager#mode} is `process`)\n     * @type {string[]}\n     */\n\n    this.execArgv = manager.execArgv;\n    /**\n     * Environment variables for the shard's process, or workerData for the shard's worker\n     * @type {Object}\n     */\n\n    this.env = Object.assign({}, process.env, {\n      SHARDING_MANAGER: true,\n      SHARDS: this.id,\n      SHARD_COUNT: this.manager.totalShards,\n      DISCORD_TOKEN: this.manager.token\n    });\n    /**\n     * Whether the shard's {@link Client} is ready\n     * @type {boolean}\n     */\n\n    this.ready = false;\n    /**\n     * Process of the shard (if {@link ShardingManager#mode} is `process`)\n     * @type {?ChildProcess}\n     */\n\n    this.process = null;\n    /**\n     * Worker of the shard (if {@link ShardingManager#mode} is `worker`)\n     * @type {?Worker}\n     */\n\n    this.worker = null;\n    /**\n     * Ongoing promises for calls to {@link Shard#eval}, mapped by the `script` they were called with\n     * @type {Map<string, Promise>}\n     * @private\n     */\n\n    this._evals = new Map();\n    /**\n     * Ongoing promises for calls to {@link Shard#fetchClientValue}, mapped by the `prop` they were called with\n     * @type {Map<string, Promise>}\n     * @private\n     */\n\n    this._fetches = new Map();\n    /**\n     * Listener function for the {@link ChildProcess}' `exit` event\n     * @type {Function}\n     * @private\n     */\n\n    this._exitListener = null;\n  }\n  /**\n   * Forks a child process or creates a worker thread for the shard.\n   * <warn>You should not need to call this manually.</warn>\n   * @param {number} [timeout=30000] The amount in milliseconds to wait until the {@link Client} has become ready\n   * before resolving (`-1` or `Infinity` for no wait)\n   * @returns {Promise<ChildProcess>}\n   */\n\n\n  spawn() {\n    let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 30_000;\n    if (this.process) throw new Error('SHARDING_PROCESS_EXISTS', this.id);\n    if (this.worker) throw new Error('SHARDING_WORKER_EXISTS', this.id);\n    this._exitListener = this._handleExit.bind(this, undefined, timeout);\n\n    if (this.manager.mode === 'process') {\n      this.process = childProcess.fork(path.resolve(this.manager.file), this.args, {\n        env: this.env,\n        execArgv: this.execArgv\n      }).on('message', this._handleMessage.bind(this)).on('exit', this._exitListener);\n    } else if (this.manager.mode === 'worker') {\n      this.worker = new Worker(path.resolve(this.manager.file), {\n        workerData: this.env\n      }).on('message', this._handleMessage.bind(this)).on('exit', this._exitListener);\n    }\n\n    this._evals.clear();\n\n    this._fetches.clear();\n\n    const child = this.process ?? this.worker;\n    /**\n     * Emitted upon the creation of the shard's child process/worker.\n     * @event Shard#spawn\n     * @param {ChildProcess|Worker} process Child process/worker that was created\n     */\n\n    this.emit('spawn', child);\n    if (timeout === -1 || timeout === Infinity) return Promise.resolve(child);\n    return new Promise((resolve, reject) => {\n      const cleanup = () => {\n        clearTimeout(spawnTimeoutTimer);\n        this.off('ready', onReady);\n        this.off('disconnect', onDisconnect);\n        this.off('death', onDeath);\n      };\n\n      const onReady = () => {\n        cleanup();\n        resolve(child);\n      };\n\n      const onDisconnect = () => {\n        cleanup();\n        reject(new Error('SHARDING_READY_DISCONNECTED', this.id));\n      };\n\n      const onDeath = () => {\n        cleanup();\n        reject(new Error('SHARDING_READY_DIED', this.id));\n      };\n\n      const onTimeout = () => {\n        cleanup();\n        reject(new Error('SHARDING_READY_TIMEOUT', this.id));\n      };\n\n      const spawnTimeoutTimer = setTimeout(onTimeout, timeout);\n      this.once('ready', onReady);\n      this.once('disconnect', onDisconnect);\n      this.once('death', onDeath);\n    });\n  }\n  /**\n   * Immediately kills the shard's process/worker and does not restart it.\n   */\n\n\n  kill() {\n    if (this.process) {\n      this.process.removeListener('exit', this._exitListener);\n      this.process.kill();\n    } else {\n      this.worker.removeListener('exit', this._exitListener);\n      this.worker.terminate();\n    }\n\n    this._handleExit(false);\n  }\n  /**\n   * Options used to respawn a shard.\n   * @typedef {Object} ShardRespawnOptions\n   * @property {number} [delay=500] How long to wait between killing the process/worker and\n   * restarting it (in milliseconds)\n   * @property {number} [timeout=30000] The amount in milliseconds to wait until the {@link Client}\n   * has become ready before resolving (`-1` or `Infinity` for no wait)\n   */\n\n  /**\n   * Kills and restarts the shard's process/worker.\n   * @param {ShardRespawnOptions} [options] Options for respawning the shard\n   * @returns {Promise<ChildProcess>}\n   */\n\n\n  async respawn() {\n    let {\n      delay = 500,\n      timeout = 30_000\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.kill();\n    if (delay > 0) await sleep(delay);\n    return this.spawn(timeout);\n  }\n  /**\n   * Sends a message to the shard's process/worker.\n   * @param {*} message Message to send to the shard\n   * @returns {Promise<Shard>}\n   */\n\n\n  send(message) {\n    return new Promise((resolve, reject) => {\n      if (this.process) {\n        this.process.send(message, err => {\n          if (err) reject(err);else resolve(this);\n        });\n      } else {\n        this.worker.postMessage(message);\n        resolve(this);\n      }\n    });\n  }\n  /**\n   * Fetches a client property value of the shard.\n   * @param {string} prop Name of the client property to get, using periods for nesting\n   * @returns {Promise<*>}\n   * @example\n   * shard.fetchClientValue('guilds.cache.size')\n   *   .then(count => console.log(`${count} guilds in shard ${shard.id}`))\n   *   .catch(console.error);\n   */\n\n\n  fetchClientValue(prop) {\n    // Shard is dead (maybe respawning), don't cache anything and error immediately\n    if (!this.process && !this.worker) return Promise.reject(new Error('SHARDING_NO_CHILD_EXISTS', this.id)); // Cached promise from previous call\n\n    if (this._fetches.has(prop)) return this._fetches.get(prop);\n    const promise = new Promise((resolve, reject) => {\n      const child = this.process ?? this.worker;\n\n      const listener = message => {\n        if (message?._fetchProp !== prop) return;\n        child.removeListener('message', listener);\n\n        this._fetches.delete(prop);\n\n        if (!message._error) resolve(message._result);else reject(Util.makeError(message._error));\n      };\n\n      child.on('message', listener);\n      this.send({\n        _fetchProp: prop\n      }).catch(err => {\n        child.removeListener('message', listener);\n\n        this._fetches.delete(prop);\n\n        reject(err);\n      });\n    });\n\n    this._fetches.set(prop, promise);\n\n    return promise;\n  }\n  /**\n   * Evaluates a script or function on the shard, in the context of the {@link Client}.\n   * @param {string|Function} script JavaScript to run on the shard\n   * @param {*} [context] The context for the eval\n   * @returns {Promise<*>} Result of the script execution\n   */\n\n\n  eval(script, context) {\n    // Stringify the script if it's a Function\n    const _eval = typeof script === 'function' ? `(${script})(this, ${JSON.stringify(context)})` : script; // Shard is dead (maybe respawning), don't cache anything and error immediately\n\n\n    if (!this.process && !this.worker) return Promise.reject(new Error('SHARDING_NO_CHILD_EXISTS', this.id)); // Cached promise from previous call\n\n    if (this._evals.has(_eval)) return this._evals.get(_eval);\n    const promise = new Promise((resolve, reject) => {\n      const child = this.process ?? this.worker;\n\n      const listener = message => {\n        if (message?._eval !== _eval) return;\n        child.removeListener('message', listener);\n\n        this._evals.delete(_eval);\n\n        if (!message._error) resolve(message._result);else reject(Util.makeError(message._error));\n      };\n\n      child.on('message', listener);\n      this.send({\n        _eval\n      }).catch(err => {\n        child.removeListener('message', listener);\n\n        this._evals.delete(_eval);\n\n        reject(err);\n      });\n    });\n\n    this._evals.set(_eval, promise);\n\n    return promise;\n  }\n  /**\n   * Handles a message received from the child process/worker.\n   * @param {*} message Message received\n   * @private\n   */\n\n\n  _handleMessage(message) {\n    if (message) {\n      // Shard is ready\n      if (message._ready) {\n        this.ready = true;\n        /**\n         * Emitted upon the shard's {@link Client#event:shardReady} event.\n         * @event Shard#ready\n         */\n\n        this.emit('ready');\n        return;\n      } // Shard has disconnected\n\n\n      if (message._disconnect) {\n        this.ready = false;\n        /**\n         * Emitted upon the shard's {@link Client#event:shardDisconnect} event.\n         * @event Shard#disconnect\n         */\n\n        this.emit('disconnect');\n        return;\n      } // Shard is attempting to reconnect\n\n\n      if (message._reconnecting) {\n        this.ready = false;\n        /**\n         * Emitted upon the shard's {@link Client#event:shardReconnecting} event.\n         * @event Shard#reconnecting\n         */\n\n        this.emit('reconnecting');\n        return;\n      } // Shard is requesting a property fetch\n\n\n      if (message._sFetchProp) {\n        const resp = {\n          _sFetchProp: message._sFetchProp,\n          _sFetchPropShard: message._sFetchPropShard\n        };\n        this.manager.fetchClientValues(message._sFetchProp, message._sFetchPropShard).then(results => this.send({ ...resp,\n          _result: results\n        }), err => this.send({ ...resp,\n          _error: Util.makePlainError(err)\n        }));\n        return;\n      } // Shard is requesting an eval broadcast\n\n\n      if (message._sEval) {\n        const resp = {\n          _sEval: message._sEval,\n          _sEvalShard: message._sEvalShard\n        };\n\n        this.manager._performOnShards('eval', [message._sEval], message._sEvalShard).then(results => this.send({ ...resp,\n          _result: results\n        }), err => this.send({ ...resp,\n          _error: Util.makePlainError(err)\n        }));\n\n        return;\n      } // Shard is requesting a respawn of all shards\n\n\n      if (message._sRespawnAll) {\n        const {\n          shardDelay,\n          respawnDelay,\n          timeout\n        } = message._sRespawnAll;\n        this.manager.respawnAll({\n          shardDelay,\n          respawnDelay,\n          timeout\n        }).catch(() => {// Do nothing\n        });\n        return;\n      }\n    }\n    /**\n     * Emitted upon receiving a message from the child process/worker.\n     * @event Shard#message\n     * @param {*} message Message that was received\n     */\n\n\n    this.emit('message', message);\n  }\n  /**\n   * Handles the shard's process/worker exiting.\n   * @param {boolean} [respawn=this.manager.respawn] Whether to spawn the shard again\n   * @param {number} [timeout] The amount in milliseconds to wait until the {@link Client}\n   * has become ready (`-1` or `Infinity` for no wait)\n   * @private\n   */\n\n\n  _handleExit() {\n    let respawn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.manager.respawn;\n    let timeout = arguments.length > 1 ? arguments[1] : undefined;\n\n    /**\n     * Emitted upon the shard's child process/worker exiting.\n     * @event Shard#death\n     * @param {ChildProcess|Worker} process Child process/worker that exited\n     */\n    this.emit('death', this.process ?? this.worker);\n    this.ready = false;\n    this.process = null;\n    this.worker = null;\n\n    this._evals.clear();\n\n    this._fetches.clear();\n\n    if (respawn) this.spawn(timeout).catch(err => this.emit('error', err));\n  }\n\n}\n\nmodule.exports = Shard;","map":{"version":3,"names":["EventEmitter","require","path","process","setTimeout","sleep","Error","Util","childProcess","Worker","Shard","constructor","manager","id","mode","args","shardArgs","execArgv","env","Object","assign","SHARDING_MANAGER","SHARDS","SHARD_COUNT","totalShards","DISCORD_TOKEN","token","ready","worker","_evals","Map","_fetches","_exitListener","spawn","timeout","_handleExit","bind","undefined","fork","resolve","file","on","_handleMessage","workerData","clear","child","emit","Infinity","Promise","reject","cleanup","clearTimeout","spawnTimeoutTimer","off","onReady","onDisconnect","onDeath","onTimeout","once","kill","removeListener","terminate","respawn","delay","send","message","err","postMessage","fetchClientValue","prop","has","get","promise","listener","_fetchProp","delete","_error","_result","makeError","catch","set","eval","script","context","_eval","JSON","stringify","_ready","_disconnect","_reconnecting","_sFetchProp","resp","_sFetchPropShard","fetchClientValues","then","results","makePlainError","_sEval","_sEvalShard","_performOnShards","_sRespawnAll","shardDelay","respawnDelay","respawnAll","module","exports"],"sources":["C:/Users/xsxsam/node_modules/discord.js/src/sharding/Shard.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('node:events');\nconst path = require('node:path');\nconst process = require('node:process');\nconst { setTimeout } = require('node:timers');\nconst { setTimeout: sleep } = require('node:timers/promises');\nconst { Error } = require('../errors');\nconst Util = require('../util/Util');\nlet childProcess = null;\nlet Worker = null;\n\n/**\n * A self-contained shard created by the {@link ShardingManager}. Each one has a {@link ChildProcess} that contains\n * an instance of the bot and its {@link Client}. When its child process/worker exits for any reason, the shard will\n * spawn a new one to replace it as necessary.\n * @extends EventEmitter\n */\nclass Shard extends EventEmitter {\n  constructor(manager, id) {\n    super();\n\n    if (manager.mode === 'process') childProcess = require('node:child_process');\n    else if (manager.mode === 'worker') Worker = require('node:worker_threads').Worker;\n\n    /**\n     * Manager that created the shard\n     * @type {ShardingManager}\n     */\n    this.manager = manager;\n\n    /**\n     * The shard's id in the manager\n     * @type {number}\n     */\n    this.id = id;\n\n    /**\n     * Arguments for the shard's process (only when {@link ShardingManager#mode} is `process`)\n     * @type {string[]}\n     */\n    this.args = manager.shardArgs ?? [];\n\n    /**\n     * Arguments for the shard's process executable (only when {@link ShardingManager#mode} is `process`)\n     * @type {string[]}\n     */\n    this.execArgv = manager.execArgv;\n\n    /**\n     * Environment variables for the shard's process, or workerData for the shard's worker\n     * @type {Object}\n     */\n    this.env = Object.assign({}, process.env, {\n      SHARDING_MANAGER: true,\n      SHARDS: this.id,\n      SHARD_COUNT: this.manager.totalShards,\n      DISCORD_TOKEN: this.manager.token,\n    });\n\n    /**\n     * Whether the shard's {@link Client} is ready\n     * @type {boolean}\n     */\n    this.ready = false;\n\n    /**\n     * Process of the shard (if {@link ShardingManager#mode} is `process`)\n     * @type {?ChildProcess}\n     */\n    this.process = null;\n\n    /**\n     * Worker of the shard (if {@link ShardingManager#mode} is `worker`)\n     * @type {?Worker}\n     */\n    this.worker = null;\n\n    /**\n     * Ongoing promises for calls to {@link Shard#eval}, mapped by the `script` they were called with\n     * @type {Map<string, Promise>}\n     * @private\n     */\n    this._evals = new Map();\n\n    /**\n     * Ongoing promises for calls to {@link Shard#fetchClientValue}, mapped by the `prop` they were called with\n     * @type {Map<string, Promise>}\n     * @private\n     */\n    this._fetches = new Map();\n\n    /**\n     * Listener function for the {@link ChildProcess}' `exit` event\n     * @type {Function}\n     * @private\n     */\n    this._exitListener = null;\n  }\n\n  /**\n   * Forks a child process or creates a worker thread for the shard.\n   * <warn>You should not need to call this manually.</warn>\n   * @param {number} [timeout=30000] The amount in milliseconds to wait until the {@link Client} has become ready\n   * before resolving (`-1` or `Infinity` for no wait)\n   * @returns {Promise<ChildProcess>}\n   */\n  spawn(timeout = 30_000) {\n    if (this.process) throw new Error('SHARDING_PROCESS_EXISTS', this.id);\n    if (this.worker) throw new Error('SHARDING_WORKER_EXISTS', this.id);\n\n    this._exitListener = this._handleExit.bind(this, undefined, timeout);\n\n    if (this.manager.mode === 'process') {\n      this.process = childProcess\n        .fork(path.resolve(this.manager.file), this.args, {\n          env: this.env,\n          execArgv: this.execArgv,\n        })\n        .on('message', this._handleMessage.bind(this))\n        .on('exit', this._exitListener);\n    } else if (this.manager.mode === 'worker') {\n      this.worker = new Worker(path.resolve(this.manager.file), { workerData: this.env })\n        .on('message', this._handleMessage.bind(this))\n        .on('exit', this._exitListener);\n    }\n\n    this._evals.clear();\n    this._fetches.clear();\n\n    const child = this.process ?? this.worker;\n\n    /**\n     * Emitted upon the creation of the shard's child process/worker.\n     * @event Shard#spawn\n     * @param {ChildProcess|Worker} process Child process/worker that was created\n     */\n    this.emit('spawn', child);\n\n    if (timeout === -1 || timeout === Infinity) return Promise.resolve(child);\n    return new Promise((resolve, reject) => {\n      const cleanup = () => {\n        clearTimeout(spawnTimeoutTimer);\n        this.off('ready', onReady);\n        this.off('disconnect', onDisconnect);\n        this.off('death', onDeath);\n      };\n\n      const onReady = () => {\n        cleanup();\n        resolve(child);\n      };\n\n      const onDisconnect = () => {\n        cleanup();\n        reject(new Error('SHARDING_READY_DISCONNECTED', this.id));\n      };\n\n      const onDeath = () => {\n        cleanup();\n        reject(new Error('SHARDING_READY_DIED', this.id));\n      };\n\n      const onTimeout = () => {\n        cleanup();\n        reject(new Error('SHARDING_READY_TIMEOUT', this.id));\n      };\n\n      const spawnTimeoutTimer = setTimeout(onTimeout, timeout);\n      this.once('ready', onReady);\n      this.once('disconnect', onDisconnect);\n      this.once('death', onDeath);\n    });\n  }\n\n  /**\n   * Immediately kills the shard's process/worker and does not restart it.\n   */\n  kill() {\n    if (this.process) {\n      this.process.removeListener('exit', this._exitListener);\n      this.process.kill();\n    } else {\n      this.worker.removeListener('exit', this._exitListener);\n      this.worker.terminate();\n    }\n\n    this._handleExit(false);\n  }\n\n  /**\n   * Options used to respawn a shard.\n   * @typedef {Object} ShardRespawnOptions\n   * @property {number} [delay=500] How long to wait between killing the process/worker and\n   * restarting it (in milliseconds)\n   * @property {number} [timeout=30000] The amount in milliseconds to wait until the {@link Client}\n   * has become ready before resolving (`-1` or `Infinity` for no wait)\n   */\n\n  /**\n   * Kills and restarts the shard's process/worker.\n   * @param {ShardRespawnOptions} [options] Options for respawning the shard\n   * @returns {Promise<ChildProcess>}\n   */\n  async respawn({ delay = 500, timeout = 30_000 } = {}) {\n    this.kill();\n    if (delay > 0) await sleep(delay);\n    return this.spawn(timeout);\n  }\n\n  /**\n   * Sends a message to the shard's process/worker.\n   * @param {*} message Message to send to the shard\n   * @returns {Promise<Shard>}\n   */\n  send(message) {\n    return new Promise((resolve, reject) => {\n      if (this.process) {\n        this.process.send(message, err => {\n          if (err) reject(err);\n          else resolve(this);\n        });\n      } else {\n        this.worker.postMessage(message);\n        resolve(this);\n      }\n    });\n  }\n\n  /**\n   * Fetches a client property value of the shard.\n   * @param {string} prop Name of the client property to get, using periods for nesting\n   * @returns {Promise<*>}\n   * @example\n   * shard.fetchClientValue('guilds.cache.size')\n   *   .then(count => console.log(`${count} guilds in shard ${shard.id}`))\n   *   .catch(console.error);\n   */\n  fetchClientValue(prop) {\n    // Shard is dead (maybe respawning), don't cache anything and error immediately\n    if (!this.process && !this.worker) return Promise.reject(new Error('SHARDING_NO_CHILD_EXISTS', this.id));\n\n    // Cached promise from previous call\n    if (this._fetches.has(prop)) return this._fetches.get(prop);\n\n    const promise = new Promise((resolve, reject) => {\n      const child = this.process ?? this.worker;\n\n      const listener = message => {\n        if (message?._fetchProp !== prop) return;\n        child.removeListener('message', listener);\n        this._fetches.delete(prop);\n        if (!message._error) resolve(message._result);\n        else reject(Util.makeError(message._error));\n      };\n      child.on('message', listener);\n\n      this.send({ _fetchProp: prop }).catch(err => {\n        child.removeListener('message', listener);\n        this._fetches.delete(prop);\n        reject(err);\n      });\n    });\n\n    this._fetches.set(prop, promise);\n    return promise;\n  }\n\n  /**\n   * Evaluates a script or function on the shard, in the context of the {@link Client}.\n   * @param {string|Function} script JavaScript to run on the shard\n   * @param {*} [context] The context for the eval\n   * @returns {Promise<*>} Result of the script execution\n   */\n  eval(script, context) {\n    // Stringify the script if it's a Function\n    const _eval = typeof script === 'function' ? `(${script})(this, ${JSON.stringify(context)})` : script;\n\n    // Shard is dead (maybe respawning), don't cache anything and error immediately\n    if (!this.process && !this.worker) return Promise.reject(new Error('SHARDING_NO_CHILD_EXISTS', this.id));\n\n    // Cached promise from previous call\n    if (this._evals.has(_eval)) return this._evals.get(_eval);\n\n    const promise = new Promise((resolve, reject) => {\n      const child = this.process ?? this.worker;\n\n      const listener = message => {\n        if (message?._eval !== _eval) return;\n        child.removeListener('message', listener);\n        this._evals.delete(_eval);\n        if (!message._error) resolve(message._result);\n        else reject(Util.makeError(message._error));\n      };\n      child.on('message', listener);\n\n      this.send({ _eval }).catch(err => {\n        child.removeListener('message', listener);\n        this._evals.delete(_eval);\n        reject(err);\n      });\n    });\n\n    this._evals.set(_eval, promise);\n    return promise;\n  }\n\n  /**\n   * Handles a message received from the child process/worker.\n   * @param {*} message Message received\n   * @private\n   */\n  _handleMessage(message) {\n    if (message) {\n      // Shard is ready\n      if (message._ready) {\n        this.ready = true;\n        /**\n         * Emitted upon the shard's {@link Client#event:shardReady} event.\n         * @event Shard#ready\n         */\n        this.emit('ready');\n        return;\n      }\n\n      // Shard has disconnected\n      if (message._disconnect) {\n        this.ready = false;\n        /**\n         * Emitted upon the shard's {@link Client#event:shardDisconnect} event.\n         * @event Shard#disconnect\n         */\n        this.emit('disconnect');\n        return;\n      }\n\n      // Shard is attempting to reconnect\n      if (message._reconnecting) {\n        this.ready = false;\n        /**\n         * Emitted upon the shard's {@link Client#event:shardReconnecting} event.\n         * @event Shard#reconnecting\n         */\n        this.emit('reconnecting');\n        return;\n      }\n\n      // Shard is requesting a property fetch\n      if (message._sFetchProp) {\n        const resp = { _sFetchProp: message._sFetchProp, _sFetchPropShard: message._sFetchPropShard };\n        this.manager.fetchClientValues(message._sFetchProp, message._sFetchPropShard).then(\n          results => this.send({ ...resp, _result: results }),\n          err => this.send({ ...resp, _error: Util.makePlainError(err) }),\n        );\n        return;\n      }\n\n      // Shard is requesting an eval broadcast\n      if (message._sEval) {\n        const resp = { _sEval: message._sEval, _sEvalShard: message._sEvalShard };\n        this.manager._performOnShards('eval', [message._sEval], message._sEvalShard).then(\n          results => this.send({ ...resp, _result: results }),\n          err => this.send({ ...resp, _error: Util.makePlainError(err) }),\n        );\n        return;\n      }\n\n      // Shard is requesting a respawn of all shards\n      if (message._sRespawnAll) {\n        const { shardDelay, respawnDelay, timeout } = message._sRespawnAll;\n        this.manager.respawnAll({ shardDelay, respawnDelay, timeout }).catch(() => {\n          // Do nothing\n        });\n        return;\n      }\n    }\n\n    /**\n     * Emitted upon receiving a message from the child process/worker.\n     * @event Shard#message\n     * @param {*} message Message that was received\n     */\n    this.emit('message', message);\n  }\n\n  /**\n   * Handles the shard's process/worker exiting.\n   * @param {boolean} [respawn=this.manager.respawn] Whether to spawn the shard again\n   * @param {number} [timeout] The amount in milliseconds to wait until the {@link Client}\n   * has become ready (`-1` or `Infinity` for no wait)\n   * @private\n   */\n  _handleExit(respawn = this.manager.respawn, timeout) {\n    /**\n     * Emitted upon the shard's child process/worker exiting.\n     * @event Shard#death\n     * @param {ChildProcess|Worker} process Child process/worker that exited\n     */\n    this.emit('death', this.process ?? this.worker);\n\n    this.ready = false;\n    this.process = null;\n    this.worker = null;\n    this._evals.clear();\n    this._fetches.clear();\n\n    if (respawn) this.spawn(timeout).catch(err => this.emit('error', err));\n  }\n}\n\nmodule.exports = Shard;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}