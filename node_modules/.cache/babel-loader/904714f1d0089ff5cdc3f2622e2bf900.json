{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst CachedManager = require('./CachedManager');\n\nconst {\n  TypeError,\n  Error\n} = require('../errors');\n\nconst {\n  GuildScheduledEvent\n} = require('../structures/GuildScheduledEvent');\n\nconst {\n  PrivacyLevels,\n  GuildScheduledEventEntityTypes,\n  GuildScheduledEventStatuses\n} = require('../util/Constants');\n/**\n * Manages API methods for GuildScheduledEvents and stores their cache.\n * @extends {CachedManager}\n */\n\n\nclass GuildScheduledEventManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, GuildScheduledEvent, iterable);\n    /**\n     * The guild this manager belongs to\n     * @type {Guild}\n     */\n\n    this.guild = guild;\n  }\n  /**\n   * The cache of this manager\n   * @type {Collection<Snowflake, GuildScheduledEvent>}\n   * @name GuildScheduledEventManager#cache\n   */\n\n  /**\n   * Data that resolves to give a GuildScheduledEvent object. This can be:\n   * * A Snowflake\n   * * A GuildScheduledEvent object\n   * @typedef {Snowflake|GuildScheduledEvent} GuildScheduledEventResolvable\n   */\n\n  /**\n   * Options used to create a guild scheduled event.\n   * @typedef {Object} GuildScheduledEventCreateOptions\n   * @property {string} name The name of the guild scheduled event\n   * @property {DateResolvable} scheduledStartTime The time to schedule the event at\n   * @property {DateResolvable} [scheduledEndTime] The time to end the event at\n   * <warn>This is required if `entityType` is 'EXTERNAL'</warn>\n   * @property {PrivacyLevel|number} privacyLevel The privacy level of the guild scheduled event\n   * @property {GuildScheduledEventEntityType|number} entityType The scheduled entity type of the event\n   * @property {string} [description] The description of the guild scheduled event\n   * @property {GuildVoiceChannelResolvable} [channel] The channel of the guild scheduled event\n   * <warn>This is required if `entityType` is 'STAGE_INSTANCE' or `VOICE`</warn>\n   * @property {GuildScheduledEventEntityMetadataOptions} [entityMetadata] The entity metadata of the\n   * guild scheduled event\n   * <warn>This is required if `entityType` is 'EXTERNAL'</warn>\n   * @property {string} [reason] The reason for creating the guild scheduled event\n   */\n\n  /**\n   * Options used to set entity metadata of a guild scheduled event.\n   * @typedef {Object} GuildScheduledEventEntityMetadataOptions\n   * @property {string} [location] The location of the guild scheduled event\n   * <warn>This is required if `entityType` is 'EXTERNAL'</warn>\n   */\n\n  /**\n   * Creates a new guild scheduled event.\n   * @param {GuildScheduledEventCreateOptions} options Options for creating the guild scheduled event\n   * @returns {Promise<GuildScheduledEvent>}\n   */\n\n\n  async create(options) {\n    if (typeof options !== 'object') throw new TypeError('INVALID_TYPE', 'options', 'object', true);\n    let {\n      privacyLevel,\n      entityType,\n      channel,\n      name,\n      scheduledStartTime,\n      description,\n      scheduledEndTime,\n      entityMetadata,\n      reason\n    } = options;\n    if (typeof privacyLevel === 'string') privacyLevel = PrivacyLevels[privacyLevel];\n    if (typeof entityType === 'string') entityType = GuildScheduledEventEntityTypes[entityType];\n    let entity_metadata, channel_id;\n\n    if (entityType === GuildScheduledEventEntityTypes.EXTERNAL) {\n      channel_id = typeof channel === 'undefined' ? channel : null;\n      entity_metadata = {\n        location: entityMetadata?.location\n      };\n    } else {\n      channel_id = this.guild.channels.resolveId(channel);\n      if (!channel_id) throw new Error('GUILD_VOICE_CHANNEL_RESOLVE');\n      entity_metadata = typeof entityMetadata === 'undefined' ? entityMetadata : null;\n    }\n\n    const data = await this.client.api.guilds(this.guild.id, 'scheduled-events').post({\n      data: {\n        channel_id,\n        name,\n        privacy_level: privacyLevel,\n        scheduled_start_time: new Date(scheduledStartTime).toISOString(),\n        scheduled_end_time: scheduledEndTime ? new Date(scheduledEndTime).toISOString() : scheduledEndTime,\n        description,\n        entity_type: entityType,\n        entity_metadata\n      },\n      reason\n    });\n    return this._add(data);\n  }\n  /**\n   * Options used to fetch a single guild scheduled event from a guild.\n   * @typedef {BaseFetchOptions} FetchGuildScheduledEventOptions\n   * @property {GuildScheduledEventResolvable} guildScheduledEvent The guild scheduled event to fetch\n   * @property {boolean} [withUserCount=true] Whether to fetch the number of users subscribed to the scheduled event\n   */\n\n  /**\n   * Options used to fetch multiple guild scheduled events from a guild.\n   * @typedef {Object} FetchGuildScheduledEventsOptions\n   * @property {boolean} [cache] Whether or not to cache the fetched guild scheduled events\n   * @property {boolean} [withUserCount=true] Whether to fetch the number of users subscribed to each scheduled event\n   * should be returned\n   */\n\n  /**\n   * Obtains one or more guild scheduled events from Discord, or the guild cache if it's already available.\n   * @param {GuildScheduledEventResolvable|FetchGuildScheduledEventOptions|FetchGuildScheduledEventsOptions} [options]\n   * The id of the guild scheduled event or options\n   * @returns {Promise<GuildScheduledEvent|Collection<Snowflake, GuildScheduledEvent>>}\n   */\n\n\n  async fetch() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const id = this.resolveId(options.guildScheduledEvent ?? options);\n\n    if (id) {\n      if (!options.force) {\n        const existing = this.cache.get(id);\n        if (existing) return existing;\n      }\n\n      const data = await this.client.api.guilds(this.guild.id, 'scheduled-events', id).get({\n        query: {\n          with_user_count: options.withUserCount ?? true\n        }\n      });\n      return this._add(data, options.cache);\n    }\n\n    const data = await this.client.api.guilds(this.guild.id, 'scheduled-events').get({\n      query: {\n        with_user_count: options.withUserCount ?? true\n      }\n    });\n    return data.reduce((coll, rawGuildScheduledEventData) => coll.set(rawGuildScheduledEventData.id, this.guild.scheduledEvents._add(rawGuildScheduledEventData, options.cache)), new Collection());\n  }\n  /**\n   * Options used to edit a guild scheduled event.\n   * @typedef {Object} GuildScheduledEventEditOptions\n   * @property {string} [name] The name of the guild scheduled event\n   * @property {DateResolvable} [scheduledStartTime] The time to schedule the event at\n   * @property {DateResolvable} [scheduledEndTime] The time to end the event at\n   * @property {PrivacyLevel|number} [privacyLevel] The privacy level of the guild scheduled event\n   * @property {GuildScheduledEventEntityType|number} [entityType] The scheduled entity type of the event\n   * @property {string} [description] The description of the guild scheduled event\n   * @property {?GuildVoiceChannelResolvable} [channel] The channel of the guild scheduled event\n   * @property {GuildScheduledEventStatus|number} [status] The status of the guild scheduled event\n   * @property {GuildScheduledEventEntityMetadataOptions} [entityMetadata] The entity metadata of the\n   * guild scheduled event\n   * <warn>This can be modified only if `entityType` of the `GuildScheduledEvent` to be edited is 'EXTERNAL'</warn>\n   * @property {string} [reason] The reason for editing the guild scheduled event\n   */\n\n  /**\n   * Edits a guild scheduled event.\n   * @param {GuildScheduledEventResolvable} guildScheduledEvent The guild scheduled event to edit\n   * @param {GuildScheduledEventEditOptions} options Options to edit the guild scheduled event\n   * @returns {Promise<GuildScheduledEvent>}\n   */\n\n\n  async edit(guildScheduledEvent, options) {\n    const guildScheduledEventId = this.resolveId(guildScheduledEvent);\n    if (!guildScheduledEventId) throw new Error('GUILD_SCHEDULED_EVENT_RESOLVE');\n    if (typeof options !== 'object') throw new TypeError('INVALID_TYPE', 'options', 'object', true);\n    let {\n      privacyLevel,\n      entityType,\n      channel,\n      status,\n      name,\n      scheduledStartTime,\n      description,\n      scheduledEndTime,\n      entityMetadata,\n      reason\n    } = options;\n    if (typeof privacyLevel === 'string') privacyLevel = PrivacyLevels[privacyLevel];\n    if (typeof entityType === 'string') entityType = GuildScheduledEventEntityTypes[entityType];\n    if (typeof status === 'string') status = GuildScheduledEventStatuses[status];\n    let entity_metadata;\n\n    if (entityMetadata) {\n      entity_metadata = {\n        location: entityMetadata.location\n      };\n    }\n\n    const data = await this.client.api.guilds(this.guild.id, 'scheduled-events', guildScheduledEventId).patch({\n      data: {\n        channel_id: typeof channel === 'undefined' ? channel : this.guild.channels.resolveId(channel),\n        name,\n        privacy_level: privacyLevel,\n        scheduled_start_time: scheduledStartTime ? new Date(scheduledStartTime).toISOString() : undefined,\n        scheduled_end_time: scheduledEndTime ? new Date(scheduledEndTime).toISOString() : scheduledEndTime,\n        description,\n        entity_type: entityType,\n        status,\n        entity_metadata\n      },\n      reason\n    });\n    return this._add(data);\n  }\n  /**\n   * Deletes a guild scheduled event.\n   * @param {GuildScheduledEventResolvable} guildScheduledEvent The guild scheduled event to delete\n   * @returns {Promise<void>}\n   */\n\n\n  async delete(guildScheduledEvent) {\n    const guildScheduledEventId = this.resolveId(guildScheduledEvent);\n    if (!guildScheduledEventId) throw new Error('GUILD_SCHEDULED_EVENT_RESOLVE');\n    await this.client.api.guilds(this.guild.id, 'scheduled-events', guildScheduledEventId).delete();\n  }\n  /**\n   * Options used to fetch subscribers of a guild scheduled event\n   * @typedef {Object} FetchGuildScheduledEventSubscribersOptions\n   * @property {number} [limit] The maximum numbers of users to fetch\n   * @property {boolean} [withMember] Whether to fetch guild member data of the users\n   * @property {Snowflake} [before] Consider only users before this user id\n   * @property {Snowflake} [after] Consider only users after this user id\n   * <warn>If both `before` and `after` are provided, only `before` is respected</warn>\n   */\n\n  /**\n   * Represents a subscriber of a {@link GuildScheduledEvent}\n   * @typedef {Object} GuildScheduledEventUser\n   * @property {Snowflake} guildScheduledEventId The id of the guild scheduled event which the user subscribed to\n   * @property {User} user The user that subscribed to the guild scheduled event\n   * @property {?GuildMember} member The guild member associated with the user, if any\n   */\n\n  /**\n   * Fetches subscribers of a guild scheduled event.\n   * @param {GuildScheduledEventResolvable} guildScheduledEvent The guild scheduled event to fetch subscribers of\n   * @param {FetchGuildScheduledEventSubscribersOptions} [options={}] Options for fetching the subscribers\n   * @returns {Promise<Collection<Snowflake, GuildScheduledEventUser>>}\n   */\n\n\n  async fetchSubscribers(guildScheduledEvent) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const guildScheduledEventId = this.resolveId(guildScheduledEvent);\n    if (!guildScheduledEventId) throw new Error('GUILD_SCHEDULED_EVENT_RESOLVE');\n    let {\n      limit,\n      withMember,\n      before,\n      after\n    } = options;\n    const data = await this.client.api.guilds(this.guild.id, 'scheduled-events', guildScheduledEventId).users.get({\n      query: {\n        limit,\n        with_member: withMember,\n        before,\n        after\n      }\n    });\n    return data.reduce((coll, rawData) => coll.set(rawData.user.id, {\n      guildScheduledEventId: rawData.guild_scheduled_event_id,\n      user: this.client.users._add(rawData.user),\n      member: rawData.member ? this.guild.members._add({ ...rawData.member,\n        user: rawData.user\n      }) : null\n    }), new Collection());\n  }\n\n}\n\nmodule.exports = GuildScheduledEventManager;","map":{"version":3,"names":["Collection","require","CachedManager","TypeError","Error","GuildScheduledEvent","PrivacyLevels","GuildScheduledEventEntityTypes","GuildScheduledEventStatuses","GuildScheduledEventManager","constructor","guild","iterable","client","create","options","privacyLevel","entityType","channel","name","scheduledStartTime","description","scheduledEndTime","entityMetadata","reason","entity_metadata","channel_id","EXTERNAL","location","channels","resolveId","data","api","guilds","id","post","privacy_level","scheduled_start_time","Date","toISOString","scheduled_end_time","entity_type","_add","fetch","guildScheduledEvent","force","existing","cache","get","query","with_user_count","withUserCount","reduce","coll","rawGuildScheduledEventData","set","scheduledEvents","edit","guildScheduledEventId","status","patch","undefined","delete","fetchSubscribers","limit","withMember","before","after","users","with_member","rawData","user","guild_scheduled_event_id","member","members","module","exports"],"sources":["C:/Users/xsxsam/node_modules/discord.js/src/managers/GuildScheduledEventManager.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst CachedManager = require('./CachedManager');\nconst { TypeError, Error } = require('../errors');\nconst { GuildScheduledEvent } = require('../structures/GuildScheduledEvent');\nconst { PrivacyLevels, GuildScheduledEventEntityTypes, GuildScheduledEventStatuses } = require('../util/Constants');\n\n/**\n * Manages API methods for GuildScheduledEvents and stores their cache.\n * @extends {CachedManager}\n */\nclass GuildScheduledEventManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, GuildScheduledEvent, iterable);\n\n    /**\n     * The guild this manager belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The cache of this manager\n   * @type {Collection<Snowflake, GuildScheduledEvent>}\n   * @name GuildScheduledEventManager#cache\n   */\n\n  /**\n   * Data that resolves to give a GuildScheduledEvent object. This can be:\n   * * A Snowflake\n   * * A GuildScheduledEvent object\n   * @typedef {Snowflake|GuildScheduledEvent} GuildScheduledEventResolvable\n   */\n\n  /**\n   * Options used to create a guild scheduled event.\n   * @typedef {Object} GuildScheduledEventCreateOptions\n   * @property {string} name The name of the guild scheduled event\n   * @property {DateResolvable} scheduledStartTime The time to schedule the event at\n   * @property {DateResolvable} [scheduledEndTime] The time to end the event at\n   * <warn>This is required if `entityType` is 'EXTERNAL'</warn>\n   * @property {PrivacyLevel|number} privacyLevel The privacy level of the guild scheduled event\n   * @property {GuildScheduledEventEntityType|number} entityType The scheduled entity type of the event\n   * @property {string} [description] The description of the guild scheduled event\n   * @property {GuildVoiceChannelResolvable} [channel] The channel of the guild scheduled event\n   * <warn>This is required if `entityType` is 'STAGE_INSTANCE' or `VOICE`</warn>\n   * @property {GuildScheduledEventEntityMetadataOptions} [entityMetadata] The entity metadata of the\n   * guild scheduled event\n   * <warn>This is required if `entityType` is 'EXTERNAL'</warn>\n   * @property {string} [reason] The reason for creating the guild scheduled event\n   */\n\n  /**\n   * Options used to set entity metadata of a guild scheduled event.\n   * @typedef {Object} GuildScheduledEventEntityMetadataOptions\n   * @property {string} [location] The location of the guild scheduled event\n   * <warn>This is required if `entityType` is 'EXTERNAL'</warn>\n   */\n\n  /**\n   * Creates a new guild scheduled event.\n   * @param {GuildScheduledEventCreateOptions} options Options for creating the guild scheduled event\n   * @returns {Promise<GuildScheduledEvent>}\n   */\n  async create(options) {\n    if (typeof options !== 'object') throw new TypeError('INVALID_TYPE', 'options', 'object', true);\n    let {\n      privacyLevel,\n      entityType,\n      channel,\n      name,\n      scheduledStartTime,\n      description,\n      scheduledEndTime,\n      entityMetadata,\n      reason,\n    } = options;\n\n    if (typeof privacyLevel === 'string') privacyLevel = PrivacyLevels[privacyLevel];\n    if (typeof entityType === 'string') entityType = GuildScheduledEventEntityTypes[entityType];\n\n    let entity_metadata, channel_id;\n    if (entityType === GuildScheduledEventEntityTypes.EXTERNAL) {\n      channel_id = typeof channel === 'undefined' ? channel : null;\n      entity_metadata = { location: entityMetadata?.location };\n    } else {\n      channel_id = this.guild.channels.resolveId(channel);\n      if (!channel_id) throw new Error('GUILD_VOICE_CHANNEL_RESOLVE');\n      entity_metadata = typeof entityMetadata === 'undefined' ? entityMetadata : null;\n    }\n\n    const data = await this.client.api.guilds(this.guild.id, 'scheduled-events').post({\n      data: {\n        channel_id,\n        name,\n        privacy_level: privacyLevel,\n        scheduled_start_time: new Date(scheduledStartTime).toISOString(),\n        scheduled_end_time: scheduledEndTime ? new Date(scheduledEndTime).toISOString() : scheduledEndTime,\n        description,\n        entity_type: entityType,\n        entity_metadata,\n      },\n      reason,\n    });\n\n    return this._add(data);\n  }\n\n  /**\n   * Options used to fetch a single guild scheduled event from a guild.\n   * @typedef {BaseFetchOptions} FetchGuildScheduledEventOptions\n   * @property {GuildScheduledEventResolvable} guildScheduledEvent The guild scheduled event to fetch\n   * @property {boolean} [withUserCount=true] Whether to fetch the number of users subscribed to the scheduled event\n   */\n\n  /**\n   * Options used to fetch multiple guild scheduled events from a guild.\n   * @typedef {Object} FetchGuildScheduledEventsOptions\n   * @property {boolean} [cache] Whether or not to cache the fetched guild scheduled events\n   * @property {boolean} [withUserCount=true] Whether to fetch the number of users subscribed to each scheduled event\n   * should be returned\n   */\n\n  /**\n   * Obtains one or more guild scheduled events from Discord, or the guild cache if it's already available.\n   * @param {GuildScheduledEventResolvable|FetchGuildScheduledEventOptions|FetchGuildScheduledEventsOptions} [options]\n   * The id of the guild scheduled event or options\n   * @returns {Promise<GuildScheduledEvent|Collection<Snowflake, GuildScheduledEvent>>}\n   */\n  async fetch(options = {}) {\n    const id = this.resolveId(options.guildScheduledEvent ?? options);\n\n    if (id) {\n      if (!options.force) {\n        const existing = this.cache.get(id);\n        if (existing) return existing;\n      }\n\n      const data = await this.client.api\n        .guilds(this.guild.id, 'scheduled-events', id)\n        .get({ query: { with_user_count: options.withUserCount ?? true } });\n      return this._add(data, options.cache);\n    }\n\n    const data = await this.client.api\n      .guilds(this.guild.id, 'scheduled-events')\n      .get({ query: { with_user_count: options.withUserCount ?? true } });\n\n    return data.reduce(\n      (coll, rawGuildScheduledEventData) =>\n        coll.set(\n          rawGuildScheduledEventData.id,\n          this.guild.scheduledEvents._add(rawGuildScheduledEventData, options.cache),\n        ),\n      new Collection(),\n    );\n  }\n\n  /**\n   * Options used to edit a guild scheduled event.\n   * @typedef {Object} GuildScheduledEventEditOptions\n   * @property {string} [name] The name of the guild scheduled event\n   * @property {DateResolvable} [scheduledStartTime] The time to schedule the event at\n   * @property {DateResolvable} [scheduledEndTime] The time to end the event at\n   * @property {PrivacyLevel|number} [privacyLevel] The privacy level of the guild scheduled event\n   * @property {GuildScheduledEventEntityType|number} [entityType] The scheduled entity type of the event\n   * @property {string} [description] The description of the guild scheduled event\n   * @property {?GuildVoiceChannelResolvable} [channel] The channel of the guild scheduled event\n   * @property {GuildScheduledEventStatus|number} [status] The status of the guild scheduled event\n   * @property {GuildScheduledEventEntityMetadataOptions} [entityMetadata] The entity metadata of the\n   * guild scheduled event\n   * <warn>This can be modified only if `entityType` of the `GuildScheduledEvent` to be edited is 'EXTERNAL'</warn>\n   * @property {string} [reason] The reason for editing the guild scheduled event\n   */\n\n  /**\n   * Edits a guild scheduled event.\n   * @param {GuildScheduledEventResolvable} guildScheduledEvent The guild scheduled event to edit\n   * @param {GuildScheduledEventEditOptions} options Options to edit the guild scheduled event\n   * @returns {Promise<GuildScheduledEvent>}\n   */\n  async edit(guildScheduledEvent, options) {\n    const guildScheduledEventId = this.resolveId(guildScheduledEvent);\n    if (!guildScheduledEventId) throw new Error('GUILD_SCHEDULED_EVENT_RESOLVE');\n\n    if (typeof options !== 'object') throw new TypeError('INVALID_TYPE', 'options', 'object', true);\n    let {\n      privacyLevel,\n      entityType,\n      channel,\n      status,\n      name,\n      scheduledStartTime,\n      description,\n      scheduledEndTime,\n      entityMetadata,\n      reason,\n    } = options;\n\n    if (typeof privacyLevel === 'string') privacyLevel = PrivacyLevels[privacyLevel];\n    if (typeof entityType === 'string') entityType = GuildScheduledEventEntityTypes[entityType];\n    if (typeof status === 'string') status = GuildScheduledEventStatuses[status];\n\n    let entity_metadata;\n    if (entityMetadata) {\n      entity_metadata = {\n        location: entityMetadata.location,\n      };\n    }\n\n    const data = await this.client.api.guilds(this.guild.id, 'scheduled-events', guildScheduledEventId).patch({\n      data: {\n        channel_id: typeof channel === 'undefined' ? channel : this.guild.channels.resolveId(channel),\n        name,\n        privacy_level: privacyLevel,\n        scheduled_start_time: scheduledStartTime ? new Date(scheduledStartTime).toISOString() : undefined,\n        scheduled_end_time: scheduledEndTime ? new Date(scheduledEndTime).toISOString() : scheduledEndTime,\n        description,\n        entity_type: entityType,\n        status,\n        entity_metadata,\n      },\n      reason,\n    });\n\n    return this._add(data);\n  }\n\n  /**\n   * Deletes a guild scheduled event.\n   * @param {GuildScheduledEventResolvable} guildScheduledEvent The guild scheduled event to delete\n   * @returns {Promise<void>}\n   */\n  async delete(guildScheduledEvent) {\n    const guildScheduledEventId = this.resolveId(guildScheduledEvent);\n    if (!guildScheduledEventId) throw new Error('GUILD_SCHEDULED_EVENT_RESOLVE');\n\n    await this.client.api.guilds(this.guild.id, 'scheduled-events', guildScheduledEventId).delete();\n  }\n\n  /**\n   * Options used to fetch subscribers of a guild scheduled event\n   * @typedef {Object} FetchGuildScheduledEventSubscribersOptions\n   * @property {number} [limit] The maximum numbers of users to fetch\n   * @property {boolean} [withMember] Whether to fetch guild member data of the users\n   * @property {Snowflake} [before] Consider only users before this user id\n   * @property {Snowflake} [after] Consider only users after this user id\n   * <warn>If both `before` and `after` are provided, only `before` is respected</warn>\n   */\n\n  /**\n   * Represents a subscriber of a {@link GuildScheduledEvent}\n   * @typedef {Object} GuildScheduledEventUser\n   * @property {Snowflake} guildScheduledEventId The id of the guild scheduled event which the user subscribed to\n   * @property {User} user The user that subscribed to the guild scheduled event\n   * @property {?GuildMember} member The guild member associated with the user, if any\n   */\n\n  /**\n   * Fetches subscribers of a guild scheduled event.\n   * @param {GuildScheduledEventResolvable} guildScheduledEvent The guild scheduled event to fetch subscribers of\n   * @param {FetchGuildScheduledEventSubscribersOptions} [options={}] Options for fetching the subscribers\n   * @returns {Promise<Collection<Snowflake, GuildScheduledEventUser>>}\n   */\n  async fetchSubscribers(guildScheduledEvent, options = {}) {\n    const guildScheduledEventId = this.resolveId(guildScheduledEvent);\n    if (!guildScheduledEventId) throw new Error('GUILD_SCHEDULED_EVENT_RESOLVE');\n\n    let { limit, withMember, before, after } = options;\n\n    const data = await this.client.api.guilds(this.guild.id, 'scheduled-events', guildScheduledEventId).users.get({\n      query: { limit, with_member: withMember, before, after },\n    });\n\n    return data.reduce(\n      (coll, rawData) =>\n        coll.set(rawData.user.id, {\n          guildScheduledEventId: rawData.guild_scheduled_event_id,\n          user: this.client.users._add(rawData.user),\n          member: rawData.member ? this.guild.members._add({ ...rawData.member, user: rawData.user }) : null,\n        }),\n      new Collection(),\n    );\n  }\n}\n\nmodule.exports = GuildScheduledEventManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}