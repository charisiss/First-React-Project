{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst CachedManager = require('./CachedManager');\n\nconst {\n  TypeError\n} = require('../errors');\n\nconst ThreadChannel = require('../structures/ThreadChannel');\n\nconst {\n  ChannelTypes\n} = require('../util/Constants');\n/**\n * Manages API methods for {@link ThreadChannel} objects and stores their cache.\n * @extends {CachedManager}\n */\n\n\nclass ThreadManager extends CachedManager {\n  constructor(channel, iterable) {\n    super(channel.client, ThreadChannel, iterable);\n    /**\n     * The channel this Manager belongs to\n     * @type {NewsChannel|TextChannel}\n     */\n\n    this.channel = channel;\n  }\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, ThreadChannel>}\n   * @name ThreadManager#cache\n   */\n\n\n  _add(thread) {\n    const existing = this.cache.get(thread.id);\n    if (existing) return existing;\n    this.cache.set(thread.id, thread);\n    return thread;\n  }\n  /**\n   * Data that can be resolved to a Thread Channel object. This can be:\n   * * A ThreadChannel object\n   * * A Snowflake\n   * @typedef {ThreadChannel|Snowflake} ThreadChannelResolvable\n   */\n\n  /**\n   * Resolves a {@link ThreadChannelResolvable} to a {@link ThreadChannel} object.\n   * @method resolve\n   * @memberof ThreadManager\n   * @instance\n   * @param {ThreadChannelResolvable} thread The ThreadChannel resolvable to resolve\n   * @returns {?ThreadChannel}\n   */\n\n  /**\n   * Resolves a {@link ThreadChannelResolvable} to a {@link ThreadChannel} id.\n   * @method resolveId\n   * @memberof ThreadManager\n   * @instance\n   * @param {ThreadChannelResolvable} thread The ThreadChannel resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Options for creating a thread. <warn>Only one of `startMessage` or `type` can be defined.</warn>\n   * @typedef {StartThreadOptions} ThreadCreateOptions\n   * @property {MessageResolvable} [startMessage] The message to start a thread from. <warn>If this is defined then type\n   * of thread gets automatically defined and cannot be changed. The provided `type` field will be ignored</warn>\n   * @property {ThreadChannelTypes|number} [type] The type of thread to create. Defaults to `GUILD_PUBLIC_THREAD` if\n   * created in a {@link TextChannel} <warn>When creating threads in a {@link NewsChannel} this is ignored and is always\n   * `GUILD_NEWS_THREAD`</warn>\n   * @property {boolean} [invitable] Whether non-moderators can add other non-moderators to the thread\n   * <info>Can only be set when type will be `GUILD_PRIVATE_THREAD`</info>\n   * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the new channel in seconds\n   */\n\n  /**\n   * Creates a new thread in the channel.\n   * @param {ThreadCreateOptions} [options] Options to create a new thread\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Create a new public thread\n   * channel.threads\n   *   .create({\n   *     name: 'food-talk',\n   *     autoArchiveDuration: 60,\n   *     reason: 'Needed a separate thread for food',\n   *   })\n   *   .then(threadChannel => console.log(threadChannel))\n   *   .catch(console.error);\n   * @example\n   * // Create a new private thread\n   * channel.threads\n   *   .create({\n   *      name: 'mod-talk',\n   *      autoArchiveDuration: 60,\n   *      type: 'GUILD_PRIVATE_THREAD',\n   *      reason: 'Needed a separate thread for moderation',\n   *    })\n   *   .then(threadChannel => console.log(threadChannel))\n   *   .catch(console.error);\n   */\n\n\n  async create() {\n    let {\n      name,\n      autoArchiveDuration = this.channel.defaultAutoArchiveDuration,\n      startMessage,\n      type,\n      invitable,\n      reason,\n      rateLimitPerUser\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let path = this.client.api.channels(this.channel.id);\n\n    if (type && typeof type !== 'string' && typeof type !== 'number') {\n      throw new TypeError('INVALID_TYPE', 'type', 'ThreadChannelType or Number');\n    }\n\n    let resolvedType = this.channel.type === 'GUILD_NEWS' ? ChannelTypes.GUILD_NEWS_THREAD : ChannelTypes.GUILD_PUBLIC_THREAD;\n\n    if (startMessage) {\n      const startMessageId = this.channel.messages.resolveId(startMessage);\n      if (!startMessageId) throw new TypeError('INVALID_TYPE', 'startMessage', 'MessageResolvable');\n      path = path.messages(startMessageId);\n    } else if (this.channel.type !== 'GUILD_NEWS') {\n      resolvedType = typeof type === 'string' ? ChannelTypes[type] : type ?? resolvedType;\n    }\n\n    if (autoArchiveDuration === 'MAX') {\n      autoArchiveDuration = 1440;\n\n      if (this.channel.guild.features.includes('SEVEN_DAY_THREAD_ARCHIVE')) {\n        autoArchiveDuration = 10080;\n      } else if (this.channel.guild.features.includes('THREE_DAY_THREAD_ARCHIVE')) {\n        autoArchiveDuration = 4320;\n      }\n    }\n\n    const data = await path.threads.post({\n      data: {\n        name,\n        auto_archive_duration: autoArchiveDuration,\n        type: resolvedType,\n        invitable: resolvedType === ChannelTypes.GUILD_PRIVATE_THREAD ? invitable : undefined,\n        rate_limit_per_user: rateLimitPerUser\n      },\n      reason\n    });\n    return this.client.actions.ThreadCreate.handle(data).thread;\n  }\n  /**\n   * The options for fetching multiple threads, the properties are mutually exclusive\n   * @typedef {Object} FetchThreadsOptions\n   * @property {FetchArchivedThreadOptions} [archived] The options used to fetch archived threads\n   * @property {boolean} [active] When true, fetches active threads. <warn>If `archived` is set, this is ignored!</warn>\n   */\n\n  /**\n   * Obtains a thread from Discord, or the channel cache if it's already available.\n   * @param {ThreadChannelResolvable|FetchThreadsOptions} [options] The options to fetch threads. If it is a\n   * ThreadChannelResolvable then the specified thread will be fetched. Fetches all active threads if `undefined`\n   * @param {BaseFetchOptions} [cacheOptions] Additional options for this fetch. <warn>The `force` field gets ignored\n   * if `options` is not a {@link ThreadChannelResolvable}</warn>\n   * @returns {Promise<?(ThreadChannel|FetchedThreads)>}\n   * @example\n   * // Fetch a thread by its id\n   * channel.threads.fetch('831955138126104859')\n   *   .then(channel => console.log(channel.name))\n   *   .catch(console.error);\n   */\n\n\n  fetch(options) {\n    let {\n      cache = true,\n      force = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!options) return this.fetchActive(cache);\n    const channel = this.client.channels.resolveId(options);\n    if (channel) return this.client.channels.fetch(channel, cache, force);\n\n    if (options.archived) {\n      return this.fetchArchived(options.archived, cache);\n    }\n\n    return this.fetchActive(cache);\n  }\n  /**\n   * Data that can be resolved to a Date object. This can be:\n   * * A Date object\n   * * A number representing a timestamp\n   * * An [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) string\n   * @typedef {Date|number|string} DateResolvable\n   */\n\n  /**\n   * The options used to fetch archived threads.\n   * @typedef {Object} FetchArchivedThreadOptions\n   * @property {string} [type='public'] The type of threads to fetch, either `public` or `private`\n   * @property {boolean} [fetchAll=false] Whether to fetch **all** archived threads when type is `private`.\n   * Requires `MANAGE_THREADS` if true\n   * @property {DateResolvable|ThreadChannelResolvable} [before] Only return threads that were created before this Date\n   * or Snowflake. <warn>Must be a {@link ThreadChannelResolvable} when type is `private` and fetchAll is `false`</warn>\n   * @property {number} [limit] Maximum number of threads to return\n   */\n\n  /**\n   * The data returned from a thread fetch that returns multiple threads.\n   * @typedef {Object} FetchedThreads\n   * @property {Collection<Snowflake, ThreadChannel>} threads The threads that were fetched, with any members returned\n   * @property {?boolean} hasMore Whether there are potentially additional threads that require a subsequent call\n   */\n\n  /**\n   * Obtains a set of archived threads from Discord, requires `READ_MESSAGE_HISTORY` in the parent channel.\n   * @param {FetchArchivedThreadOptions} [options] The options to fetch archived threads\n   * @param {boolean} [cache=true] Whether to cache the new thread objects if they aren't already\n   * @returns {Promise<FetchedThreads>}\n   */\n\n\n  async fetchArchived() {\n    let {\n      type = 'public',\n      fetchAll = false,\n      before,\n      limit\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let path = this.client.api.channels(this.channel.id);\n\n    if (type === 'private' && !fetchAll) {\n      path = path.users('@me');\n    }\n\n    let timestamp;\n    let id;\n\n    if (typeof before !== 'undefined') {\n      if (before instanceof ThreadChannel || /^\\d{16,19}$/.test(String(before))) {\n        id = this.resolveId(before);\n        timestamp = this.resolve(before)?.archivedAt?.toISOString();\n      } else {\n        try {\n          timestamp = new Date(before).toISOString();\n        } catch {\n          throw new TypeError('INVALID_TYPE', 'before', 'DateResolvable or ThreadChannelResolvable');\n        }\n      }\n    }\n\n    const raw = await path.threads.archived(type).get({\n      query: {\n        before: type === 'private' && !fetchAll ? id : timestamp,\n        limit\n      }\n    });\n    return this.constructor._mapThreads(raw, this.client, {\n      parent: this.channel,\n      cache\n    });\n  }\n  /**\n   * Obtains the accessible active threads from Discord, requires `READ_MESSAGE_HISTORY` in the parent channel.\n   * @param {boolean} [cache=true] Whether to cache the new thread objects if they aren't already\n   * @returns {Promise<FetchedThreads>}\n   */\n\n\n  async fetchActive() {\n    let cache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    const raw = await this.client.api.guilds(this.channel.guild.id).threads.active.get();\n    return this.constructor._mapThreads(raw, this.client, {\n      parent: this.channel,\n      cache\n    });\n  }\n\n  static _mapThreads(rawThreads, client, _ref) {\n    let {\n      parent,\n      guild,\n      cache\n    } = _ref;\n    const threads = rawThreads.threads.reduce((coll, raw) => {\n      const thread = client.channels._add(raw, guild ?? parent?.guild, {\n        cache\n      });\n\n      if (parent && thread.parentId !== parent.id) return coll;\n      return coll.set(thread.id, thread);\n    }, new Collection()); // Discord sends the thread id as id in this object\n\n    for (const rawMember of rawThreads.members) client.channels.cache.get(rawMember.id)?.members._add(rawMember);\n\n    return {\n      threads,\n      hasMore: rawThreads.has_more ?? false\n    };\n  }\n\n}\n\nmodule.exports = ThreadManager;","map":{"version":3,"names":["Collection","require","CachedManager","TypeError","ThreadChannel","ChannelTypes","ThreadManager","constructor","channel","iterable","client","_add","thread","existing","cache","get","id","set","create","name","autoArchiveDuration","defaultAutoArchiveDuration","startMessage","type","invitable","reason","rateLimitPerUser","path","api","channels","resolvedType","GUILD_NEWS_THREAD","GUILD_PUBLIC_THREAD","startMessageId","messages","resolveId","guild","features","includes","data","threads","post","auto_archive_duration","GUILD_PRIVATE_THREAD","undefined","rate_limit_per_user","actions","ThreadCreate","handle","fetch","options","force","fetchActive","archived","fetchArchived","fetchAll","before","limit","users","timestamp","test","String","resolve","archivedAt","toISOString","Date","raw","query","_mapThreads","parent","guilds","active","rawThreads","reduce","coll","parentId","rawMember","members","hasMore","has_more","module","exports"],"sources":["C:/Users/xsxsam/node_modules/discord.js/src/managers/ThreadManager.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst CachedManager = require('./CachedManager');\nconst { TypeError } = require('../errors');\nconst ThreadChannel = require('../structures/ThreadChannel');\nconst { ChannelTypes } = require('../util/Constants');\n\n/**\n * Manages API methods for {@link ThreadChannel} objects and stores their cache.\n * @extends {CachedManager}\n */\nclass ThreadManager extends CachedManager {\n  constructor(channel, iterable) {\n    super(channel.client, ThreadChannel, iterable);\n\n    /**\n     * The channel this Manager belongs to\n     * @type {NewsChannel|TextChannel}\n     */\n    this.channel = channel;\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, ThreadChannel>}\n   * @name ThreadManager#cache\n   */\n\n  _add(thread) {\n    const existing = this.cache.get(thread.id);\n    if (existing) return existing;\n    this.cache.set(thread.id, thread);\n    return thread;\n  }\n\n  /**\n   * Data that can be resolved to a Thread Channel object. This can be:\n   * * A ThreadChannel object\n   * * A Snowflake\n   * @typedef {ThreadChannel|Snowflake} ThreadChannelResolvable\n   */\n\n  /**\n   * Resolves a {@link ThreadChannelResolvable} to a {@link ThreadChannel} object.\n   * @method resolve\n   * @memberof ThreadManager\n   * @instance\n   * @param {ThreadChannelResolvable} thread The ThreadChannel resolvable to resolve\n   * @returns {?ThreadChannel}\n   */\n\n  /**\n   * Resolves a {@link ThreadChannelResolvable} to a {@link ThreadChannel} id.\n   * @method resolveId\n   * @memberof ThreadManager\n   * @instance\n   * @param {ThreadChannelResolvable} thread The ThreadChannel resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Options for creating a thread. <warn>Only one of `startMessage` or `type` can be defined.</warn>\n   * @typedef {StartThreadOptions} ThreadCreateOptions\n   * @property {MessageResolvable} [startMessage] The message to start a thread from. <warn>If this is defined then type\n   * of thread gets automatically defined and cannot be changed. The provided `type` field will be ignored</warn>\n   * @property {ThreadChannelTypes|number} [type] The type of thread to create. Defaults to `GUILD_PUBLIC_THREAD` if\n   * created in a {@link TextChannel} <warn>When creating threads in a {@link NewsChannel} this is ignored and is always\n   * `GUILD_NEWS_THREAD`</warn>\n   * @property {boolean} [invitable] Whether non-moderators can add other non-moderators to the thread\n   * <info>Can only be set when type will be `GUILD_PRIVATE_THREAD`</info>\n   * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the new channel in seconds\n   */\n\n  /**\n   * Creates a new thread in the channel.\n   * @param {ThreadCreateOptions} [options] Options to create a new thread\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Create a new public thread\n   * channel.threads\n   *   .create({\n   *     name: 'food-talk',\n   *     autoArchiveDuration: 60,\n   *     reason: 'Needed a separate thread for food',\n   *   })\n   *   .then(threadChannel => console.log(threadChannel))\n   *   .catch(console.error);\n   * @example\n   * // Create a new private thread\n   * channel.threads\n   *   .create({\n   *      name: 'mod-talk',\n   *      autoArchiveDuration: 60,\n   *      type: 'GUILD_PRIVATE_THREAD',\n   *      reason: 'Needed a separate thread for moderation',\n   *    })\n   *   .then(threadChannel => console.log(threadChannel))\n   *   .catch(console.error);\n   */\n  async create({\n    name,\n    autoArchiveDuration = this.channel.defaultAutoArchiveDuration,\n    startMessage,\n    type,\n    invitable,\n    reason,\n    rateLimitPerUser,\n  } = {}) {\n    let path = this.client.api.channels(this.channel.id);\n    if (type && typeof type !== 'string' && typeof type !== 'number') {\n      throw new TypeError('INVALID_TYPE', 'type', 'ThreadChannelType or Number');\n    }\n    let resolvedType =\n      this.channel.type === 'GUILD_NEWS' ? ChannelTypes.GUILD_NEWS_THREAD : ChannelTypes.GUILD_PUBLIC_THREAD;\n    if (startMessage) {\n      const startMessageId = this.channel.messages.resolveId(startMessage);\n      if (!startMessageId) throw new TypeError('INVALID_TYPE', 'startMessage', 'MessageResolvable');\n      path = path.messages(startMessageId);\n    } else if (this.channel.type !== 'GUILD_NEWS') {\n      resolvedType = typeof type === 'string' ? ChannelTypes[type] : type ?? resolvedType;\n    }\n    if (autoArchiveDuration === 'MAX') {\n      autoArchiveDuration = 1440;\n      if (this.channel.guild.features.includes('SEVEN_DAY_THREAD_ARCHIVE')) {\n        autoArchiveDuration = 10080;\n      } else if (this.channel.guild.features.includes('THREE_DAY_THREAD_ARCHIVE')) {\n        autoArchiveDuration = 4320;\n      }\n    }\n\n    const data = await path.threads.post({\n      data: {\n        name,\n        auto_archive_duration: autoArchiveDuration,\n        type: resolvedType,\n        invitable: resolvedType === ChannelTypes.GUILD_PRIVATE_THREAD ? invitable : undefined,\n        rate_limit_per_user: rateLimitPerUser,\n      },\n      reason,\n    });\n\n    return this.client.actions.ThreadCreate.handle(data).thread;\n  }\n\n  /**\n   * The options for fetching multiple threads, the properties are mutually exclusive\n   * @typedef {Object} FetchThreadsOptions\n   * @property {FetchArchivedThreadOptions} [archived] The options used to fetch archived threads\n   * @property {boolean} [active] When true, fetches active threads. <warn>If `archived` is set, this is ignored!</warn>\n   */\n\n  /**\n   * Obtains a thread from Discord, or the channel cache if it's already available.\n   * @param {ThreadChannelResolvable|FetchThreadsOptions} [options] The options to fetch threads. If it is a\n   * ThreadChannelResolvable then the specified thread will be fetched. Fetches all active threads if `undefined`\n   * @param {BaseFetchOptions} [cacheOptions] Additional options for this fetch. <warn>The `force` field gets ignored\n   * if `options` is not a {@link ThreadChannelResolvable}</warn>\n   * @returns {Promise<?(ThreadChannel|FetchedThreads)>}\n   * @example\n   * // Fetch a thread by its id\n   * channel.threads.fetch('831955138126104859')\n   *   .then(channel => console.log(channel.name))\n   *   .catch(console.error);\n   */\n  fetch(options, { cache = true, force = false } = {}) {\n    if (!options) return this.fetchActive(cache);\n    const channel = this.client.channels.resolveId(options);\n    if (channel) return this.client.channels.fetch(channel, cache, force);\n    if (options.archived) {\n      return this.fetchArchived(options.archived, cache);\n    }\n    return this.fetchActive(cache);\n  }\n\n  /**\n   * Data that can be resolved to a Date object. This can be:\n   * * A Date object\n   * * A number representing a timestamp\n   * * An [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) string\n   * @typedef {Date|number|string} DateResolvable\n   */\n\n  /**\n   * The options used to fetch archived threads.\n   * @typedef {Object} FetchArchivedThreadOptions\n   * @property {string} [type='public'] The type of threads to fetch, either `public` or `private`\n   * @property {boolean} [fetchAll=false] Whether to fetch **all** archived threads when type is `private`.\n   * Requires `MANAGE_THREADS` if true\n   * @property {DateResolvable|ThreadChannelResolvable} [before] Only return threads that were created before this Date\n   * or Snowflake. <warn>Must be a {@link ThreadChannelResolvable} when type is `private` and fetchAll is `false`</warn>\n   * @property {number} [limit] Maximum number of threads to return\n   */\n\n  /**\n   * The data returned from a thread fetch that returns multiple threads.\n   * @typedef {Object} FetchedThreads\n   * @property {Collection<Snowflake, ThreadChannel>} threads The threads that were fetched, with any members returned\n   * @property {?boolean} hasMore Whether there are potentially additional threads that require a subsequent call\n   */\n\n  /**\n   * Obtains a set of archived threads from Discord, requires `READ_MESSAGE_HISTORY` in the parent channel.\n   * @param {FetchArchivedThreadOptions} [options] The options to fetch archived threads\n   * @param {boolean} [cache=true] Whether to cache the new thread objects if they aren't already\n   * @returns {Promise<FetchedThreads>}\n   */\n  async fetchArchived({ type = 'public', fetchAll = false, before, limit } = {}, cache = true) {\n    let path = this.client.api.channels(this.channel.id);\n    if (type === 'private' && !fetchAll) {\n      path = path.users('@me');\n    }\n    let timestamp;\n    let id;\n    if (typeof before !== 'undefined') {\n      if (before instanceof ThreadChannel || /^\\d{16,19}$/.test(String(before))) {\n        id = this.resolveId(before);\n        timestamp = this.resolve(before)?.archivedAt?.toISOString();\n      } else {\n        try {\n          timestamp = new Date(before).toISOString();\n        } catch {\n          throw new TypeError('INVALID_TYPE', 'before', 'DateResolvable or ThreadChannelResolvable');\n        }\n      }\n    }\n    const raw = await path.threads\n      .archived(type)\n      .get({ query: { before: type === 'private' && !fetchAll ? id : timestamp, limit } });\n    return this.constructor._mapThreads(raw, this.client, { parent: this.channel, cache });\n  }\n\n  /**\n   * Obtains the accessible active threads from Discord, requires `READ_MESSAGE_HISTORY` in the parent channel.\n   * @param {boolean} [cache=true] Whether to cache the new thread objects if they aren't already\n   * @returns {Promise<FetchedThreads>}\n   */\n  async fetchActive(cache = true) {\n    const raw = await this.client.api.guilds(this.channel.guild.id).threads.active.get();\n    return this.constructor._mapThreads(raw, this.client, { parent: this.channel, cache });\n  }\n\n  static _mapThreads(rawThreads, client, { parent, guild, cache }) {\n    const threads = rawThreads.threads.reduce((coll, raw) => {\n      const thread = client.channels._add(raw, guild ?? parent?.guild, { cache });\n      if (parent && thread.parentId !== parent.id) return coll;\n      return coll.set(thread.id, thread);\n    }, new Collection());\n    // Discord sends the thread id as id in this object\n    for (const rawMember of rawThreads.members) client.channels.cache.get(rawMember.id)?.members._add(rawMember);\n    return {\n      threads,\n      hasMore: rawThreads.has_more ?? false,\n    };\n  }\n}\n\nmodule.exports = ThreadManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}