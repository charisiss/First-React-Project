{"ast":null,"code":"'use strict';\n\nconst {\n  setInterval\n} = require('node:timers');\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst {\n  _cleanupSymbol\n} = require('./Constants.js');\n\nconst Sweepers = require('./Sweepers.js');\n\nconst {\n  TypeError\n} = require('../errors/DJSError.js');\n/**\n * @typedef {Function} SweepFilter\n * @param {LimitedCollection} collection The collection being swept\n * @returns {Function|null} Return `null` to skip sweeping, otherwise a function passed to `sweep()`,\n * See {@link [Collection#sweep](https://discord.js.org/#/docs/collection/main/class/Collection?scrollTo=sweep)}\n * for the definition of this function.\n */\n\n/**\n * Options for defining the behavior of a LimitedCollection\n * @typedef {Object} LimitedCollectionOptions\n * @property {?number} [maxSize=Infinity] The maximum size of the Collection\n * @property {?Function} [keepOverLimit=null] A function, which is passed the value and key of an entry, ran to decide\n * to keep an entry past the maximum size\n * @property {?SweepFilter} [sweepFilter=null] DEPRECATED: There is no direct alternative to this,\n * however most of its purpose is fulfilled by {@link Client#sweepers}\n * A function ran every `sweepInterval` to determine how to sweep\n * @property {?number} [sweepInterval=0] DEPRECATED: There is no direct alternative to this,\n * however most of its purpose is fulfilled by {@link Client#sweepers}\n * How frequently, in seconds, to sweep the collection.\n */\n\n/**\n * A Collection which holds a max amount of entries and sweeps periodically.\n * @extends {Collection}\n * @param {LimitedCollectionOptions} [options={}] Options for constructing the Collection.\n * @param {Iterable} [iterable=null] Optional entries passed to the Map constructor.\n */\n\n\nclass LimitedCollection extends Collection {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let iterable = arguments.length > 1 ? arguments[1] : undefined;\n\n    if (typeof options !== 'object' || options === null) {\n      throw new TypeError('INVALID_TYPE', 'options', 'object', true);\n    }\n\n    const {\n      maxSize = Infinity,\n      keepOverLimit = null,\n      sweepInterval = 0,\n      sweepFilter = null\n    } = options;\n\n    if (typeof maxSize !== 'number') {\n      throw new TypeError('INVALID_TYPE', 'maxSize', 'number');\n    }\n\n    if (keepOverLimit !== null && typeof keepOverLimit !== 'function') {\n      throw new TypeError('INVALID_TYPE', 'keepOverLimit', 'function');\n    }\n\n    if (typeof sweepInterval !== 'number') {\n      throw new TypeError('INVALID_TYPE', 'sweepInterval', 'number');\n    }\n\n    if (sweepFilter !== null && typeof sweepFilter !== 'function') {\n      throw new TypeError('INVALID_TYPE', 'sweepFilter', 'function');\n    }\n\n    super(iterable);\n    /**\n     * The max size of the Collection.\n     * @type {number}\n     */\n\n    this.maxSize = maxSize;\n    /**\n     * A function called to check if an entry should be kept when the Collection is at max size.\n     * @type {?Function}\n     */\n\n    this.keepOverLimit = keepOverLimit;\n    /**\n     * A function called every sweep interval that returns a function passed to `sweep`.\n     * @deprecated in favor of {@link Client#sweepers}\n     * @type {?SweepFilter}\n     */\n\n    this.sweepFilter = sweepFilter;\n    /**\n     * The id of the interval being used to sweep.\n     * @deprecated in favor of {@link Client#sweepers}\n     * @type {?Timeout}\n     */\n\n    this.interval = sweepInterval > 0 && sweepInterval !== Infinity && sweepFilter ? setInterval(() => {\n      const sweepFn = this.sweepFilter(this);\n      if (sweepFn === null) return;\n      if (typeof sweepFn !== 'function') throw new TypeError('SWEEP_FILTER_RETURN');\n      this.sweep(sweepFn);\n    }, sweepInterval * 1_000).unref() : null;\n  }\n\n  set(key, value) {\n    if (this.maxSize === 0) return this;\n\n    if (this.size >= this.maxSize && !this.has(key)) {\n      for (const [k, v] of this.entries()) {\n        const keep = this.keepOverLimit?.(v, k, this) ?? false;\n\n        if (!keep) {\n          this.delete(k);\n          break;\n        }\n      }\n    }\n\n    return super.set(key, value);\n  }\n  /**\n   * Create a sweepFilter function that uses a lifetime to determine sweepability.\n   * @param {LifetimeFilterOptions} [options={}] The options used to generate the filter function\n   * @deprecated Use {@link Sweepers.filterByLifetime} instead\n   * @returns {SweepFilter}\n   */\n\n\n  static filterByLifetime() {\n    let {\n      lifetime = 14400,\n      getComparisonTimestamp = e => e?.createdTimestamp,\n      excludeFromSweep = () => false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return Sweepers.filterByLifetime({\n      lifetime,\n      getComparisonTimestamp,\n      excludeFromSweep\n    });\n  }\n\n  [_cleanupSymbol]() {\n    return this.interval ? () => clearInterval(this.interval) : null;\n  }\n\n  static get [Symbol.species]() {\n    return Collection;\n  }\n\n}\n\nmodule.exports = LimitedCollection;","map":{"version":3,"names":["setInterval","require","Collection","_cleanupSymbol","Sweepers","TypeError","LimitedCollection","constructor","options","iterable","maxSize","Infinity","keepOverLimit","sweepInterval","sweepFilter","interval","sweepFn","sweep","unref","set","key","value","size","has","k","v","entries","keep","delete","filterByLifetime","lifetime","getComparisonTimestamp","e","createdTimestamp","excludeFromSweep","clearInterval","Symbol","species","module","exports"],"sources":["C:/Users/xsxsam/node_modules/discord.js/src/util/LimitedCollection.js"],"sourcesContent":["'use strict';\n\nconst { setInterval } = require('node:timers');\nconst { Collection } = require('@discordjs/collection');\nconst { _cleanupSymbol } = require('./Constants.js');\nconst Sweepers = require('./Sweepers.js');\nconst { TypeError } = require('../errors/DJSError.js');\n\n/**\n * @typedef {Function} SweepFilter\n * @param {LimitedCollection} collection The collection being swept\n * @returns {Function|null} Return `null` to skip sweeping, otherwise a function passed to `sweep()`,\n * See {@link [Collection#sweep](https://discord.js.org/#/docs/collection/main/class/Collection?scrollTo=sweep)}\n * for the definition of this function.\n */\n\n/**\n * Options for defining the behavior of a LimitedCollection\n * @typedef {Object} LimitedCollectionOptions\n * @property {?number} [maxSize=Infinity] The maximum size of the Collection\n * @property {?Function} [keepOverLimit=null] A function, which is passed the value and key of an entry, ran to decide\n * to keep an entry past the maximum size\n * @property {?SweepFilter} [sweepFilter=null] DEPRECATED: There is no direct alternative to this,\n * however most of its purpose is fulfilled by {@link Client#sweepers}\n * A function ran every `sweepInterval` to determine how to sweep\n * @property {?number} [sweepInterval=0] DEPRECATED: There is no direct alternative to this,\n * however most of its purpose is fulfilled by {@link Client#sweepers}\n * How frequently, in seconds, to sweep the collection.\n */\n\n/**\n * A Collection which holds a max amount of entries and sweeps periodically.\n * @extends {Collection}\n * @param {LimitedCollectionOptions} [options={}] Options for constructing the Collection.\n * @param {Iterable} [iterable=null] Optional entries passed to the Map constructor.\n */\nclass LimitedCollection extends Collection {\n  constructor(options = {}, iterable) {\n    if (typeof options !== 'object' || options === null) {\n      throw new TypeError('INVALID_TYPE', 'options', 'object', true);\n    }\n    const { maxSize = Infinity, keepOverLimit = null, sweepInterval = 0, sweepFilter = null } = options;\n\n    if (typeof maxSize !== 'number') {\n      throw new TypeError('INVALID_TYPE', 'maxSize', 'number');\n    }\n    if (keepOverLimit !== null && typeof keepOverLimit !== 'function') {\n      throw new TypeError('INVALID_TYPE', 'keepOverLimit', 'function');\n    }\n    if (typeof sweepInterval !== 'number') {\n      throw new TypeError('INVALID_TYPE', 'sweepInterval', 'number');\n    }\n    if (sweepFilter !== null && typeof sweepFilter !== 'function') {\n      throw new TypeError('INVALID_TYPE', 'sweepFilter', 'function');\n    }\n\n    super(iterable);\n\n    /**\n     * The max size of the Collection.\n     * @type {number}\n     */\n    this.maxSize = maxSize;\n\n    /**\n     * A function called to check if an entry should be kept when the Collection is at max size.\n     * @type {?Function}\n     */\n    this.keepOverLimit = keepOverLimit;\n\n    /**\n     * A function called every sweep interval that returns a function passed to `sweep`.\n     * @deprecated in favor of {@link Client#sweepers}\n     * @type {?SweepFilter}\n     */\n    this.sweepFilter = sweepFilter;\n\n    /**\n     * The id of the interval being used to sweep.\n     * @deprecated in favor of {@link Client#sweepers}\n     * @type {?Timeout}\n     */\n    this.interval =\n      sweepInterval > 0 && sweepInterval !== Infinity && sweepFilter\n        ? setInterval(() => {\n            const sweepFn = this.sweepFilter(this);\n            if (sweepFn === null) return;\n            if (typeof sweepFn !== 'function') throw new TypeError('SWEEP_FILTER_RETURN');\n            this.sweep(sweepFn);\n          }, sweepInterval * 1_000).unref()\n        : null;\n  }\n\n  set(key, value) {\n    if (this.maxSize === 0) return this;\n    if (this.size >= this.maxSize && !this.has(key)) {\n      for (const [k, v] of this.entries()) {\n        const keep = this.keepOverLimit?.(v, k, this) ?? false;\n        if (!keep) {\n          this.delete(k);\n          break;\n        }\n      }\n    }\n    return super.set(key, value);\n  }\n\n  /**\n   * Create a sweepFilter function that uses a lifetime to determine sweepability.\n   * @param {LifetimeFilterOptions} [options={}] The options used to generate the filter function\n   * @deprecated Use {@link Sweepers.filterByLifetime} instead\n   * @returns {SweepFilter}\n   */\n  static filterByLifetime({\n    lifetime = 14400,\n    getComparisonTimestamp = e => e?.createdTimestamp,\n    excludeFromSweep = () => false,\n  } = {}) {\n    return Sweepers.filterByLifetime({ lifetime, getComparisonTimestamp, excludeFromSweep });\n  }\n\n  [_cleanupSymbol]() {\n    return this.interval ? () => clearInterval(this.interval) : null;\n  }\n\n  static get [Symbol.species]() {\n    return Collection;\n  }\n}\n\nmodule.exports = LimitedCollection;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}