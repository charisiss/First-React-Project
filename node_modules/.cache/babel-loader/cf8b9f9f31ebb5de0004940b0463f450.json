{"ast":null,"code":"'use strict';\n\nconst Collector = require('./interfaces/Collector');\n\nconst {\n  Events\n} = require('../util/Constants');\n/**\n * @typedef {CollectorOptions} MessageCollectorOptions\n * @property {number} max The maximum amount of messages to collect\n * @property {number} maxProcessed The maximum amount of messages to process\n */\n\n/**\n * Collects messages on a channel.\n * Will automatically stop if the channel ({@link Client#event:channelDelete channelDelete}),\n * thread ({@link Client#event:threadDelete threadDelete}), or\n * guild ({@link Client#event:guildDelete guildDelete}) is deleted.\n * @extends {Collector}\n */\n\n\nclass MessageCollector extends Collector {\n  /**\n   * @param {TextBasedChannels} channel The channel\n   * @param {MessageCollectorOptions} options The options to be applied to this collector\n   * @emits MessageCollector#message\n   */\n  constructor(channel) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(channel.client, options);\n    /**\n     * The channel\n     * @type {TextBasedChannels}\n     */\n\n    this.channel = channel;\n    /**\n     * Total number of messages that were received in the channel during message collection\n     * @type {number}\n     */\n\n    this.received = 0;\n\n    const bulkDeleteListener = messages => {\n      for (const message of messages.values()) this.handleDispose(message);\n    };\n\n    this._handleChannelDeletion = this._handleChannelDeletion.bind(this);\n    this._handleThreadDeletion = this._handleThreadDeletion.bind(this);\n    this._handleGuildDeletion = this._handleGuildDeletion.bind(this);\n    this.client.incrementMaxListeners();\n    this.client.on(Events.MESSAGE_CREATE, this.handleCollect);\n    this.client.on(Events.MESSAGE_DELETE, this.handleDispose);\n    this.client.on(Events.MESSAGE_BULK_DELETE, bulkDeleteListener);\n    this.client.on(Events.CHANNEL_DELETE, this._handleChannelDeletion);\n    this.client.on(Events.THREAD_DELETE, this._handleThreadDeletion);\n    this.client.on(Events.GUILD_DELETE, this._handleGuildDeletion);\n    this.once('end', () => {\n      this.client.removeListener(Events.MESSAGE_CREATE, this.handleCollect);\n      this.client.removeListener(Events.MESSAGE_DELETE, this.handleDispose);\n      this.client.removeListener(Events.MESSAGE_BULK_DELETE, bulkDeleteListener);\n      this.client.removeListener(Events.CHANNEL_DELETE, this._handleChannelDeletion);\n      this.client.removeListener(Events.THREAD_DELETE, this._handleThreadDeletion);\n      this.client.removeListener(Events.GUILD_DELETE, this._handleGuildDeletion);\n      this.client.decrementMaxListeners();\n    });\n  }\n  /**\n   * Handles a message for possible collection.\n   * @param {Message} message The message that could be collected\n   * @returns {?Snowflake}\n   * @private\n   */\n\n\n  collect(message) {\n    /**\n     * Emitted whenever a message is collected.\n     * @event MessageCollector#collect\n     * @param {Message} message The message that was collected\n     */\n    if (message.channelId !== this.channel.id) return null;\n    this.received++;\n    return message.id;\n  }\n  /**\n   * Handles a message for possible disposal.\n   * @param {Message} message The message that could be disposed of\n   * @returns {?Snowflake}\n   */\n\n\n  dispose(message) {\n    /**\n     * Emitted whenever a message is disposed of.\n     * @event MessageCollector#dispose\n     * @param {Message} message The message that was disposed of\n     */\n    return message.channelId === this.channel.id ? message.id : null;\n  }\n  /**\n   * The reason this collector has ended with, or null if it hasn't ended yet\n   * @type {?string}\n   * @readonly\n   */\n\n\n  get endReason() {\n    if (this.options.max && this.collected.size >= this.options.max) return 'limit';\n    if (this.options.maxProcessed && this.received === this.options.maxProcessed) return 'processedLimit';\n    return null;\n  }\n  /**\n   * Handles checking if the channel has been deleted, and if so, stops the collector with the reason 'channelDelete'.\n   * @private\n   * @param {GuildChannel} channel The channel that was deleted\n   * @returns {void}\n   */\n\n\n  _handleChannelDeletion(channel) {\n    if (channel.id === this.channel.id || channel.id === this.channel.parentId) {\n      this.stop('channelDelete');\n    }\n  }\n  /**\n   * Handles checking if the thread has been deleted, and if so, stops the collector with the reason 'threadDelete'.\n   * @private\n   * @param {ThreadChannel} thread The thread that was deleted\n   * @returns {void}\n   */\n\n\n  _handleThreadDeletion(thread) {\n    if (thread.id === this.channel.id) {\n      this.stop('threadDelete');\n    }\n  }\n  /**\n   * Handles checking if the guild has been deleted, and if so, stops the collector with the reason 'guildDelete'.\n   * @private\n   * @param {Guild} guild The guild that was deleted\n   * @returns {void}\n   */\n\n\n  _handleGuildDeletion(guild) {\n    if (guild.id === this.channel.guild?.id) {\n      this.stop('guildDelete');\n    }\n  }\n\n}\n\nmodule.exports = MessageCollector;","map":{"version":3,"names":["Collector","require","Events","MessageCollector","constructor","channel","options","client","received","bulkDeleteListener","messages","message","values","handleDispose","_handleChannelDeletion","bind","_handleThreadDeletion","_handleGuildDeletion","incrementMaxListeners","on","MESSAGE_CREATE","handleCollect","MESSAGE_DELETE","MESSAGE_BULK_DELETE","CHANNEL_DELETE","THREAD_DELETE","GUILD_DELETE","once","removeListener","decrementMaxListeners","collect","channelId","id","dispose","endReason","max","collected","size","maxProcessed","parentId","stop","thread","guild","module","exports"],"sources":["C:/Users/xsxsam/node_modules/discord.js/src/structures/MessageCollector.js"],"sourcesContent":["'use strict';\n\nconst Collector = require('./interfaces/Collector');\nconst { Events } = require('../util/Constants');\n\n/**\n * @typedef {CollectorOptions} MessageCollectorOptions\n * @property {number} max The maximum amount of messages to collect\n * @property {number} maxProcessed The maximum amount of messages to process\n */\n\n/**\n * Collects messages on a channel.\n * Will automatically stop if the channel ({@link Client#event:channelDelete channelDelete}),\n * thread ({@link Client#event:threadDelete threadDelete}), or\n * guild ({@link Client#event:guildDelete guildDelete}) is deleted.\n * @extends {Collector}\n */\nclass MessageCollector extends Collector {\n  /**\n   * @param {TextBasedChannels} channel The channel\n   * @param {MessageCollectorOptions} options The options to be applied to this collector\n   * @emits MessageCollector#message\n   */\n  constructor(channel, options = {}) {\n    super(channel.client, options);\n\n    /**\n     * The channel\n     * @type {TextBasedChannels}\n     */\n    this.channel = channel;\n\n    /**\n     * Total number of messages that were received in the channel during message collection\n     * @type {number}\n     */\n    this.received = 0;\n\n    const bulkDeleteListener = messages => {\n      for (const message of messages.values()) this.handleDispose(message);\n    };\n\n    this._handleChannelDeletion = this._handleChannelDeletion.bind(this);\n    this._handleThreadDeletion = this._handleThreadDeletion.bind(this);\n    this._handleGuildDeletion = this._handleGuildDeletion.bind(this);\n\n    this.client.incrementMaxListeners();\n    this.client.on(Events.MESSAGE_CREATE, this.handleCollect);\n    this.client.on(Events.MESSAGE_DELETE, this.handleDispose);\n    this.client.on(Events.MESSAGE_BULK_DELETE, bulkDeleteListener);\n    this.client.on(Events.CHANNEL_DELETE, this._handleChannelDeletion);\n    this.client.on(Events.THREAD_DELETE, this._handleThreadDeletion);\n    this.client.on(Events.GUILD_DELETE, this._handleGuildDeletion);\n\n    this.once('end', () => {\n      this.client.removeListener(Events.MESSAGE_CREATE, this.handleCollect);\n      this.client.removeListener(Events.MESSAGE_DELETE, this.handleDispose);\n      this.client.removeListener(Events.MESSAGE_BULK_DELETE, bulkDeleteListener);\n      this.client.removeListener(Events.CHANNEL_DELETE, this._handleChannelDeletion);\n      this.client.removeListener(Events.THREAD_DELETE, this._handleThreadDeletion);\n      this.client.removeListener(Events.GUILD_DELETE, this._handleGuildDeletion);\n      this.client.decrementMaxListeners();\n    });\n  }\n\n  /**\n   * Handles a message for possible collection.\n   * @param {Message} message The message that could be collected\n   * @returns {?Snowflake}\n   * @private\n   */\n  collect(message) {\n    /**\n     * Emitted whenever a message is collected.\n     * @event MessageCollector#collect\n     * @param {Message} message The message that was collected\n     */\n    if (message.channelId !== this.channel.id) return null;\n    this.received++;\n    return message.id;\n  }\n\n  /**\n   * Handles a message for possible disposal.\n   * @param {Message} message The message that could be disposed of\n   * @returns {?Snowflake}\n   */\n  dispose(message) {\n    /**\n     * Emitted whenever a message is disposed of.\n     * @event MessageCollector#dispose\n     * @param {Message} message The message that was disposed of\n     */\n    return message.channelId === this.channel.id ? message.id : null;\n  }\n\n  /**\n   * The reason this collector has ended with, or null if it hasn't ended yet\n   * @type {?string}\n   * @readonly\n   */\n  get endReason() {\n    if (this.options.max && this.collected.size >= this.options.max) return 'limit';\n    if (this.options.maxProcessed && this.received === this.options.maxProcessed) return 'processedLimit';\n    return null;\n  }\n\n  /**\n   * Handles checking if the channel has been deleted, and if so, stops the collector with the reason 'channelDelete'.\n   * @private\n   * @param {GuildChannel} channel The channel that was deleted\n   * @returns {void}\n   */\n  _handleChannelDeletion(channel) {\n    if (channel.id === this.channel.id || channel.id === this.channel.parentId) {\n      this.stop('channelDelete');\n    }\n  }\n\n  /**\n   * Handles checking if the thread has been deleted, and if so, stops the collector with the reason 'threadDelete'.\n   * @private\n   * @param {ThreadChannel} thread The thread that was deleted\n   * @returns {void}\n   */\n  _handleThreadDeletion(thread) {\n    if (thread.id === this.channel.id) {\n      this.stop('threadDelete');\n    }\n  }\n\n  /**\n   * Handles checking if the guild has been deleted, and if so, stops the collector with the reason 'guildDelete'.\n   * @private\n   * @param {Guild} guild The guild that was deleted\n   * @returns {void}\n   */\n  _handleGuildDeletion(guild) {\n    if (guild.id === this.channel.guild?.id) {\n      this.stop('guildDelete');\n    }\n  }\n}\n\nmodule.exports = MessageCollector;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}