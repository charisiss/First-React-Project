{"ast":null,"code":"'use strict';\n\nconst {\n  Channel\n} = require('./Channel');\n\nconst TextBasedChannel = require('./interfaces/TextBasedChannel');\n\nconst {\n  RangeError\n} = require('../errors');\n\nconst MessageManager = require('../managers/MessageManager');\n\nconst ThreadMemberManager = require('../managers/ThreadMemberManager');\n\nconst Permissions = require('../util/Permissions');\n/**\n * Represents a thread channel on Discord.\n * @extends {Channel}\n * @implements {TextBasedChannel}\n */\n\n\nclass ThreadChannel extends Channel {\n  constructor(guild, data, client) {\n    let fromInteraction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    super(guild?.client ?? client, data, false);\n    /**\n     * The guild the thread is in\n     * @type {Guild}\n     */\n\n    this.guild = guild;\n    /**\n     * The id of the guild the channel is in\n     * @type {Snowflake}\n     */\n\n    this.guildId = guild?.id ?? data.guild_id;\n    /**\n     * A manager of the messages sent to this thread\n     * @type {MessageManager}\n     */\n\n    this.messages = new MessageManager(this);\n    /**\n     * A manager of the members that are part of this thread\n     * @type {ThreadMemberManager}\n     */\n\n    this.members = new ThreadMemberManager(this);\n    if (data) this._patch(data, fromInteraction);\n  }\n\n  _patch(data) {\n    let partial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    super._patch(data);\n\n    if ('name' in data) {\n      /**\n       * The name of the thread\n       * @type {string}\n       */\n      this.name = data.name;\n    }\n\n    if ('guild_id' in data) {\n      this.guildId = data.guild_id;\n    }\n\n    if ('parent_id' in data) {\n      /**\n       * The id of the parent channel of this thread\n       * @type {?Snowflake}\n       */\n      this.parentId = data.parent_id;\n    } else {\n      this.parentId ??= null;\n    }\n\n    if ('thread_metadata' in data) {\n      /**\n       * Whether the thread is locked\n       * @type {?boolean}\n       */\n      this.locked = data.thread_metadata.locked ?? false;\n      /**\n       * Whether members without `MANAGE_THREADS` can invite other members without `MANAGE_THREADS`\n       * <info>Always `null` in public threads</info>\n       * @type {?boolean}\n       */\n\n      this.invitable = this.type === 'GUILD_PRIVATE_THREAD' ? data.thread_metadata.invitable ?? false : null;\n      /**\n       * Whether the thread is archived\n       * @type {?boolean}\n       */\n\n      this.archived = data.thread_metadata.archived;\n      /**\n       * The amount of time (in minutes) after which the thread will automatically archive in case of no recent activity\n       * @type {?number}\n       */\n\n      this.autoArchiveDuration = data.thread_metadata.auto_archive_duration;\n      /**\n       * The timestamp when the thread's archive status was last changed\n       * <info>If the thread was never archived or unarchived, this is the timestamp at which the thread was\n       * created</info>\n       * @type {?number}\n       */\n\n      this.archiveTimestamp = new Date(data.thread_metadata.archive_timestamp).getTime();\n    } else {\n      this.locked ??= null;\n      this.archived ??= null;\n      this.autoArchiveDuration ??= null;\n      this.archiveTimestamp ??= null;\n      this.invitable ??= null;\n    }\n\n    if ('owner_id' in data) {\n      /**\n       * The id of the member who created this thread\n       * @type {?Snowflake}\n       */\n      this.ownerId = data.owner_id;\n    } else {\n      this.ownerId ??= null;\n    }\n\n    if ('last_message_id' in data) {\n      /**\n       * The last message id sent in this thread, if one was sent\n       * @type {?Snowflake}\n       */\n      this.lastMessageId = data.last_message_id;\n    } else {\n      this.lastMessageId ??= null;\n    }\n\n    if ('last_pin_timestamp' in data) {\n      /**\n       * The timestamp when the last pinned message was pinned, if there was one\n       * @type {?number}\n       */\n      this.lastPinTimestamp = data.last_pin_timestamp ? new Date(data.last_pin_timestamp).getTime() : null;\n    } else {\n      this.lastPinTimestamp ??= null;\n    }\n\n    if ('rate_limit_per_user' in data || !partial) {\n      /**\n       * The rate limit per user (slowmode) for this thread in seconds\n       * @type {?number}\n       */\n      this.rateLimitPerUser = data.rate_limit_per_user ?? 0;\n    } else {\n      this.rateLimitPerUser ??= null;\n    }\n\n    if ('message_count' in data) {\n      /**\n       * The approximate count of messages in this thread\n       * <info>This stops counting at 50. If you need an approximate value higher than that, use\n       * `ThreadChannel#messages.cache.size`</info>\n       * @type {?number}\n       */\n      this.messageCount = data.message_count;\n    } else {\n      this.messageCount ??= null;\n    }\n\n    if ('member_count' in data) {\n      /**\n       * The approximate count of users in this thread\n       * <info>This stops counting at 50. If you need an approximate value higher than that, use\n       * `ThreadChannel#members.cache.size`</info>\n       * @type {?number}\n       */\n      this.memberCount = data.member_count;\n    } else {\n      this.memberCount ??= null;\n    }\n\n    if (data.member && this.client.user) this.members._add({\n      user_id: this.client.user.id,\n      ...data.member\n    });\n    if (data.messages) for (const message of data.messages) this.messages._add(message);\n  }\n  /**\n   * A collection of associated guild member objects of this thread's members\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n\n\n  get guildMembers() {\n    return this.members.cache.mapValues(member => member.guildMember);\n  }\n  /**\n   * The time at which this thread's archive status was last changed\n   * <info>If the thread was never archived or unarchived, this is the time at which the thread was created</info>\n   * @type {?Date}\n   * @readonly\n   */\n\n\n  get archivedAt() {\n    if (!this.archiveTimestamp) return null;\n    return new Date(this.archiveTimestamp);\n  }\n  /**\n   * The parent channel of this thread\n   * @type {?(NewsChannel|TextChannel)}\n   * @readonly\n   */\n\n\n  get parent() {\n    return this.guild.channels.resolve(this.parentId);\n  }\n  /**\n   * Makes the client user join the thread.\n   * @returns {Promise<ThreadChannel>}\n   */\n\n\n  async join() {\n    await this.members.add('@me');\n    return this;\n  }\n  /**\n   * Makes the client user leave the thread.\n   * @returns {Promise<ThreadChannel>}\n   */\n\n\n  async leave() {\n    await this.members.remove('@me');\n    return this;\n  }\n  /**\n   * Gets the overall set of permissions for a member or role in this thread's parent channel, taking overwrites into\n   * account.\n   * @param {GuildMemberResolvable|RoleResolvable} memberOrRole The member or role to obtain the overall permissions for\n   * @param {boolean} [checkAdmin=true] Whether having `ADMINISTRATOR` will return all permissions\n   * @returns {?Readonly<Permissions>}\n   */\n\n\n  permissionsFor(memberOrRole, checkAdmin) {\n    return this.parent?.permissionsFor(memberOrRole, checkAdmin) ?? null;\n  }\n  /**\n   * Fetches the owner of this thread. If the thread member object isn't needed,\n   * use {@link ThreadChannel#ownerId} instead.\n   * @param {BaseFetchOptions} [options] The options for fetching the member\n   * @returns {Promise<?ThreadMember>}\n   */\n\n\n  async fetchOwner() {\n    let {\n      cache = true,\n      force = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!force) {\n      const existing = this.members.cache.get(this.ownerId);\n      if (existing) return existing;\n    } // We cannot fetch a single thread member, as of this commit's date, Discord API responds with 405\n\n\n    const members = await this.members.fetch(cache);\n    return members.get(this.ownerId) ?? null;\n  }\n  /**\n   * Fetches the message that started this thread, if any.\n   * <info>This only works when the thread started from a message in the parent channel, otherwise the promise will\n   * reject. If you just need the id of that message, use {@link ThreadChannel#id} instead.</info>\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<Message>}\n   */\n\n\n  fetchStarterMessage(options) {\n    return this.parent.messages.fetch(this.id, options);\n  }\n  /**\n   * The options used to edit a thread channel\n   * @typedef {Object} ThreadEditData\n   * @property {string} [name] The new name for the thread\n   * @property {boolean} [archived] Whether the thread is archived\n   * @property {ThreadAutoArchiveDuration} [autoArchiveDuration] The amount of time (in minutes) after which the thread\n   * should automatically archive in case of no recent activity\n   * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the thread in seconds\n   * @property {boolean} [locked] Whether the thread is locked\n   * @property {boolean} [invitable] Whether non-moderators can add other non-moderators to a thread\n   * <info>Can only be edited on `GUILD_PRIVATE_THREAD`</info>\n   */\n\n  /**\n   * Edits this thread.\n   * @param {ThreadEditData} data The new data for this thread\n   * @param {string} [reason] Reason for editing this thread\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Edit a thread\n   * thread.edit({ name: 'new-thread' })\n   *   .then(editedThread => console.log(editedThread))\n   *   .catch(console.error);\n   */\n\n\n  async edit(data, reason) {\n    let autoArchiveDuration = data.autoArchiveDuration;\n\n    if (data.autoArchiveDuration === 'MAX') {\n      autoArchiveDuration = 1440;\n\n      if (this.guild.features.includes('SEVEN_DAY_THREAD_ARCHIVE')) {\n        autoArchiveDuration = 10080;\n      } else if (this.guild.features.includes('THREE_DAY_THREAD_ARCHIVE')) {\n        autoArchiveDuration = 4320;\n      }\n    }\n\n    const newData = await this.client.api.channels(this.id).patch({\n      data: {\n        name: (data.name ?? this.name).trim(),\n        archived: data.archived,\n        auto_archive_duration: autoArchiveDuration,\n        rate_limit_per_user: data.rateLimitPerUser,\n        locked: data.locked,\n        invitable: this.type === 'GUILD_PRIVATE_THREAD' ? data.invitable : undefined\n      },\n      reason\n    });\n    return this.client.actions.ChannelUpdate.handle(newData).updated;\n  }\n  /**\n   * Sets whether the thread is archived.\n   * @param {boolean} [archived=true] Whether the thread is archived\n   * @param {string} [reason] Reason for archiving or unarchiving\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Archive the thread\n   * thread.setArchived(true)\n   *   .then(newThread => console.log(`Thread is now ${newThread.archived ? 'archived' : 'active'}`))\n   *   .catch(console.error);\n   */\n\n\n  setArchived() {\n    let archived = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let reason = arguments.length > 1 ? arguments[1] : undefined;\n    return this.edit({\n      archived\n    }, reason);\n  }\n  /**\n   * Sets the duration after which the thread will automatically archive in case of no recent activity.\n   * @param {ThreadAutoArchiveDuration} autoArchiveDuration The amount of time (in minutes) after which the thread\n   * should automatically archive in case of no recent activity\n   * @param {string} [reason] Reason for changing the auto archive duration\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Set the thread's auto archive time to 1 hour\n   * thread.setAutoArchiveDuration(60)\n   *   .then(newThread => {\n   *     console.log(`Thread will now archive after ${newThread.autoArchiveDuration} minutes of inactivity`);\n   *    });\n   *   .catch(console.error);\n   */\n\n\n  setAutoArchiveDuration(autoArchiveDuration, reason) {\n    return this.edit({\n      autoArchiveDuration\n    }, reason);\n  }\n  /**\n   * Sets whether members without the `MANAGE_THREADS` permission can invite other members without the\n   * `MANAGE_THREADS` permission to this thread.\n   * @param {boolean} [invitable=true] Whether non-moderators can invite non-moderators to this thread\n   * @param {string} [reason] Reason for changing invite\n   * @returns {Promise<ThreadChannel>}\n   */\n\n\n  setInvitable() {\n    let invitable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let reason = arguments.length > 1 ? arguments[1] : undefined;\n    if (this.type !== 'GUILD_PRIVATE_THREAD') return Promise.reject(new RangeError('THREAD_INVITABLE_TYPE', this.type));\n    return this.edit({\n      invitable\n    }, reason);\n  }\n  /**\n   * Sets whether the thread can be **unarchived** by anyone with `SEND_MESSAGES` permission.\n   * When a thread is locked only members with `MANAGE_THREADS` can unarchive it.\n   * @param {boolean} [locked=true] Whether the thread is locked\n   * @param {string} [reason] Reason for locking or unlocking the thread\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Set the thread to locked\n   * thread.setLocked(true)\n   *   .then(newThread => console.log(`Thread is now ${newThread.locked ? 'locked' : 'unlocked'}`))\n   *   .catch(console.error);\n   */\n\n\n  setLocked() {\n    let locked = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let reason = arguments.length > 1 ? arguments[1] : undefined;\n    return this.edit({\n      locked\n    }, reason);\n  }\n  /**\n   * Sets a new name for this thread.\n   * @param {string} name The new name for the thread\n   * @param {string} [reason] Reason for changing the thread's name\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Change the thread's name\n   * thread.setName('not_general')\n   *   .then(newThread => console.log(`Thread's new name is ${newThread.name}`))\n   *   .catch(console.error);\n   */\n\n\n  setName(name, reason) {\n    return this.edit({\n      name\n    }, reason);\n  }\n  /**\n   * Sets the rate limit per user (slowmode) for this thread.\n   * @param {number} rateLimitPerUser The new rate limit in seconds\n   * @param {string} [reason] Reason for changing the thread's rate limit\n   * @returns {Promise<ThreadChannel>}\n   */\n\n\n  setRateLimitPerUser(rateLimitPerUser, reason) {\n    return this.edit({\n      rateLimitPerUser\n    }, reason);\n  }\n  /**\n   * Whether the client user is a member of the thread.\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get joined() {\n    return this.members.cache.has(this.client.user?.id);\n  }\n  /**\n   * Whether the thread is editable by the client user (name, archived, autoArchiveDuration)\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get editable() {\n    return this.ownerId === this.client.user.id && (this.type !== 'GUILD_PRIVATE_THREAD' || this.joined) || this.manageable;\n  }\n  /**\n   * Whether the thread is joinable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get joinable() {\n    return !this.archived && !this.joined && this.permissionsFor(this.client.user)?.has(this.type === 'GUILD_PRIVATE_THREAD' ? Permissions.FLAGS.MANAGE_THREADS : Permissions.FLAGS.VIEW_CHANNEL, false);\n  }\n  /**\n   * Whether the thread is manageable by the client user, for deleting or editing rateLimitPerUser or locked.\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get manageable() {\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false; // This flag allows managing even if timed out\n\n    if (permissions.has(Permissions.FLAGS.ADMINISTRATOR, false)) return true;\n    return this.guild.me.communicationDisabledUntilTimestamp < Date.now() && permissions.has(Permissions.FLAGS.MANAGE_THREADS, false);\n  }\n  /**\n   * Whether the thread is viewable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get viewable() {\n    if (this.client.user.id === this.guild.ownerId) return true;\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    return permissions.has(Permissions.FLAGS.VIEW_CHANNEL, false);\n  }\n  /**\n   * Whether the client user can send messages in this thread\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get sendable() {\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false; // This flag allows sending even if timed out\n\n    if (permissions.has(Permissions.FLAGS.ADMINISTRATOR, false)) return true;\n    return !(this.archived && this.locked && !this.manageable) && (this.type !== 'GUILD_PRIVATE_THREAD' || this.joined || this.manageable) && permissions.has(Permissions.FLAGS.SEND_MESSAGES_IN_THREADS, false) && this.guild.me.communicationDisabledUntilTimestamp < Date.now();\n  }\n  /**\n   * Whether the thread is unarchivable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get unarchivable() {\n    return this.archived && (this.locked ? this.manageable : this.sendable);\n  }\n  /**\n   * Deletes this thread.\n   * @param {string} [reason] Reason for deleting this thread\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Delete the thread\n   * thread.delete('cleaning out old threads')\n   *   .then(deletedThread => console.log(deletedThread))\n   *   .catch(console.error);\n   */\n\n\n  async delete(reason) {\n    await this.client.api.channels(this.id).delete({\n      reason\n    });\n    return this;\n  } // These are here only for documentation purposes - they are implemented by TextBasedChannel\n\n  /* eslint-disable no-empty-function */\n\n\n  get lastMessage() {}\n\n  get lastPinAt() {}\n\n  send() {}\n\n  sendTyping() {}\n\n  createMessageCollector() {}\n\n  awaitMessages() {}\n\n  createMessageComponentCollector() {}\n\n  awaitMessageComponent() {}\n\n  bulkDelete() {}\n\n}\n\nTextBasedChannel.applyToClass(ThreadChannel, true);\nmodule.exports = ThreadChannel;","map":{"version":3,"names":["Channel","require","TextBasedChannel","RangeError","MessageManager","ThreadMemberManager","Permissions","ThreadChannel","constructor","guild","data","client","fromInteraction","guildId","id","guild_id","messages","members","_patch","partial","name","parentId","parent_id","locked","thread_metadata","invitable","type","archived","autoArchiveDuration","auto_archive_duration","archiveTimestamp","Date","archive_timestamp","getTime","ownerId","owner_id","lastMessageId","last_message_id","lastPinTimestamp","last_pin_timestamp","rateLimitPerUser","rate_limit_per_user","messageCount","message_count","memberCount","member_count","member","user","_add","user_id","message","guildMembers","cache","mapValues","guildMember","archivedAt","parent","channels","resolve","join","add","leave","remove","permissionsFor","memberOrRole","checkAdmin","fetchOwner","force","existing","get","fetch","fetchStarterMessage","options","edit","reason","features","includes","newData","api","patch","trim","undefined","actions","ChannelUpdate","handle","updated","setArchived","setAutoArchiveDuration","setInvitable","Promise","reject","setLocked","setName","setRateLimitPerUser","joined","has","editable","manageable","joinable","FLAGS","MANAGE_THREADS","VIEW_CHANNEL","permissions","ADMINISTRATOR","me","communicationDisabledUntilTimestamp","now","viewable","sendable","SEND_MESSAGES_IN_THREADS","unarchivable","delete","lastMessage","lastPinAt","send","sendTyping","createMessageCollector","awaitMessages","createMessageComponentCollector","awaitMessageComponent","bulkDelete","applyToClass","module","exports"],"sources":["C:/Users/xsxsam/node_modules/discord.js/src/structures/ThreadChannel.js"],"sourcesContent":["'use strict';\n\nconst { Channel } = require('./Channel');\nconst TextBasedChannel = require('./interfaces/TextBasedChannel');\nconst { RangeError } = require('../errors');\nconst MessageManager = require('../managers/MessageManager');\nconst ThreadMemberManager = require('../managers/ThreadMemberManager');\nconst Permissions = require('../util/Permissions');\n\n/**\n * Represents a thread channel on Discord.\n * @extends {Channel}\n * @implements {TextBasedChannel}\n */\nclass ThreadChannel extends Channel {\n  constructor(guild, data, client, fromInteraction = false) {\n    super(guild?.client ?? client, data, false);\n\n    /**\n     * The guild the thread is in\n     * @type {Guild}\n     */\n    this.guild = guild;\n\n    /**\n     * The id of the guild the channel is in\n     * @type {Snowflake}\n     */\n    this.guildId = guild?.id ?? data.guild_id;\n\n    /**\n     * A manager of the messages sent to this thread\n     * @type {MessageManager}\n     */\n    this.messages = new MessageManager(this);\n\n    /**\n     * A manager of the members that are part of this thread\n     * @type {ThreadMemberManager}\n     */\n    this.members = new ThreadMemberManager(this);\n    if (data) this._patch(data, fromInteraction);\n  }\n\n  _patch(data, partial = false) {\n    super._patch(data);\n\n    if ('name' in data) {\n      /**\n       * The name of the thread\n       * @type {string}\n       */\n      this.name = data.name;\n    }\n\n    if ('guild_id' in data) {\n      this.guildId = data.guild_id;\n    }\n\n    if ('parent_id' in data) {\n      /**\n       * The id of the parent channel of this thread\n       * @type {?Snowflake}\n       */\n      this.parentId = data.parent_id;\n    } else {\n      this.parentId ??= null;\n    }\n\n    if ('thread_metadata' in data) {\n      /**\n       * Whether the thread is locked\n       * @type {?boolean}\n       */\n      this.locked = data.thread_metadata.locked ?? false;\n\n      /**\n       * Whether members without `MANAGE_THREADS` can invite other members without `MANAGE_THREADS`\n       * <info>Always `null` in public threads</info>\n       * @type {?boolean}\n       */\n      this.invitable = this.type === 'GUILD_PRIVATE_THREAD' ? data.thread_metadata.invitable ?? false : null;\n\n      /**\n       * Whether the thread is archived\n       * @type {?boolean}\n       */\n      this.archived = data.thread_metadata.archived;\n\n      /**\n       * The amount of time (in minutes) after which the thread will automatically archive in case of no recent activity\n       * @type {?number}\n       */\n      this.autoArchiveDuration = data.thread_metadata.auto_archive_duration;\n\n      /**\n       * The timestamp when the thread's archive status was last changed\n       * <info>If the thread was never archived or unarchived, this is the timestamp at which the thread was\n       * created</info>\n       * @type {?number}\n       */\n      this.archiveTimestamp = new Date(data.thread_metadata.archive_timestamp).getTime();\n    } else {\n      this.locked ??= null;\n      this.archived ??= null;\n      this.autoArchiveDuration ??= null;\n      this.archiveTimestamp ??= null;\n      this.invitable ??= null;\n    }\n\n    if ('owner_id' in data) {\n      /**\n       * The id of the member who created this thread\n       * @type {?Snowflake}\n       */\n      this.ownerId = data.owner_id;\n    } else {\n      this.ownerId ??= null;\n    }\n\n    if ('last_message_id' in data) {\n      /**\n       * The last message id sent in this thread, if one was sent\n       * @type {?Snowflake}\n       */\n      this.lastMessageId = data.last_message_id;\n    } else {\n      this.lastMessageId ??= null;\n    }\n\n    if ('last_pin_timestamp' in data) {\n      /**\n       * The timestamp when the last pinned message was pinned, if there was one\n       * @type {?number}\n       */\n      this.lastPinTimestamp = data.last_pin_timestamp ? new Date(data.last_pin_timestamp).getTime() : null;\n    } else {\n      this.lastPinTimestamp ??= null;\n    }\n\n    if ('rate_limit_per_user' in data || !partial) {\n      /**\n       * The rate limit per user (slowmode) for this thread in seconds\n       * @type {?number}\n       */\n      this.rateLimitPerUser = data.rate_limit_per_user ?? 0;\n    } else {\n      this.rateLimitPerUser ??= null;\n    }\n\n    if ('message_count' in data) {\n      /**\n       * The approximate count of messages in this thread\n       * <info>This stops counting at 50. If you need an approximate value higher than that, use\n       * `ThreadChannel#messages.cache.size`</info>\n       * @type {?number}\n       */\n      this.messageCount = data.message_count;\n    } else {\n      this.messageCount ??= null;\n    }\n\n    if ('member_count' in data) {\n      /**\n       * The approximate count of users in this thread\n       * <info>This stops counting at 50. If you need an approximate value higher than that, use\n       * `ThreadChannel#members.cache.size`</info>\n       * @type {?number}\n       */\n      this.memberCount = data.member_count;\n    } else {\n      this.memberCount ??= null;\n    }\n\n    if (data.member && this.client.user) this.members._add({ user_id: this.client.user.id, ...data.member });\n    if (data.messages) for (const message of data.messages) this.messages._add(message);\n  }\n\n  /**\n   * A collection of associated guild member objects of this thread's members\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n  get guildMembers() {\n    return this.members.cache.mapValues(member => member.guildMember);\n  }\n\n  /**\n   * The time at which this thread's archive status was last changed\n   * <info>If the thread was never archived or unarchived, this is the time at which the thread was created</info>\n   * @type {?Date}\n   * @readonly\n   */\n  get archivedAt() {\n    if (!this.archiveTimestamp) return null;\n    return new Date(this.archiveTimestamp);\n  }\n\n  /**\n   * The parent channel of this thread\n   * @type {?(NewsChannel|TextChannel)}\n   * @readonly\n   */\n  get parent() {\n    return this.guild.channels.resolve(this.parentId);\n  }\n\n  /**\n   * Makes the client user join the thread.\n   * @returns {Promise<ThreadChannel>}\n   */\n  async join() {\n    await this.members.add('@me');\n    return this;\n  }\n\n  /**\n   * Makes the client user leave the thread.\n   * @returns {Promise<ThreadChannel>}\n   */\n  async leave() {\n    await this.members.remove('@me');\n    return this;\n  }\n\n  /**\n   * Gets the overall set of permissions for a member or role in this thread's parent channel, taking overwrites into\n   * account.\n   * @param {GuildMemberResolvable|RoleResolvable} memberOrRole The member or role to obtain the overall permissions for\n   * @param {boolean} [checkAdmin=true] Whether having `ADMINISTRATOR` will return all permissions\n   * @returns {?Readonly<Permissions>}\n   */\n  permissionsFor(memberOrRole, checkAdmin) {\n    return this.parent?.permissionsFor(memberOrRole, checkAdmin) ?? null;\n  }\n\n  /**\n   * Fetches the owner of this thread. If the thread member object isn't needed,\n   * use {@link ThreadChannel#ownerId} instead.\n   * @param {BaseFetchOptions} [options] The options for fetching the member\n   * @returns {Promise<?ThreadMember>}\n   */\n  async fetchOwner({ cache = true, force = false } = {}) {\n    if (!force) {\n      const existing = this.members.cache.get(this.ownerId);\n      if (existing) return existing;\n    }\n\n    // We cannot fetch a single thread member, as of this commit's date, Discord API responds with 405\n    const members = await this.members.fetch(cache);\n    return members.get(this.ownerId) ?? null;\n  }\n\n  /**\n   * Fetches the message that started this thread, if any.\n   * <info>This only works when the thread started from a message in the parent channel, otherwise the promise will\n   * reject. If you just need the id of that message, use {@link ThreadChannel#id} instead.</info>\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<Message>}\n   */\n  fetchStarterMessage(options) {\n    return this.parent.messages.fetch(this.id, options);\n  }\n\n  /**\n   * The options used to edit a thread channel\n   * @typedef {Object} ThreadEditData\n   * @property {string} [name] The new name for the thread\n   * @property {boolean} [archived] Whether the thread is archived\n   * @property {ThreadAutoArchiveDuration} [autoArchiveDuration] The amount of time (in minutes) after which the thread\n   * should automatically archive in case of no recent activity\n   * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the thread in seconds\n   * @property {boolean} [locked] Whether the thread is locked\n   * @property {boolean} [invitable] Whether non-moderators can add other non-moderators to a thread\n   * <info>Can only be edited on `GUILD_PRIVATE_THREAD`</info>\n   */\n\n  /**\n   * Edits this thread.\n   * @param {ThreadEditData} data The new data for this thread\n   * @param {string} [reason] Reason for editing this thread\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Edit a thread\n   * thread.edit({ name: 'new-thread' })\n   *   .then(editedThread => console.log(editedThread))\n   *   .catch(console.error);\n   */\n  async edit(data, reason) {\n    let autoArchiveDuration = data.autoArchiveDuration;\n    if (data.autoArchiveDuration === 'MAX') {\n      autoArchiveDuration = 1440;\n      if (this.guild.features.includes('SEVEN_DAY_THREAD_ARCHIVE')) {\n        autoArchiveDuration = 10080;\n      } else if (this.guild.features.includes('THREE_DAY_THREAD_ARCHIVE')) {\n        autoArchiveDuration = 4320;\n      }\n    }\n    const newData = await this.client.api.channels(this.id).patch({\n      data: {\n        name: (data.name ?? this.name).trim(),\n        archived: data.archived,\n        auto_archive_duration: autoArchiveDuration,\n        rate_limit_per_user: data.rateLimitPerUser,\n        locked: data.locked,\n        invitable: this.type === 'GUILD_PRIVATE_THREAD' ? data.invitable : undefined,\n      },\n      reason,\n    });\n\n    return this.client.actions.ChannelUpdate.handle(newData).updated;\n  }\n\n  /**\n   * Sets whether the thread is archived.\n   * @param {boolean} [archived=true] Whether the thread is archived\n   * @param {string} [reason] Reason for archiving or unarchiving\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Archive the thread\n   * thread.setArchived(true)\n   *   .then(newThread => console.log(`Thread is now ${newThread.archived ? 'archived' : 'active'}`))\n   *   .catch(console.error);\n   */\n  setArchived(archived = true, reason) {\n    return this.edit({ archived }, reason);\n  }\n\n  /**\n   * Sets the duration after which the thread will automatically archive in case of no recent activity.\n   * @param {ThreadAutoArchiveDuration} autoArchiveDuration The amount of time (in minutes) after which the thread\n   * should automatically archive in case of no recent activity\n   * @param {string} [reason] Reason for changing the auto archive duration\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Set the thread's auto archive time to 1 hour\n   * thread.setAutoArchiveDuration(60)\n   *   .then(newThread => {\n   *     console.log(`Thread will now archive after ${newThread.autoArchiveDuration} minutes of inactivity`);\n   *    });\n   *   .catch(console.error);\n   */\n  setAutoArchiveDuration(autoArchiveDuration, reason) {\n    return this.edit({ autoArchiveDuration }, reason);\n  }\n\n  /**\n   * Sets whether members without the `MANAGE_THREADS` permission can invite other members without the\n   * `MANAGE_THREADS` permission to this thread.\n   * @param {boolean} [invitable=true] Whether non-moderators can invite non-moderators to this thread\n   * @param {string} [reason] Reason for changing invite\n   * @returns {Promise<ThreadChannel>}\n   */\n  setInvitable(invitable = true, reason) {\n    if (this.type !== 'GUILD_PRIVATE_THREAD') return Promise.reject(new RangeError('THREAD_INVITABLE_TYPE', this.type));\n    return this.edit({ invitable }, reason);\n  }\n\n  /**\n   * Sets whether the thread can be **unarchived** by anyone with `SEND_MESSAGES` permission.\n   * When a thread is locked only members with `MANAGE_THREADS` can unarchive it.\n   * @param {boolean} [locked=true] Whether the thread is locked\n   * @param {string} [reason] Reason for locking or unlocking the thread\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Set the thread to locked\n   * thread.setLocked(true)\n   *   .then(newThread => console.log(`Thread is now ${newThread.locked ? 'locked' : 'unlocked'}`))\n   *   .catch(console.error);\n   */\n  setLocked(locked = true, reason) {\n    return this.edit({ locked }, reason);\n  }\n\n  /**\n   * Sets a new name for this thread.\n   * @param {string} name The new name for the thread\n   * @param {string} [reason] Reason for changing the thread's name\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Change the thread's name\n   * thread.setName('not_general')\n   *   .then(newThread => console.log(`Thread's new name is ${newThread.name}`))\n   *   .catch(console.error);\n   */\n  setName(name, reason) {\n    return this.edit({ name }, reason);\n  }\n\n  /**\n   * Sets the rate limit per user (slowmode) for this thread.\n   * @param {number} rateLimitPerUser The new rate limit in seconds\n   * @param {string} [reason] Reason for changing the thread's rate limit\n   * @returns {Promise<ThreadChannel>}\n   */\n  setRateLimitPerUser(rateLimitPerUser, reason) {\n    return this.edit({ rateLimitPerUser }, reason);\n  }\n\n  /**\n   * Whether the client user is a member of the thread.\n   * @type {boolean}\n   * @readonly\n   */\n  get joined() {\n    return this.members.cache.has(this.client.user?.id);\n  }\n\n  /**\n   * Whether the thread is editable by the client user (name, archived, autoArchiveDuration)\n   * @type {boolean}\n   * @readonly\n   */\n  get editable() {\n    return (\n      (this.ownerId === this.client.user.id && (this.type !== 'GUILD_PRIVATE_THREAD' || this.joined)) || this.manageable\n    );\n  }\n\n  /**\n   * Whether the thread is joinable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get joinable() {\n    return (\n      !this.archived &&\n      !this.joined &&\n      this.permissionsFor(this.client.user)?.has(\n        this.type === 'GUILD_PRIVATE_THREAD' ? Permissions.FLAGS.MANAGE_THREADS : Permissions.FLAGS.VIEW_CHANNEL,\n        false,\n      )\n    );\n  }\n\n  /**\n   * Whether the thread is manageable by the client user, for deleting or editing rateLimitPerUser or locked.\n   * @type {boolean}\n   * @readonly\n   */\n  get manageable() {\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    // This flag allows managing even if timed out\n    if (permissions.has(Permissions.FLAGS.ADMINISTRATOR, false)) return true;\n\n    return (\n      this.guild.me.communicationDisabledUntilTimestamp < Date.now() &&\n      permissions.has(Permissions.FLAGS.MANAGE_THREADS, false)\n    );\n  }\n\n  /**\n   * Whether the thread is viewable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get viewable() {\n    if (this.client.user.id === this.guild.ownerId) return true;\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    return permissions.has(Permissions.FLAGS.VIEW_CHANNEL, false);\n  }\n\n  /**\n   * Whether the client user can send messages in this thread\n   * @type {boolean}\n   * @readonly\n   */\n  get sendable() {\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    // This flag allows sending even if timed out\n    if (permissions.has(Permissions.FLAGS.ADMINISTRATOR, false)) return true;\n\n    return (\n      !(this.archived && this.locked && !this.manageable) &&\n      (this.type !== 'GUILD_PRIVATE_THREAD' || this.joined || this.manageable) &&\n      permissions.has(Permissions.FLAGS.SEND_MESSAGES_IN_THREADS, false) &&\n      this.guild.me.communicationDisabledUntilTimestamp < Date.now()\n    );\n  }\n\n  /**\n   * Whether the thread is unarchivable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get unarchivable() {\n    return this.archived && (this.locked ? this.manageable : this.sendable);\n  }\n\n  /**\n   * Deletes this thread.\n   * @param {string} [reason] Reason for deleting this thread\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Delete the thread\n   * thread.delete('cleaning out old threads')\n   *   .then(deletedThread => console.log(deletedThread))\n   *   .catch(console.error);\n   */\n  async delete(reason) {\n    await this.client.api.channels(this.id).delete({ reason });\n    return this;\n  }\n\n  // These are here only for documentation purposes - they are implemented by TextBasedChannel\n  /* eslint-disable no-empty-function */\n  get lastMessage() {}\n  get lastPinAt() {}\n  send() {}\n  sendTyping() {}\n  createMessageCollector() {}\n  awaitMessages() {}\n  createMessageComponentCollector() {}\n  awaitMessageComponent() {}\n  bulkDelete() {}\n}\n\nTextBasedChannel.applyToClass(ThreadChannel, true);\n\nmodule.exports = ThreadChannel;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}