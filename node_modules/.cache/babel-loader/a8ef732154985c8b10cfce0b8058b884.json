{"ast":null,"code":"'use strict';\n\nconst {\n  setInterval\n} = require('node:timers');\n\nconst {\n  Events,\n  ThreadChannelTypes,\n  SweeperKeys\n} = require('./Constants');\n\nconst {\n  TypeError\n} = require('../errors/DJSError.js');\n/**\n * @typedef {Function} GlobalSweepFilter\n * @returns {Function|null} Return `null` to skip sweeping, otherwise a function passed to `sweep()`,\n * See {@link [Collection#sweep](https://discord.js.org/#/docs/collection/main/class/Collection?scrollTo=sweep)}\n * for the definition of this function.\n */\n\n/**\n * A container for all cache sweeping intervals and their associated sweep methods.\n */\n\n\nclass Sweepers {\n  constructor(client, options) {\n    /**\n     * The client that instantiated this\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', {\n      value: client\n    });\n    /**\n     * The options the sweepers were instantiated with\n     * @type {SweeperOptions}\n     */\n\n    this.options = options;\n    /**\n     * A record of interval timeout that is used to sweep the indicated items, or null if not being swept\n     * @type {Object<SweeperKey, ?Timeout>}\n     */\n\n    this.intervals = Object.fromEntries(SweeperKeys.map(key => [key, null]));\n\n    for (const key of SweeperKeys) {\n      if (!(key in options)) continue;\n\n      this._validateProperties(key);\n\n      const clonedOptions = { ...this.options[key]\n      }; // Handle cases that have a \"lifetime\"\n\n      if (!('filter' in clonedOptions)) {\n        switch (key) {\n          case 'invites':\n            clonedOptions.filter = this.constructor.expiredInviteSweepFilter(clonedOptions.lifetime);\n            break;\n\n          case 'messages':\n            clonedOptions.filter = this.constructor.outdatedMessageSweepFilter(clonedOptions.lifetime);\n            break;\n\n          case 'threads':\n            clonedOptions.filter = this.constructor.archivedThreadSweepFilter(clonedOptions.lifetime);\n        }\n      }\n\n      this._initInterval(key, `sweep${key[0].toUpperCase()}${key.slice(1)}`, clonedOptions);\n    }\n  }\n  /**\n   * Sweeps all guild and global application commands and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which commands will be removed from the caches.\n   * @returns {number} Amount of commands that were removed from the caches\n   */\n\n\n  sweepApplicationCommands(filter) {\n    const {\n      guilds,\n      items: guildCommands\n    } = this._sweepGuildDirectProp('commands', filter, {\n      emit: false\n    });\n\n    const globalCommands = this.client.application?.commands.cache.sweep(filter) ?? 0;\n    this.client.emit(Events.CACHE_SWEEP, `Swept ${globalCommands} global application commands and ${guildCommands} guild commands in ${guilds} guilds.`);\n    return guildCommands + globalCommands;\n  }\n  /**\n   * Sweeps all guild bans and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which bans will be removed from the caches.\n   * @returns {number} Amount of bans that were removed from the caches\n   */\n\n\n  sweepBans(filter) {\n    return this._sweepGuildDirectProp('bans', filter).items;\n  }\n  /**\n   * Sweeps all guild emojis and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which emojis will be removed from the caches.\n   * @returns {number} Amount of emojis that were removed from the caches\n   */\n\n\n  sweepEmojis(filter) {\n    return this._sweepGuildDirectProp('emojis', filter).items;\n  }\n  /**\n   * Sweeps all guild invites and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which invites will be removed from the caches.\n   * @returns {number} Amount of invites that were removed from the caches\n   */\n\n\n  sweepInvites(filter) {\n    return this._sweepGuildDirectProp('invites', filter).items;\n  }\n  /**\n   * Sweeps all guild members and removes the ones which are indicated by the filter.\n   * <info>It is highly recommended to keep the client guild member cached</info>\n   * @param {Function} filter The function used to determine which guild members will be removed from the caches.\n   * @returns {number} Amount of guild members that were removed from the caches\n   */\n\n\n  sweepGuildMembers(filter) {\n    return this._sweepGuildDirectProp('members', filter, {\n      outputName: 'guild members'\n    }).items;\n  }\n  /**\n   * Sweeps all text-based channels' messages and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which messages will be removed from the caches.\n   * @returns {number} Amount of messages that were removed from the caches\n   * @example\n   * // Remove all messages older than 1800 seconds from the messages cache\n   * const amount = sweepers.sweepMessages(\n   *   Sweepers.filterByLifetime({\n   *     lifetime: 1800,\n   *     getComparisonTimestamp: m => m.editedTimestamp ?? m.createdTimestamp,\n   *   })(),\n   * );\n   * console.log(`Successfully removed ${amount} messages from the cache.`);\n   */\n\n\n  sweepMessages(filter) {\n    if (typeof filter !== 'function') {\n      throw new TypeError('INVALID_TYPE', 'filter', 'function');\n    }\n\n    let channels = 0;\n    let messages = 0;\n\n    for (const channel of this.client.channels.cache.values()) {\n      if (!channel.isText()) continue;\n      channels++;\n      messages += channel.messages.cache.sweep(filter);\n    }\n\n    this.client.emit(Events.CACHE_SWEEP, `Swept ${messages} messages in ${channels} text-based channels.`);\n    return messages;\n  }\n  /**\n   * Sweeps all presences and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which presences will be removed from the caches.\n   * @returns {number} Amount of presences that were removed from the caches\n   */\n\n\n  sweepPresences(filter) {\n    return this._sweepGuildDirectProp('presences', filter).items;\n  }\n  /**\n   * Sweeps all message reactions and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which reactions will be removed from the caches.\n   * @returns {number} Amount of reactions that were removed from the caches\n   */\n\n\n  sweepReactions(filter) {\n    if (typeof filter !== 'function') {\n      throw new TypeError('INVALID_TYPE', 'filter', 'function');\n    }\n\n    let channels = 0;\n    let messages = 0;\n    let reactions = 0;\n\n    for (const channel of this.client.channels.cache.values()) {\n      if (!channel.isText()) continue;\n      channels++;\n\n      for (const message of channel.messages.cache.values()) {\n        messages++;\n        reactions += message.reactions.cache.sweep(filter);\n      }\n    }\n\n    this.client.emit(Events.CACHE_SWEEP, `Swept ${reactions} reactions on ${messages} messages in ${channels} text-based channels.`);\n    return reactions;\n  }\n  /**\n   * Sweeps all guild stage instances and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which stage instances will be removed from the caches.\n   * @returns {number} Amount of stage instances that were removed from the caches\n   */\n\n\n  sweepStageInstances(filter) {\n    return this._sweepGuildDirectProp('stageInstances', filter, {\n      outputName: 'stage instances'\n    }).items;\n  }\n  /**\n   * Sweeps all thread members and removes the ones which are indicated by the filter.\n   * <info>It is highly recommended to keep the client thread member cached</info>\n   * @param {Function} filter The function used to determine which thread members will be removed from the caches.\n   * @returns {number} Amount of thread members that were removed from the caches\n   */\n\n\n  sweepThreadMembers(filter) {\n    if (typeof filter !== 'function') {\n      throw new TypeError('INVALID_TYPE', 'filter', 'function');\n    }\n\n    let threads = 0;\n    let members = 0;\n\n    for (const channel of this.client.channels.cache.values()) {\n      if (!ThreadChannelTypes.includes(channel.type)) continue;\n      threads++;\n      members += channel.members.cache.sweep(filter);\n    }\n\n    this.client.emit(Events.CACHE_SWEEP, `Swept ${members} thread members in ${threads} threads.`);\n    return members;\n  }\n  /**\n   * Sweeps all threads and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which threads will be removed from the caches.\n   * @returns {number} filter Amount of threads that were removed from the caches\n   * @example\n   * // Remove all threads archived greater than 1 day ago from all the channel caches\n   * const amount = sweepers.sweepThreads(\n   *   Sweepers.filterByLifetime({\n   *     getComparisonTimestamp: t => t.archivedTimestamp,\n   *     excludeFromSweep: t => !t.archived,\n   *   })(),\n   * );\n   * console.log(`Successfully removed ${amount} threads from the cache.`);\n   */\n\n\n  sweepThreads(filter) {\n    if (typeof filter !== 'function') {\n      throw new TypeError('INVALID_TYPE', 'filter', 'function');\n    }\n\n    let threads = 0;\n\n    for (const [key, val] of this.client.channels.cache.entries()) {\n      if (!ThreadChannelTypes.includes(val.type)) continue;\n\n      if (filter(val, key, this.client.channels.cache)) {\n        threads++;\n\n        this.client.channels._remove(key);\n      }\n    }\n\n    this.client.emit(Events.CACHE_SWEEP, `Swept ${threads} threads.`);\n    return threads;\n  }\n  /**\n   * Sweeps all users and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which users will be removed from the caches.\n   * @returns {number} Amount of users that were removed from the caches\n   */\n\n\n  sweepUsers(filter) {\n    if (typeof filter !== 'function') {\n      throw new TypeError('INVALID_TYPE', 'filter', 'function');\n    }\n\n    const users = this.client.users.cache.sweep(filter);\n    this.client.emit(Events.CACHE_SWEEP, `Swept ${users} users.`);\n    return users;\n  }\n  /**\n   * Sweeps all guild voice states and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which voice states will be removed from the caches.\n   * @returns {number} Amount of voice states that were removed from the caches\n   */\n\n\n  sweepVoiceStates(filter) {\n    return this._sweepGuildDirectProp('voiceStates', filter, {\n      outputName: 'voice states'\n    }).items;\n  }\n  /**\n   * Cancels all sweeping intervals\n   * @returns {void}\n   */\n\n\n  destroy() {\n    for (const key of SweeperKeys) {\n      if (this.intervals[key]) clearInterval(this.intervals[key]);\n    }\n  }\n  /**\n   * Options for generating a filter function based on lifetime\n   * @typedef {Object} LifetimeFilterOptions\n   * @property {number} [lifetime=14400] How long, in seconds, an entry should stay in the collection\n   * before it is considered sweepable.\n   * @property {Function} [getComparisonTimestamp=e => e?.createdTimestamp] A function that takes an entry, key,\n   * and the collection and returns a timestamp to compare against in order to determine the lifetime of the entry.\n   * @property {Function} [excludeFromSweep=() => false] A function that takes an entry, key, and the collection\n   * and returns a boolean, `true` when the entry should not be checked for sweepability.\n   */\n\n  /**\n   * Create a sweepFilter function that uses a lifetime to determine sweepability.\n   * @param {LifetimeFilterOptions} [options={}] The options used to generate the filter function\n   * @returns {GlobalSweepFilter}\n   */\n\n\n  static filterByLifetime() {\n    let {\n      lifetime = 14400,\n      getComparisonTimestamp = e => e?.createdTimestamp,\n      excludeFromSweep = () => false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (typeof lifetime !== 'number') {\n      throw new TypeError('INVALID_TYPE', 'lifetime', 'number');\n    }\n\n    if (typeof getComparisonTimestamp !== 'function') {\n      throw new TypeError('INVALID_TYPE', 'getComparisonTimestamp', 'function');\n    }\n\n    if (typeof excludeFromSweep !== 'function') {\n      throw new TypeError('INVALID_TYPE', 'excludeFromSweep', 'function');\n    }\n\n    return () => {\n      if (lifetime <= 0) return null;\n      const lifetimeMs = lifetime * 1_000;\n      const now = Date.now();\n      return (entry, key, coll) => {\n        if (excludeFromSweep(entry, key, coll)) {\n          return false;\n        }\n\n        const comparisonTimestamp = getComparisonTimestamp(entry, key, coll);\n        if (!comparisonTimestamp || typeof comparisonTimestamp !== 'number') return false;\n        return now - comparisonTimestamp > lifetimeMs;\n      };\n    };\n  }\n  /**\n   * Creates a sweep filter that sweeps archived threads\n   * @param {number} [lifetime=14400] How long a thread has to be archived to be valid for sweeping\n   * @returns {GlobalSweepFilter}\n   */\n\n\n  static archivedThreadSweepFilter() {\n    let lifetime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 14400;\n    return this.filterByLifetime({\n      lifetime,\n      getComparisonTimestamp: e => e.archiveTimestamp,\n      excludeFromSweep: e => !e.archived\n    });\n  }\n  /**\n   * Creates a sweep filter that sweeps expired invites\n   * @param {number} [lifetime=14400] How long ago an invite has to have expired to be valid for sweeping\n   * @returns {GlobalSweepFilter}\n   */\n\n\n  static expiredInviteSweepFilter() {\n    let lifetime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 14400;\n    return this.filterByLifetime({\n      lifetime,\n      getComparisonTimestamp: i => i.expiresTimestamp\n    });\n  }\n  /**\n   * Creates a sweep filter that sweeps outdated messages (edits taken into account)\n   * @param {number} [lifetime=3600] How long ago a message has to have been sent or edited to be valid for sweeping\n   * @returns {GlobalSweepFilter}\n   */\n\n\n  static outdatedMessageSweepFilter() {\n    let lifetime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3600;\n    return this.filterByLifetime({\n      lifetime,\n      getComparisonTimestamp: m => m.editedTimestamp ?? m.createdTimestamp\n    });\n  }\n  /**\n   * Configuration options for emitting the cache sweep client event\n   * @typedef {Object} SweepEventOptions\n   * @property {boolean} [emit=true] Whether to emit the client event in this method\n   * @property {string} [outputName] A name to output in the client event if it should differ from the key\n   * @private\n   */\n\n  /**\n   * Sweep a direct sub property of all guilds\n   * @param {string} key The name of the property\n   * @param {Function} filter Filter function passed to sweep\n   * @param {SweepEventOptions} [eventOptions={}] Options for the Client event emitted here\n   * @returns {Object} Object containing the number of guilds swept and the number of items swept\n   * @private\n   */\n\n\n  _sweepGuildDirectProp(key, filter) {\n    let {\n      emit = true,\n      outputName\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (typeof filter !== 'function') {\n      throw new TypeError('INVALID_TYPE', 'filter', 'function');\n    }\n\n    let guilds = 0;\n    let items = 0;\n\n    for (const guild of this.client.guilds.cache.values()) {\n      const {\n        cache\n      } = guild[key];\n      guilds++;\n      items += cache.sweep(filter);\n    }\n\n    if (emit) {\n      this.client.emit(Events.CACHE_SWEEP, `Swept ${items} ${outputName ?? key} in ${guilds} guilds.`);\n    }\n\n    return {\n      guilds,\n      items\n    };\n  }\n  /**\n   * Validates a set of properties\n   * @param {string} key Key of the options object to check\n   * @private\n   */\n\n\n  _validateProperties(key) {\n    const props = this.options[key];\n\n    if (typeof props !== 'object') {\n      throw new TypeError('INVALID_TYPE', `sweepers.${key}`, 'object', true);\n    }\n\n    if (typeof props.interval !== 'number') {\n      throw new TypeError('INVALID_TYPE', `sweepers.${key}.interval`, 'number');\n    } // Invites, Messages, and Threads can be provided a lifetime parameter, which we use to generate the filter\n\n\n    if (['invites', 'messages', 'threads'].includes(key) && !('filter' in props)) {\n      if (typeof props.lifetime !== 'number') {\n        throw new TypeError('INVALID_TYPE', `sweepers.${key}.lifetime`, 'number');\n      }\n\n      return;\n    }\n\n    if (typeof props.filter !== 'function') {\n      throw new TypeError('INVALID_TYPE', `sweepers.${key}.filter`, 'function');\n    }\n  }\n  /**\n   * Initialize an interval for sweeping\n   * @param {string} intervalKey The name of the property that stores the interval for this sweeper\n   * @param {string} sweepKey The name of the function that sweeps the desired caches\n   * @param {Object} opts Validated options for a sweep\n   * @private\n   */\n\n\n  _initInterval(intervalKey, sweepKey, opts) {\n    if (opts.interval <= 0 || opts.interval === Infinity) return;\n    this.intervals[intervalKey] = setInterval(() => {\n      const sweepFn = opts.filter();\n      if (sweepFn === null) return;\n      if (typeof sweepFn !== 'function') throw new TypeError('SWEEP_FILTER_RETURN');\n      this[sweepKey](sweepFn);\n    }, opts.interval * 1_000).unref();\n  }\n\n}\n\nmodule.exports = Sweepers;","map":{"version":3,"names":["setInterval","require","Events","ThreadChannelTypes","SweeperKeys","TypeError","Sweepers","constructor","client","options","Object","defineProperty","value","intervals","fromEntries","map","key","_validateProperties","clonedOptions","filter","expiredInviteSweepFilter","lifetime","outdatedMessageSweepFilter","archivedThreadSweepFilter","_initInterval","toUpperCase","slice","sweepApplicationCommands","guilds","items","guildCommands","_sweepGuildDirectProp","emit","globalCommands","application","commands","cache","sweep","CACHE_SWEEP","sweepBans","sweepEmojis","sweepInvites","sweepGuildMembers","outputName","sweepMessages","channels","messages","channel","values","isText","sweepPresences","sweepReactions","reactions","message","sweepStageInstances","sweepThreadMembers","threads","members","includes","type","sweepThreads","val","entries","_remove","sweepUsers","users","sweepVoiceStates","destroy","clearInterval","filterByLifetime","getComparisonTimestamp","e","createdTimestamp","excludeFromSweep","lifetimeMs","now","Date","entry","coll","comparisonTimestamp","archiveTimestamp","archived","i","expiresTimestamp","m","editedTimestamp","guild","props","interval","intervalKey","sweepKey","opts","Infinity","sweepFn","unref","module","exports"],"sources":["C:/Users/xsxsam/node_modules/discord.js/src/util/Sweepers.js"],"sourcesContent":["'use strict';\n\nconst { setInterval } = require('node:timers');\nconst { Events, ThreadChannelTypes, SweeperKeys } = require('./Constants');\nconst { TypeError } = require('../errors/DJSError.js');\n\n/**\n * @typedef {Function} GlobalSweepFilter\n * @returns {Function|null} Return `null` to skip sweeping, otherwise a function passed to `sweep()`,\n * See {@link [Collection#sweep](https://discord.js.org/#/docs/collection/main/class/Collection?scrollTo=sweep)}\n * for the definition of this function.\n */\n\n/**\n * A container for all cache sweeping intervals and their associated sweep methods.\n */\nclass Sweepers {\n  constructor(client, options) {\n    /**\n     * The client that instantiated this\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', { value: client });\n\n    /**\n     * The options the sweepers were instantiated with\n     * @type {SweeperOptions}\n     */\n    this.options = options;\n\n    /**\n     * A record of interval timeout that is used to sweep the indicated items, or null if not being swept\n     * @type {Object<SweeperKey, ?Timeout>}\n     */\n    this.intervals = Object.fromEntries(SweeperKeys.map(key => [key, null]));\n\n    for (const key of SweeperKeys) {\n      if (!(key in options)) continue;\n\n      this._validateProperties(key);\n\n      const clonedOptions = { ...this.options[key] };\n\n      // Handle cases that have a \"lifetime\"\n      if (!('filter' in clonedOptions)) {\n        switch (key) {\n          case 'invites':\n            clonedOptions.filter = this.constructor.expiredInviteSweepFilter(clonedOptions.lifetime);\n            break;\n          case 'messages':\n            clonedOptions.filter = this.constructor.outdatedMessageSweepFilter(clonedOptions.lifetime);\n            break;\n          case 'threads':\n            clonedOptions.filter = this.constructor.archivedThreadSweepFilter(clonedOptions.lifetime);\n        }\n      }\n\n      this._initInterval(key, `sweep${key[0].toUpperCase()}${key.slice(1)}`, clonedOptions);\n    }\n  }\n\n  /**\n   * Sweeps all guild and global application commands and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which commands will be removed from the caches.\n   * @returns {number} Amount of commands that were removed from the caches\n   */\n  sweepApplicationCommands(filter) {\n    const { guilds, items: guildCommands } = this._sweepGuildDirectProp('commands', filter, { emit: false });\n\n    const globalCommands = this.client.application?.commands.cache.sweep(filter) ?? 0;\n\n    this.client.emit(\n      Events.CACHE_SWEEP,\n      `Swept ${globalCommands} global application commands and ${guildCommands} guild commands in ${guilds} guilds.`,\n    );\n    return guildCommands + globalCommands;\n  }\n\n  /**\n   * Sweeps all guild bans and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which bans will be removed from the caches.\n   * @returns {number} Amount of bans that were removed from the caches\n   */\n  sweepBans(filter) {\n    return this._sweepGuildDirectProp('bans', filter).items;\n  }\n\n  /**\n   * Sweeps all guild emojis and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which emojis will be removed from the caches.\n   * @returns {number} Amount of emojis that were removed from the caches\n   */\n  sweepEmojis(filter) {\n    return this._sweepGuildDirectProp('emojis', filter).items;\n  }\n\n  /**\n   * Sweeps all guild invites and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which invites will be removed from the caches.\n   * @returns {number} Amount of invites that were removed from the caches\n   */\n  sweepInvites(filter) {\n    return this._sweepGuildDirectProp('invites', filter).items;\n  }\n\n  /**\n   * Sweeps all guild members and removes the ones which are indicated by the filter.\n   * <info>It is highly recommended to keep the client guild member cached</info>\n   * @param {Function} filter The function used to determine which guild members will be removed from the caches.\n   * @returns {number} Amount of guild members that were removed from the caches\n   */\n  sweepGuildMembers(filter) {\n    return this._sweepGuildDirectProp('members', filter, { outputName: 'guild members' }).items;\n  }\n\n  /**\n   * Sweeps all text-based channels' messages and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which messages will be removed from the caches.\n   * @returns {number} Amount of messages that were removed from the caches\n   * @example\n   * // Remove all messages older than 1800 seconds from the messages cache\n   * const amount = sweepers.sweepMessages(\n   *   Sweepers.filterByLifetime({\n   *     lifetime: 1800,\n   *     getComparisonTimestamp: m => m.editedTimestamp ?? m.createdTimestamp,\n   *   })(),\n   * );\n   * console.log(`Successfully removed ${amount} messages from the cache.`);\n   */\n  sweepMessages(filter) {\n    if (typeof filter !== 'function') {\n      throw new TypeError('INVALID_TYPE', 'filter', 'function');\n    }\n    let channels = 0;\n    let messages = 0;\n\n    for (const channel of this.client.channels.cache.values()) {\n      if (!channel.isText()) continue;\n\n      channels++;\n      messages += channel.messages.cache.sweep(filter);\n    }\n    this.client.emit(Events.CACHE_SWEEP, `Swept ${messages} messages in ${channels} text-based channels.`);\n    return messages;\n  }\n\n  /**\n   * Sweeps all presences and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which presences will be removed from the caches.\n   * @returns {number} Amount of presences that were removed from the caches\n   */\n  sweepPresences(filter) {\n    return this._sweepGuildDirectProp('presences', filter).items;\n  }\n\n  /**\n   * Sweeps all message reactions and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which reactions will be removed from the caches.\n   * @returns {number} Amount of reactions that were removed from the caches\n   */\n  sweepReactions(filter) {\n    if (typeof filter !== 'function') {\n      throw new TypeError('INVALID_TYPE', 'filter', 'function');\n    }\n    let channels = 0;\n    let messages = 0;\n    let reactions = 0;\n\n    for (const channel of this.client.channels.cache.values()) {\n      if (!channel.isText()) continue;\n      channels++;\n\n      for (const message of channel.messages.cache.values()) {\n        messages++;\n        reactions += message.reactions.cache.sweep(filter);\n      }\n    }\n    this.client.emit(\n      Events.CACHE_SWEEP,\n      `Swept ${reactions} reactions on ${messages} messages in ${channels} text-based channels.`,\n    );\n    return reactions;\n  }\n\n  /**\n   * Sweeps all guild stage instances and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which stage instances will be removed from the caches.\n   * @returns {number} Amount of stage instances that were removed from the caches\n   */\n  sweepStageInstances(filter) {\n    return this._sweepGuildDirectProp('stageInstances', filter, { outputName: 'stage instances' }).items;\n  }\n\n  /**\n   * Sweeps all thread members and removes the ones which are indicated by the filter.\n   * <info>It is highly recommended to keep the client thread member cached</info>\n   * @param {Function} filter The function used to determine which thread members will be removed from the caches.\n   * @returns {number} Amount of thread members that were removed from the caches\n   */\n  sweepThreadMembers(filter) {\n    if (typeof filter !== 'function') {\n      throw new TypeError('INVALID_TYPE', 'filter', 'function');\n    }\n\n    let threads = 0;\n    let members = 0;\n    for (const channel of this.client.channels.cache.values()) {\n      if (!ThreadChannelTypes.includes(channel.type)) continue;\n      threads++;\n      members += channel.members.cache.sweep(filter);\n    }\n    this.client.emit(Events.CACHE_SWEEP, `Swept ${members} thread members in ${threads} threads.`);\n    return members;\n  }\n\n  /**\n   * Sweeps all threads and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which threads will be removed from the caches.\n   * @returns {number} filter Amount of threads that were removed from the caches\n   * @example\n   * // Remove all threads archived greater than 1 day ago from all the channel caches\n   * const amount = sweepers.sweepThreads(\n   *   Sweepers.filterByLifetime({\n   *     getComparisonTimestamp: t => t.archivedTimestamp,\n   *     excludeFromSweep: t => !t.archived,\n   *   })(),\n   * );\n   * console.log(`Successfully removed ${amount} threads from the cache.`);\n   */\n  sweepThreads(filter) {\n    if (typeof filter !== 'function') {\n      throw new TypeError('INVALID_TYPE', 'filter', 'function');\n    }\n\n    let threads = 0;\n    for (const [key, val] of this.client.channels.cache.entries()) {\n      if (!ThreadChannelTypes.includes(val.type)) continue;\n      if (filter(val, key, this.client.channels.cache)) {\n        threads++;\n        this.client.channels._remove(key);\n      }\n    }\n    this.client.emit(Events.CACHE_SWEEP, `Swept ${threads} threads.`);\n    return threads;\n  }\n\n  /**\n   * Sweeps all users and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which users will be removed from the caches.\n   * @returns {number} Amount of users that were removed from the caches\n   */\n  sweepUsers(filter) {\n    if (typeof filter !== 'function') {\n      throw new TypeError('INVALID_TYPE', 'filter', 'function');\n    }\n\n    const users = this.client.users.cache.sweep(filter);\n\n    this.client.emit(Events.CACHE_SWEEP, `Swept ${users} users.`);\n\n    return users;\n  }\n\n  /**\n   * Sweeps all guild voice states and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which voice states will be removed from the caches.\n   * @returns {number} Amount of voice states that were removed from the caches\n   */\n  sweepVoiceStates(filter) {\n    return this._sweepGuildDirectProp('voiceStates', filter, { outputName: 'voice states' }).items;\n  }\n\n  /**\n   * Cancels all sweeping intervals\n   * @returns {void}\n   */\n  destroy() {\n    for (const key of SweeperKeys) {\n      if (this.intervals[key]) clearInterval(this.intervals[key]);\n    }\n  }\n\n  /**\n   * Options for generating a filter function based on lifetime\n   * @typedef {Object} LifetimeFilterOptions\n   * @property {number} [lifetime=14400] How long, in seconds, an entry should stay in the collection\n   * before it is considered sweepable.\n   * @property {Function} [getComparisonTimestamp=e => e?.createdTimestamp] A function that takes an entry, key,\n   * and the collection and returns a timestamp to compare against in order to determine the lifetime of the entry.\n   * @property {Function} [excludeFromSweep=() => false] A function that takes an entry, key, and the collection\n   * and returns a boolean, `true` when the entry should not be checked for sweepability.\n   */\n\n  /**\n   * Create a sweepFilter function that uses a lifetime to determine sweepability.\n   * @param {LifetimeFilterOptions} [options={}] The options used to generate the filter function\n   * @returns {GlobalSweepFilter}\n   */\n  static filterByLifetime({\n    lifetime = 14400,\n    getComparisonTimestamp = e => e?.createdTimestamp,\n    excludeFromSweep = () => false,\n  } = {}) {\n    if (typeof lifetime !== 'number') {\n      throw new TypeError('INVALID_TYPE', 'lifetime', 'number');\n    }\n    if (typeof getComparisonTimestamp !== 'function') {\n      throw new TypeError('INVALID_TYPE', 'getComparisonTimestamp', 'function');\n    }\n    if (typeof excludeFromSweep !== 'function') {\n      throw new TypeError('INVALID_TYPE', 'excludeFromSweep', 'function');\n    }\n    return () => {\n      if (lifetime <= 0) return null;\n      const lifetimeMs = lifetime * 1_000;\n      const now = Date.now();\n      return (entry, key, coll) => {\n        if (excludeFromSweep(entry, key, coll)) {\n          return false;\n        }\n        const comparisonTimestamp = getComparisonTimestamp(entry, key, coll);\n        if (!comparisonTimestamp || typeof comparisonTimestamp !== 'number') return false;\n        return now - comparisonTimestamp > lifetimeMs;\n      };\n    };\n  }\n\n  /**\n   * Creates a sweep filter that sweeps archived threads\n   * @param {number} [lifetime=14400] How long a thread has to be archived to be valid for sweeping\n   * @returns {GlobalSweepFilter}\n   */\n  static archivedThreadSweepFilter(lifetime = 14400) {\n    return this.filterByLifetime({\n      lifetime,\n      getComparisonTimestamp: e => e.archiveTimestamp,\n      excludeFromSweep: e => !e.archived,\n    });\n  }\n\n  /**\n   * Creates a sweep filter that sweeps expired invites\n   * @param {number} [lifetime=14400] How long ago an invite has to have expired to be valid for sweeping\n   * @returns {GlobalSweepFilter}\n   */\n  static expiredInviteSweepFilter(lifetime = 14400) {\n    return this.filterByLifetime({\n      lifetime,\n      getComparisonTimestamp: i => i.expiresTimestamp,\n    });\n  }\n\n  /**\n   * Creates a sweep filter that sweeps outdated messages (edits taken into account)\n   * @param {number} [lifetime=3600] How long ago a message has to have been sent or edited to be valid for sweeping\n   * @returns {GlobalSweepFilter}\n   */\n  static outdatedMessageSweepFilter(lifetime = 3600) {\n    return this.filterByLifetime({\n      lifetime,\n      getComparisonTimestamp: m => m.editedTimestamp ?? m.createdTimestamp,\n    });\n  }\n\n  /**\n   * Configuration options for emitting the cache sweep client event\n   * @typedef {Object} SweepEventOptions\n   * @property {boolean} [emit=true] Whether to emit the client event in this method\n   * @property {string} [outputName] A name to output in the client event if it should differ from the key\n   * @private\n   */\n\n  /**\n   * Sweep a direct sub property of all guilds\n   * @param {string} key The name of the property\n   * @param {Function} filter Filter function passed to sweep\n   * @param {SweepEventOptions} [eventOptions={}] Options for the Client event emitted here\n   * @returns {Object} Object containing the number of guilds swept and the number of items swept\n   * @private\n   */\n  _sweepGuildDirectProp(key, filter, { emit = true, outputName } = {}) {\n    if (typeof filter !== 'function') {\n      throw new TypeError('INVALID_TYPE', 'filter', 'function');\n    }\n\n    let guilds = 0;\n    let items = 0;\n\n    for (const guild of this.client.guilds.cache.values()) {\n      const { cache } = guild[key];\n\n      guilds++;\n      items += cache.sweep(filter);\n    }\n\n    if (emit) {\n      this.client.emit(Events.CACHE_SWEEP, `Swept ${items} ${outputName ?? key} in ${guilds} guilds.`);\n    }\n\n    return { guilds, items };\n  }\n\n  /**\n   * Validates a set of properties\n   * @param {string} key Key of the options object to check\n   * @private\n   */\n  _validateProperties(key) {\n    const props = this.options[key];\n    if (typeof props !== 'object') {\n      throw new TypeError('INVALID_TYPE', `sweepers.${key}`, 'object', true);\n    }\n    if (typeof props.interval !== 'number') {\n      throw new TypeError('INVALID_TYPE', `sweepers.${key}.interval`, 'number');\n    }\n    // Invites, Messages, and Threads can be provided a lifetime parameter, which we use to generate the filter\n    if (['invites', 'messages', 'threads'].includes(key) && !('filter' in props)) {\n      if (typeof props.lifetime !== 'number') {\n        throw new TypeError('INVALID_TYPE', `sweepers.${key}.lifetime`, 'number');\n      }\n      return;\n    }\n    if (typeof props.filter !== 'function') {\n      throw new TypeError('INVALID_TYPE', `sweepers.${key}.filter`, 'function');\n    }\n  }\n\n  /**\n   * Initialize an interval for sweeping\n   * @param {string} intervalKey The name of the property that stores the interval for this sweeper\n   * @param {string} sweepKey The name of the function that sweeps the desired caches\n   * @param {Object} opts Validated options for a sweep\n   * @private\n   */\n  _initInterval(intervalKey, sweepKey, opts) {\n    if (opts.interval <= 0 || opts.interval === Infinity) return;\n    this.intervals[intervalKey] = setInterval(() => {\n      const sweepFn = opts.filter();\n      if (sweepFn === null) return;\n      if (typeof sweepFn !== 'function') throw new TypeError('SWEEP_FILTER_RETURN');\n      this[sweepKey](sweepFn);\n    }, opts.interval * 1_000).unref();\n  }\n}\n\nmodule.exports = Sweepers;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}