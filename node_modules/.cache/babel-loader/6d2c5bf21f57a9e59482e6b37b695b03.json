{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst CachedManager = require('./CachedManager');\n\nconst {\n  TypeError\n} = require('../errors');\n\nconst ThreadMember = require('../structures/ThreadMember');\n/**\n * Manages API methods for GuildMembers and stores their cache.\n * @extends {CachedManager}\n */\n\n\nclass ThreadMemberManager extends CachedManager {\n  constructor(thread, iterable) {\n    super(thread.client, ThreadMember, iterable);\n    /**\n     * The thread this manager belongs to\n     * @type {ThreadChannel}\n     */\n\n    this.thread = thread;\n  }\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, ThreadMember>}\n   * @name ThreadMemberManager#cache\n   */\n\n\n  _add(data) {\n    let cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const existing = this.cache.get(data.user_id);\n    if (cache) existing?._patch(data);\n    if (existing) return existing;\n    const member = new ThreadMember(this.thread, data);\n    if (cache) this.cache.set(data.user_id, member);\n    return member;\n  }\n  /**\n   * Data that resolves to give a ThreadMember object. This can be:\n   * * A ThreadMember object\n   * * A User resolvable\n   * @typedef {ThreadMember|UserResolvable} ThreadMemberResolvable\n   */\n\n  /**\n   * Resolves a {@link ThreadMemberResolvable} to a {@link ThreadMember} object.\n   * @param {ThreadMemberResolvable} member The user that is part of the thread\n   * @returns {?GuildMember}\n   */\n\n\n  resolve(member) {\n    const memberResolvable = super.resolve(member);\n    if (memberResolvable) return memberResolvable;\n    const userResolvable = this.client.users.resolveId(member);\n    if (userResolvable) return super.resolve(userResolvable);\n    return null;\n  }\n  /**\n   * Resolves a {@link ThreadMemberResolvable} to a {@link ThreadMember} id string.\n   * @param {ThreadMemberResolvable} member The user that is part of the guild\n   * @returns {?Snowflake}\n   */\n\n\n  resolveId(member) {\n    const memberResolvable = super.resolveId(member);\n    if (memberResolvable) return memberResolvable;\n    const userResolvable = this.client.users.resolveId(member);\n    return this.cache.has(userResolvable) ? userResolvable : null;\n  }\n  /**\n   * Adds a member to the thread.\n   * @param {UserResolvable|'@me'} member The member to add\n   * @param {string} [reason] The reason for adding this member\n   * @returns {Promise<Snowflake>}\n   */\n\n\n  async add(member, reason) {\n    const id = member === '@me' ? member : this.client.users.resolveId(member);\n    if (!id) throw new TypeError('INVALID_TYPE', 'member', 'UserResolvable');\n    await this.client.api.channels(this.thread.id, 'thread-members', id).put({\n      reason\n    });\n    return id;\n  }\n  /**\n   * Remove a user from the thread.\n   * @param {Snowflake|'@me'} id The id of the member to remove\n   * @param {string} [reason] The reason for removing this member from the thread\n   * @returns {Promise<Snowflake>}\n   */\n\n\n  async remove(id, reason) {\n    await this.client.api.channels(this.thread.id, 'thread-members', id).delete({\n      reason\n    });\n    return id;\n  }\n\n  async _fetchOne(memberId, cache, force) {\n    if (!force) {\n      const existing = this.cache.get(memberId);\n      if (existing) return existing;\n    }\n\n    const data = await this.client.api.channels(this.thread.id, 'thread-members', memberId).get();\n    return this._add(data, cache);\n  }\n\n  async _fetchMany(cache) {\n    const raw = await this.client.api.channels(this.thread.id, 'thread-members').get();\n    return raw.reduce((col, member) => col.set(member.user_id, this._add(member, cache)), new Collection());\n  }\n  /**\n   * Fetches member(s) for the thread from Discord, requires access to the `GUILD_MEMBERS` gateway intent.\n   * @param {UserResolvable|boolean} [member] The member to fetch. If `undefined`, all members\n   * in the thread are fetched, and will be cached based on `options.cache`. If boolean, this serves\n   * the purpose of `options.cache`.\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<ThreadMember|Collection<Snowflake, ThreadMember>>}\n   */\n\n\n  fetch(member) {\n    let {\n      cache = true,\n      force = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const id = this.resolveId(member);\n    return id ? this._fetchOne(id, cache, force) : this._fetchMany(member ?? cache);\n  }\n\n}\n\nmodule.exports = ThreadMemberManager;","map":{"version":3,"names":["Collection","require","CachedManager","TypeError","ThreadMember","ThreadMemberManager","constructor","thread","iterable","client","_add","data","cache","existing","get","user_id","_patch","member","set","resolve","memberResolvable","userResolvable","users","resolveId","has","add","reason","id","api","channels","put","remove","delete","_fetchOne","memberId","force","_fetchMany","raw","reduce","col","fetch","module","exports"],"sources":["C:/Users/xsxsam/node_modules/discord.js/src/managers/ThreadMemberManager.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst CachedManager = require('./CachedManager');\nconst { TypeError } = require('../errors');\nconst ThreadMember = require('../structures/ThreadMember');\n\n/**\n * Manages API methods for GuildMembers and stores their cache.\n * @extends {CachedManager}\n */\nclass ThreadMemberManager extends CachedManager {\n  constructor(thread, iterable) {\n    super(thread.client, ThreadMember, iterable);\n\n    /**\n     * The thread this manager belongs to\n     * @type {ThreadChannel}\n     */\n    this.thread = thread;\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, ThreadMember>}\n   * @name ThreadMemberManager#cache\n   */\n\n  _add(data, cache = true) {\n    const existing = this.cache.get(data.user_id);\n    if (cache) existing?._patch(data);\n    if (existing) return existing;\n\n    const member = new ThreadMember(this.thread, data);\n    if (cache) this.cache.set(data.user_id, member);\n    return member;\n  }\n\n  /**\n   * Data that resolves to give a ThreadMember object. This can be:\n   * * A ThreadMember object\n   * * A User resolvable\n   * @typedef {ThreadMember|UserResolvable} ThreadMemberResolvable\n   */\n\n  /**\n   * Resolves a {@link ThreadMemberResolvable} to a {@link ThreadMember} object.\n   * @param {ThreadMemberResolvable} member The user that is part of the thread\n   * @returns {?GuildMember}\n   */\n  resolve(member) {\n    const memberResolvable = super.resolve(member);\n    if (memberResolvable) return memberResolvable;\n    const userResolvable = this.client.users.resolveId(member);\n    if (userResolvable) return super.resolve(userResolvable);\n    return null;\n  }\n\n  /**\n   * Resolves a {@link ThreadMemberResolvable} to a {@link ThreadMember} id string.\n   * @param {ThreadMemberResolvable} member The user that is part of the guild\n   * @returns {?Snowflake}\n   */\n  resolveId(member) {\n    const memberResolvable = super.resolveId(member);\n    if (memberResolvable) return memberResolvable;\n    const userResolvable = this.client.users.resolveId(member);\n    return this.cache.has(userResolvable) ? userResolvable : null;\n  }\n\n  /**\n   * Adds a member to the thread.\n   * @param {UserResolvable|'@me'} member The member to add\n   * @param {string} [reason] The reason for adding this member\n   * @returns {Promise<Snowflake>}\n   */\n  async add(member, reason) {\n    const id = member === '@me' ? member : this.client.users.resolveId(member);\n    if (!id) throw new TypeError('INVALID_TYPE', 'member', 'UserResolvable');\n    await this.client.api.channels(this.thread.id, 'thread-members', id).put({ reason });\n    return id;\n  }\n\n  /**\n   * Remove a user from the thread.\n   * @param {Snowflake|'@me'} id The id of the member to remove\n   * @param {string} [reason] The reason for removing this member from the thread\n   * @returns {Promise<Snowflake>}\n   */\n  async remove(id, reason) {\n    await this.client.api.channels(this.thread.id, 'thread-members', id).delete({ reason });\n    return id;\n  }\n\n  async _fetchOne(memberId, cache, force) {\n    if (!force) {\n      const existing = this.cache.get(memberId);\n      if (existing) return existing;\n    }\n\n    const data = await this.client.api.channels(this.thread.id, 'thread-members', memberId).get();\n    return this._add(data, cache);\n  }\n\n  async _fetchMany(cache) {\n    const raw = await this.client.api.channels(this.thread.id, 'thread-members').get();\n    return raw.reduce((col, member) => col.set(member.user_id, this._add(member, cache)), new Collection());\n  }\n\n  /**\n   * Fetches member(s) for the thread from Discord, requires access to the `GUILD_MEMBERS` gateway intent.\n   * @param {UserResolvable|boolean} [member] The member to fetch. If `undefined`, all members\n   * in the thread are fetched, and will be cached based on `options.cache`. If boolean, this serves\n   * the purpose of `options.cache`.\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<ThreadMember|Collection<Snowflake, ThreadMember>>}\n   */\n  fetch(member, { cache = true, force = false } = {}) {\n    const id = this.resolveId(member);\n    return id ? this._fetchOne(id, cache, force) : this._fetchMany(member ?? cache);\n  }\n}\n\nmodule.exports = ThreadMemberManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}