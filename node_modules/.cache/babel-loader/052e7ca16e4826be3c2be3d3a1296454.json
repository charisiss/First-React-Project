{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst CachedManager = require('./CachedManager');\n\nconst {\n  TypeError\n} = require('../errors');\n\nconst {\n  Message\n} = require('../structures/Message');\n\nconst MessagePayload = require('../structures/MessagePayload');\n\nconst Util = require('../util/Util');\n/**\n * Manages API methods for Messages and holds their cache.\n * @extends {CachedManager}\n */\n\n\nclass MessageManager extends CachedManager {\n  constructor(channel, iterable) {\n    super(channel.client, Message, iterable);\n    /**\n     * The channel that the messages belong to\n     * @type {TextBasedChannels}\n     */\n\n    this.channel = channel;\n  }\n  /**\n   * The cache of Messages\n   * @type {Collection<Snowflake, Message>}\n   * @name MessageManager#cache\n   */\n\n\n  _add(data, cache) {\n    return super._add(data, cache);\n  }\n  /**\n   * The parameters to pass in when requesting previous messages from a channel. `around`, `before` and\n   * `after` are mutually exclusive. All the parameters are optional.\n   * @typedef {Object} ChannelLogsQueryOptions\n   * @property {number} [limit=50] Number of messages to acquire\n   * @property {Snowflake} [before] The message's id to get the messages that were posted before it\n   * @property {Snowflake} [after] The message's id to get the messages that were posted after it\n   * @property {Snowflake} [around] The message's id to get the messages that were posted around it\n   */\n\n  /**\n   * Gets a message, or messages, from this channel.\n   * <info>The returned Collection does not contain reaction users of the messages if they were not cached.\n   * Those need to be fetched separately in such a case.</info>\n   * @param {Snowflake|ChannelLogsQueryOptions} [message] The id of the message to fetch, or query parameters.\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<Message|Collection<Snowflake, Message>>}\n   * @example\n   * // Get message\n   * channel.messages.fetch('99539446449315840')\n   *   .then(message => console.log(message.content))\n   *   .catch(console.error);\n   * @example\n   * // Get messages\n   * channel.messages.fetch({ limit: 10 })\n   *   .then(messages => console.log(`Received ${messages.size} messages`))\n   *   .catch(console.error);\n   * @example\n   * // Get messages and filter by user id\n   * channel.messages.fetch()\n   *   .then(messages => console.log(`${messages.filter(m => m.author.id === '84484653687267328').size} messages`))\n   *   .catch(console.error);\n   */\n\n\n  fetch(message) {\n    let {\n      cache = true,\n      force = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return typeof message === 'string' ? this._fetchId(message, cache, force) : this._fetchMany(message, cache);\n  }\n  /**\n   * Fetches the pinned messages of this channel and returns a collection of them.\n   * <info>The returned Collection does not contain any reaction data of the messages.\n   * Those need to be fetched separately.</info>\n   * @param {boolean} [cache=true] Whether to cache the message(s)\n   * @returns {Promise<Collection<Snowflake, Message>>}\n   * @example\n   * // Get pinned messages\n   * channel.messages.fetchPinned()\n   *   .then(messages => console.log(`Received ${messages.size} messages`))\n   *   .catch(console.error);\n   */\n\n\n  async fetchPinned() {\n    let cache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    const data = await this.client.api.channels[this.channel.id].pins.get();\n    const messages = new Collection();\n\n    for (const message of data) messages.set(message.id, this._add(message, cache));\n\n    return messages;\n  }\n  /**\n   * Data that can be resolved to a Message object. This can be:\n   * * A Message\n   * * A Snowflake\n   * @typedef {Message|Snowflake} MessageResolvable\n   */\n\n  /**\n   * Resolves a {@link MessageResolvable} to a {@link Message} object.\n   * @method resolve\n   * @memberof MessageManager\n   * @instance\n   * @param {MessageResolvable} message The message resolvable to resolve\n   * @returns {?Message}\n   */\n\n  /**\n   * Resolves a {@link MessageResolvable} to a {@link Message} id.\n   * @method resolveId\n   * @memberof MessageManager\n   * @instance\n   * @param {MessageResolvable} message The message resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Edits a message, even if it's not cached.\n   * @param {MessageResolvable} message The message to edit\n   * @param {string|MessageEditOptions|MessagePayload} options The options to edit the message\n   * @returns {Promise<Message>}\n   */\n\n\n  async edit(message, options) {\n    const messageId = this.resolveId(message);\n    if (!messageId) throw new TypeError('INVALID_TYPE', 'message', 'MessageResolvable');\n    const {\n      data,\n      files\n    } = await (options instanceof MessagePayload ? options : MessagePayload.create(message instanceof Message ? message : this, options)).resolveData().resolveFiles();\n    const d = await this.client.api.channels[this.channel.id].messages[messageId].patch({\n      data,\n      files\n    });\n    const existing = this.cache.get(messageId);\n\n    if (existing) {\n      const clone = existing._clone();\n\n      clone._patch(d);\n\n      return clone;\n    }\n\n    return this._add(d);\n  }\n  /**\n   * Publishes a message in an announcement channel to all channels following it, even if it's not cached.\n   * @param {MessageResolvable} message The message to publish\n   * @returns {Promise<Message>}\n   */\n\n\n  async crosspost(message) {\n    message = this.resolveId(message);\n    if (!message) throw new TypeError('INVALID_TYPE', 'message', 'MessageResolvable');\n    const data = await this.client.api.channels(this.channel.id).messages(message).crosspost.post();\n    return this.cache.get(data.id) ?? this._add(data);\n  }\n  /**\n   * Pins a message to the channel's pinned messages, even if it's not cached.\n   * @param {MessageResolvable} message The message to pin\n   * @returns {Promise<void>}\n   */\n\n\n  async pin(message) {\n    message = this.resolveId(message);\n    if (!message) throw new TypeError('INVALID_TYPE', 'message', 'MessageResolvable');\n    await this.client.api.channels(this.channel.id).pins(message).put();\n  }\n  /**\n   * Unpins a message from the channel's pinned messages, even if it's not cached.\n   * @param {MessageResolvable} message The message to unpin\n   * @returns {Promise<void>}\n   */\n\n\n  async unpin(message) {\n    message = this.resolveId(message);\n    if (!message) throw new TypeError('INVALID_TYPE', 'message', 'MessageResolvable');\n    await this.client.api.channels(this.channel.id).pins(message).delete();\n  }\n  /**\n   * Adds a reaction to a message, even if it's not cached.\n   * @param {MessageResolvable} message The message to react to\n   * @param {EmojiIdentifierResolvable} emoji The emoji to react with\n   * @returns {Promise<void>}\n   */\n\n\n  async react(message, emoji) {\n    message = this.resolveId(message);\n    if (!message) throw new TypeError('INVALID_TYPE', 'message', 'MessageResolvable');\n    emoji = Util.resolvePartialEmoji(emoji);\n    if (!emoji) throw new TypeError('EMOJI_TYPE', 'emoji', 'EmojiIdentifierResolvable');\n    const emojiId = emoji.id ? `${emoji.animated ? 'a:' : ''}${emoji.name}:${emoji.id}` : encodeURIComponent(emoji.name); // eslint-disable-next-line newline-per-chained-call\n\n    await this.client.api.channels(this.channel.id).messages(message).reactions(emojiId, '@me').put();\n  }\n  /**\n   * Deletes a message, even if it's not cached.\n   * @param {MessageResolvable} message The message to delete\n   * @returns {Promise<void>}\n   */\n\n\n  async delete(message) {\n    message = this.resolveId(message);\n    if (!message) throw new TypeError('INVALID_TYPE', 'message', 'MessageResolvable');\n    await this.client.api.channels(this.channel.id).messages(message).delete();\n  }\n\n  async _fetchId(messageId, cache, force) {\n    if (!force) {\n      const existing = this.cache.get(messageId);\n      if (existing && !existing.partial) return existing;\n    }\n\n    const data = await this.client.api.channels[this.channel.id].messages[messageId].get();\n    return this._add(data, cache);\n  }\n\n  async _fetchMany() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let cache = arguments.length > 1 ? arguments[1] : undefined;\n    const data = await this.client.api.channels[this.channel.id].messages.get({\n      query: options\n    });\n    const messages = new Collection();\n\n    for (const message of data) messages.set(message.id, this._add(message, cache));\n\n    return messages;\n  }\n\n}\n\nmodule.exports = MessageManager;","map":{"version":3,"names":["Collection","require","CachedManager","TypeError","Message","MessagePayload","Util","MessageManager","constructor","channel","iterable","client","_add","data","cache","fetch","message","force","_fetchId","_fetchMany","fetchPinned","api","channels","id","pins","get","messages","set","edit","options","messageId","resolveId","files","create","resolveData","resolveFiles","d","patch","existing","clone","_clone","_patch","crosspost","post","pin","put","unpin","delete","react","emoji","resolvePartialEmoji","emojiId","animated","name","encodeURIComponent","reactions","partial","query","module","exports"],"sources":["C:/Users/xsxsam/node_modules/discord.js/src/managers/MessageManager.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst CachedManager = require('./CachedManager');\nconst { TypeError } = require('../errors');\nconst { Message } = require('../structures/Message');\nconst MessagePayload = require('../structures/MessagePayload');\nconst Util = require('../util/Util');\n\n/**\n * Manages API methods for Messages and holds their cache.\n * @extends {CachedManager}\n */\nclass MessageManager extends CachedManager {\n  constructor(channel, iterable) {\n    super(channel.client, Message, iterable);\n\n    /**\n     * The channel that the messages belong to\n     * @type {TextBasedChannels}\n     */\n    this.channel = channel;\n  }\n\n  /**\n   * The cache of Messages\n   * @type {Collection<Snowflake, Message>}\n   * @name MessageManager#cache\n   */\n\n  _add(data, cache) {\n    return super._add(data, cache);\n  }\n\n  /**\n   * The parameters to pass in when requesting previous messages from a channel. `around`, `before` and\n   * `after` are mutually exclusive. All the parameters are optional.\n   * @typedef {Object} ChannelLogsQueryOptions\n   * @property {number} [limit=50] Number of messages to acquire\n   * @property {Snowflake} [before] The message's id to get the messages that were posted before it\n   * @property {Snowflake} [after] The message's id to get the messages that were posted after it\n   * @property {Snowflake} [around] The message's id to get the messages that were posted around it\n   */\n\n  /**\n   * Gets a message, or messages, from this channel.\n   * <info>The returned Collection does not contain reaction users of the messages if they were not cached.\n   * Those need to be fetched separately in such a case.</info>\n   * @param {Snowflake|ChannelLogsQueryOptions} [message] The id of the message to fetch, or query parameters.\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<Message|Collection<Snowflake, Message>>}\n   * @example\n   * // Get message\n   * channel.messages.fetch('99539446449315840')\n   *   .then(message => console.log(message.content))\n   *   .catch(console.error);\n   * @example\n   * // Get messages\n   * channel.messages.fetch({ limit: 10 })\n   *   .then(messages => console.log(`Received ${messages.size} messages`))\n   *   .catch(console.error);\n   * @example\n   * // Get messages and filter by user id\n   * channel.messages.fetch()\n   *   .then(messages => console.log(`${messages.filter(m => m.author.id === '84484653687267328').size} messages`))\n   *   .catch(console.error);\n   */\n  fetch(message, { cache = true, force = false } = {}) {\n    return typeof message === 'string' ? this._fetchId(message, cache, force) : this._fetchMany(message, cache);\n  }\n\n  /**\n   * Fetches the pinned messages of this channel and returns a collection of them.\n   * <info>The returned Collection does not contain any reaction data of the messages.\n   * Those need to be fetched separately.</info>\n   * @param {boolean} [cache=true] Whether to cache the message(s)\n   * @returns {Promise<Collection<Snowflake, Message>>}\n   * @example\n   * // Get pinned messages\n   * channel.messages.fetchPinned()\n   *   .then(messages => console.log(`Received ${messages.size} messages`))\n   *   .catch(console.error);\n   */\n  async fetchPinned(cache = true) {\n    const data = await this.client.api.channels[this.channel.id].pins.get();\n    const messages = new Collection();\n    for (const message of data) messages.set(message.id, this._add(message, cache));\n    return messages;\n  }\n\n  /**\n   * Data that can be resolved to a Message object. This can be:\n   * * A Message\n   * * A Snowflake\n   * @typedef {Message|Snowflake} MessageResolvable\n   */\n\n  /**\n   * Resolves a {@link MessageResolvable} to a {@link Message} object.\n   * @method resolve\n   * @memberof MessageManager\n   * @instance\n   * @param {MessageResolvable} message The message resolvable to resolve\n   * @returns {?Message}\n   */\n\n  /**\n   * Resolves a {@link MessageResolvable} to a {@link Message} id.\n   * @method resolveId\n   * @memberof MessageManager\n   * @instance\n   * @param {MessageResolvable} message The message resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Edits a message, even if it's not cached.\n   * @param {MessageResolvable} message The message to edit\n   * @param {string|MessageEditOptions|MessagePayload} options The options to edit the message\n   * @returns {Promise<Message>}\n   */\n  async edit(message, options) {\n    const messageId = this.resolveId(message);\n    if (!messageId) throw new TypeError('INVALID_TYPE', 'message', 'MessageResolvable');\n\n    const { data, files } = await (options instanceof MessagePayload\n      ? options\n      : MessagePayload.create(message instanceof Message ? message : this, options)\n    )\n      .resolveData()\n      .resolveFiles();\n    const d = await this.client.api.channels[this.channel.id].messages[messageId].patch({ data, files });\n\n    const existing = this.cache.get(messageId);\n    if (existing) {\n      const clone = existing._clone();\n      clone._patch(d);\n      return clone;\n    }\n    return this._add(d);\n  }\n\n  /**\n   * Publishes a message in an announcement channel to all channels following it, even if it's not cached.\n   * @param {MessageResolvable} message The message to publish\n   * @returns {Promise<Message>}\n   */\n  async crosspost(message) {\n    message = this.resolveId(message);\n    if (!message) throw new TypeError('INVALID_TYPE', 'message', 'MessageResolvable');\n\n    const data = await this.client.api.channels(this.channel.id).messages(message).crosspost.post();\n    return this.cache.get(data.id) ?? this._add(data);\n  }\n\n  /**\n   * Pins a message to the channel's pinned messages, even if it's not cached.\n   * @param {MessageResolvable} message The message to pin\n   * @returns {Promise<void>}\n   */\n  async pin(message) {\n    message = this.resolveId(message);\n    if (!message) throw new TypeError('INVALID_TYPE', 'message', 'MessageResolvable');\n\n    await this.client.api.channels(this.channel.id).pins(message).put();\n  }\n\n  /**\n   * Unpins a message from the channel's pinned messages, even if it's not cached.\n   * @param {MessageResolvable} message The message to unpin\n   * @returns {Promise<void>}\n   */\n  async unpin(message) {\n    message = this.resolveId(message);\n    if (!message) throw new TypeError('INVALID_TYPE', 'message', 'MessageResolvable');\n\n    await this.client.api.channels(this.channel.id).pins(message).delete();\n  }\n\n  /**\n   * Adds a reaction to a message, even if it's not cached.\n   * @param {MessageResolvable} message The message to react to\n   * @param {EmojiIdentifierResolvable} emoji The emoji to react with\n   * @returns {Promise<void>}\n   */\n  async react(message, emoji) {\n    message = this.resolveId(message);\n    if (!message) throw new TypeError('INVALID_TYPE', 'message', 'MessageResolvable');\n\n    emoji = Util.resolvePartialEmoji(emoji);\n    if (!emoji) throw new TypeError('EMOJI_TYPE', 'emoji', 'EmojiIdentifierResolvable');\n\n    const emojiId = emoji.id\n      ? `${emoji.animated ? 'a:' : ''}${emoji.name}:${emoji.id}`\n      : encodeURIComponent(emoji.name);\n\n    // eslint-disable-next-line newline-per-chained-call\n    await this.client.api.channels(this.channel.id).messages(message).reactions(emojiId, '@me').put();\n  }\n\n  /**\n   * Deletes a message, even if it's not cached.\n   * @param {MessageResolvable} message The message to delete\n   * @returns {Promise<void>}\n   */\n  async delete(message) {\n    message = this.resolveId(message);\n    if (!message) throw new TypeError('INVALID_TYPE', 'message', 'MessageResolvable');\n\n    await this.client.api.channels(this.channel.id).messages(message).delete();\n  }\n\n  async _fetchId(messageId, cache, force) {\n    if (!force) {\n      const existing = this.cache.get(messageId);\n      if (existing && !existing.partial) return existing;\n    }\n\n    const data = await this.client.api.channels[this.channel.id].messages[messageId].get();\n    return this._add(data, cache);\n  }\n\n  async _fetchMany(options = {}, cache) {\n    const data = await this.client.api.channels[this.channel.id].messages.get({ query: options });\n    const messages = new Collection();\n    for (const message of data) messages.set(message.id, this._add(message, cache));\n    return messages;\n  }\n}\n\nmodule.exports = MessageManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}