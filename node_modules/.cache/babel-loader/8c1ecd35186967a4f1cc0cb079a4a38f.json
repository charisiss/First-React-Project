{"ast":null,"code":"'use strict';\n\nconst process = require('node:process');\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst Base = require('./Base');\n\nconst BaseMessageComponent = require('./BaseMessageComponent');\n\nconst ClientApplication = require('./ClientApplication');\n\nconst InteractionCollector = require('./InteractionCollector');\n\nconst MessageAttachment = require('./MessageAttachment');\n\nconst Embed = require('./MessageEmbed');\n\nconst Mentions = require('./MessageMentions');\n\nconst MessagePayload = require('./MessagePayload');\n\nconst ReactionCollector = require('./ReactionCollector');\n\nconst {\n  Sticker\n} = require('./Sticker');\n\nconst {\n  Error\n} = require('../errors');\n\nconst ReactionManager = require('../managers/ReactionManager');\n\nconst {\n  InteractionTypes,\n  MessageTypes,\n  SystemMessageTypes\n} = require('../util/Constants');\n\nconst MessageFlags = require('../util/MessageFlags');\n\nconst Permissions = require('../util/Permissions');\n\nconst SnowflakeUtil = require('../util/SnowflakeUtil');\n\nconst Util = require('../util/Util');\n/**\n * @type {WeakSet<Message>}\n * @private\n * @internal\n */\n\n\nconst deletedMessages = new WeakSet();\nlet deprecationEmittedForDeleted = false;\n/**\n * Represents a message on Discord.\n * @extends {Base}\n */\n\nclass Message extends Base {\n  constructor(client, data) {\n    super(client);\n    /**\n     * The id of the channel the message was sent in\n     * @type {Snowflake}\n     */\n\n    this.channelId = data.channel_id;\n    /**\n     * The id of the guild the message was sent in, if any\n     * @type {?Snowflake}\n     */\n\n    this.guildId = data.guild_id ?? this.channel?.guild?.id ?? null;\n\n    this._patch(data);\n  }\n\n  _patch(data) {\n    /**\n     * The message's id\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n    /**\n     * The timestamp the message was sent at\n     * @type {number}\n     */\n\n    this.createdTimestamp = SnowflakeUtil.timestampFrom(this.id);\n\n    if ('type' in data) {\n      /**\n       * The type of the message\n       * @type {?MessageType}\n       */\n      this.type = MessageTypes[data.type];\n      /**\n       * Whether or not this message was sent by Discord, not actually a user (e.g. pin notifications)\n       * @type {?boolean}\n       */\n\n      this.system = SystemMessageTypes.includes(this.type);\n    } else {\n      this.system ??= null;\n      this.type ??= null;\n    }\n\n    if ('content' in data) {\n      /**\n       * The content of the message\n       * @type {?string}\n       */\n      this.content = data.content;\n    } else {\n      this.content ??= null;\n    }\n\n    if ('author' in data) {\n      /**\n       * The author of the message\n       * @type {?User}\n       */\n      this.author = this.client.users._add(data.author, !data.webhook_id);\n    } else {\n      this.author ??= null;\n    }\n\n    if ('pinned' in data) {\n      /**\n       * Whether or not this message is pinned\n       * @type {?boolean}\n       */\n      this.pinned = Boolean(data.pinned);\n    } else {\n      this.pinned ??= null;\n    }\n\n    if ('tts' in data) {\n      /**\n       * Whether or not the message was Text-To-Speech\n       * @type {?boolean}\n       */\n      this.tts = data.tts;\n    } else {\n      this.tts ??= null;\n    }\n\n    if ('nonce' in data) {\n      /**\n       * A random number or string used for checking message delivery\n       * <warn>This is only received after the message was sent successfully, and\n       * lost if re-fetched</warn>\n       * @type {?string}\n       */\n      this.nonce = data.nonce;\n    } else {\n      this.nonce ??= null;\n    }\n\n    if ('embeds' in data) {\n      /**\n       * A list of embeds in the message - e.g. YouTube Player\n       * @type {MessageEmbed[]}\n       */\n      this.embeds = data.embeds.map(e => new Embed(e, true));\n    } else {\n      this.embeds = this.embeds?.slice() ?? [];\n    }\n\n    if ('components' in data) {\n      /**\n       * A list of MessageActionRows in the message\n       * @type {MessageActionRow[]}\n       */\n      this.components = data.components.map(c => BaseMessageComponent.create(c, this.client));\n    } else {\n      this.components = this.components?.slice() ?? [];\n    }\n\n    if ('attachments' in data) {\n      /**\n       * A collection of attachments in the message - e.g. Pictures - mapped by their ids\n       * @type {Collection<Snowflake, MessageAttachment>}\n       */\n      this.attachments = new Collection();\n\n      if (data.attachments) {\n        for (const attachment of data.attachments) {\n          this.attachments.set(attachment.id, new MessageAttachment(attachment.url, attachment.filename, attachment));\n        }\n      }\n    } else {\n      this.attachments = new Collection(this.attachments);\n    }\n\n    if ('sticker_items' in data || 'stickers' in data) {\n      /**\n       * A collection of stickers in the message\n       * @type {Collection<Snowflake, Sticker>}\n       */\n      this.stickers = new Collection((data.sticker_items ?? data.stickers)?.map(s => [s.id, new Sticker(this.client, s)]));\n    } else {\n      this.stickers = new Collection(this.stickers);\n    } // Discord sends null if the message has not been edited\n\n\n    if (data.edited_timestamp) {\n      /**\n       * The timestamp the message was last edited at (if applicable)\n       * @type {?number}\n       */\n      this.editedTimestamp = new Date(data.edited_timestamp).getTime();\n    } else {\n      this.editedTimestamp ??= null;\n    }\n\n    if ('reactions' in data) {\n      /**\n       * A manager of the reactions belonging to this message\n       * @type {ReactionManager}\n       */\n      this.reactions = new ReactionManager(this);\n\n      if (data.reactions?.length > 0) {\n        for (const reaction of data.reactions) {\n          this.reactions._add(reaction);\n        }\n      }\n    } else {\n      this.reactions ??= new ReactionManager(this);\n    }\n\n    if (!this.mentions) {\n      /**\n       * All valid mentions that the message contains\n       * @type {MessageMentions}\n       */\n      this.mentions = new Mentions(this, data.mentions, data.mention_roles, data.mention_everyone, data.mention_channels, data.referenced_message?.author);\n    } else {\n      this.mentions = new Mentions(this, data.mentions ?? this.mentions.users, data.mention_roles ?? this.mentions.roles, data.mention_everyone ?? this.mentions.everyone, data.mention_channels ?? this.mentions.crosspostedChannels, data.referenced_message?.author ?? this.mentions.repliedUser);\n    }\n\n    if ('webhook_id' in data) {\n      /**\n       * The id of the webhook that sent the message, if applicable\n       * @type {?Snowflake}\n       */\n      this.webhookId = data.webhook_id;\n    } else {\n      this.webhookId ??= null;\n    }\n\n    if ('application' in data) {\n      /**\n       * Supplemental application information for group activities\n       * @type {?ClientApplication}\n       */\n      this.groupActivityApplication = new ClientApplication(this.client, data.application);\n    } else {\n      this.groupActivityApplication ??= null;\n    }\n\n    if ('application_id' in data) {\n      /**\n       * The id of the application of the interaction that sent this message, if any\n       * @type {?Snowflake}\n       */\n      this.applicationId = data.application_id;\n    } else {\n      this.applicationId ??= null;\n    }\n\n    if ('activity' in data) {\n      /**\n       * Group activity\n       * @type {?MessageActivity}\n       */\n      this.activity = {\n        partyId: data.activity.party_id,\n        type: data.activity.type\n      };\n    } else {\n      this.activity ??= null;\n    }\n\n    if ('thread' in data) {\n      this.client.channels._add(data.thread, this.guild);\n    }\n\n    if (this.member && data.member) {\n      this.member._patch(data.member);\n    } else if (data.member && this.guild && this.author) {\n      this.guild.members._add(Object.assign(data.member, {\n        user: this.author\n      }));\n    }\n\n    if ('flags' in data) {\n      /**\n       * Flags that are applied to the message\n       * @type {Readonly<MessageFlags>}\n       */\n      this.flags = new MessageFlags(data.flags).freeze();\n    } else {\n      this.flags = new MessageFlags(this.flags).freeze();\n    }\n    /**\n     * Reference data sent in a message that contains ids identifying the referenced message.\n     * This can be present in the following types of message:\n     * * Crossposted messages (IS_CROSSPOST {@link MessageFlags.FLAGS message flag})\n     * * CHANNEL_FOLLOW_ADD\n     * * CHANNEL_PINNED_MESSAGE\n     * * REPLY\n     * * THREAD_STARTER_MESSAGE\n     * @see {@link https://discord.com/developers/docs/resources/channel#message-types}\n     * @typedef {Object} MessageReference\n     * @property {Snowflake} channelId The channel's id the message was referenced\n     * @property {?Snowflake} guildId The guild's id the message was referenced\n     * @property {?Snowflake} messageId The message's id that was referenced\n     */\n\n\n    if ('message_reference' in data) {\n      /**\n       * Message reference data\n       * @type {?MessageReference}\n       */\n      this.reference = {\n        channelId: data.message_reference.channel_id,\n        guildId: data.message_reference.guild_id,\n        messageId: data.message_reference.message_id\n      };\n    } else {\n      this.reference ??= null;\n    }\n\n    if (data.referenced_message) {\n      this.channel?.messages._add({\n        guild_id: data.message_reference?.guild_id,\n        ...data.referenced_message\n      });\n    }\n    /**\n     * Partial data of the interaction that a message is a reply to\n     * @typedef {Object} MessageInteraction\n     * @property {Snowflake} id The interaction's id\n     * @property {InteractionType} type The type of the interaction\n     * @property {string} commandName The name of the interaction's application command\n     * @property {User} user The user that invoked the interaction\n     */\n\n\n    if (data.interaction) {\n      /**\n       * Partial data of the interaction that this message is a reply to\n       * @type {?MessageInteraction}\n       */\n      this.interaction = {\n        id: data.interaction.id,\n        type: InteractionTypes[data.interaction.type],\n        commandName: data.interaction.name,\n        user: this.client.users._add(data.interaction.user)\n      };\n    } else {\n      this.interaction ??= null;\n    }\n  }\n  /**\n   * Whether or not the structure has been deleted\n   * @type {boolean}\n   * @deprecated This will be removed in the next major version, see https://github.com/discordjs/discord.js/issues/7091\n   */\n\n\n  get deleted() {\n    if (!deprecationEmittedForDeleted) {\n      deprecationEmittedForDeleted = true;\n      process.emitWarning('Message#deleted is deprecated, see https://github.com/discordjs/discord.js/issues/7091.', 'DeprecationWarning');\n    }\n\n    return deletedMessages.has(this);\n  }\n\n  set deleted(value) {\n    if (!deprecationEmittedForDeleted) {\n      deprecationEmittedForDeleted = true;\n      process.emitWarning('Message#deleted is deprecated, see https://github.com/discordjs/discord.js/issues/7091.', 'DeprecationWarning');\n    }\n\n    if (value) deletedMessages.add(this);else deletedMessages.delete(this);\n  }\n  /**\n   * The channel that the message was sent in\n   * @type {TextChannel|DMChannel|NewsChannel|ThreadChannel}\n   * @readonly\n   */\n\n\n  get channel() {\n    return this.client.channels.resolve(this.channelId);\n  }\n  /**\n   * Whether or not this message is a partial\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get partial() {\n    return typeof this.content !== 'string' || !this.author;\n  }\n  /**\n   * Represents the author of the message as a guild member.\n   * Only available if the message comes from a guild where the author is still a member\n   * @type {?GuildMember}\n   * @readonly\n   */\n\n\n  get member() {\n    return this.guild?.members.resolve(this.author) ?? null;\n  }\n  /**\n   * The time the message was sent at\n   * @type {Date}\n   * @readonly\n   */\n\n\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n  /**\n   * The time the message was last edited at (if applicable)\n   * @type {?Date}\n   * @readonly\n   */\n\n\n  get editedAt() {\n    return this.editedTimestamp ? new Date(this.editedTimestamp) : null;\n  }\n  /**\n   * The guild the message was sent in (if in a guild channel)\n   * @type {?Guild}\n   * @readonly\n   */\n\n\n  get guild() {\n    return this.client.guilds.resolve(this.guildId) ?? this.channel?.guild ?? null;\n  }\n  /**\n   * Whether this message has a thread associated with it\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get hasThread() {\n    return this.flags.has(MessageFlags.FLAGS.HAS_THREAD);\n  }\n  /**\n   * The thread started by this message\n   * <info>This property is not suitable for checking whether a message has a thread,\n   * use {@link Message#hasThread} instead.</info>\n   * @type {?ThreadChannel}\n   * @readonly\n   */\n\n\n  get thread() {\n    return this.channel?.threads?.resolve(this.id) ?? null;\n  }\n  /**\n   * The URL to jump to this message\n   * @type {string}\n   * @readonly\n   */\n\n\n  get url() {\n    return `https://discord.com/channels/${this.guildId ?? '@me'}/${this.channelId}/${this.id}`;\n  }\n  /**\n   * The message contents with all mentions replaced by the equivalent text.\n   * If mentions cannot be resolved to a name, the relevant mention in the message content will not be converted.\n   * @type {?string}\n   * @readonly\n   */\n\n\n  get cleanContent() {\n    // eslint-disable-next-line eqeqeq\n    return this.content != null ? Util.cleanContent(this.content, this.channel) : null;\n  }\n  /**\n   * Creates a reaction collector.\n   * @param {ReactionCollectorOptions} [options={}] Options to send to the collector\n   * @returns {ReactionCollector}\n   * @example\n   * // Create a reaction collector\n   * const filter = (reaction, user) => reaction.emoji.name === 'ðŸ‘Œ' && user.id === 'someId';\n   * const collector = message.createReactionCollector({ filter, time: 15_000 });\n   * collector.on('collect', r => console.log(`Collected ${r.emoji.name}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n\n\n  createReactionCollector() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new ReactionCollector(this, options);\n  }\n  /**\n   * An object containing the same properties as CollectorOptions, but a few more:\n   * @typedef {ReactionCollectorOptions} AwaitReactionsOptions\n   * @property {string[]} [errors] Stop/end reasons that cause the promise to reject\n   */\n\n  /**\n   * Similar to createReactionCollector but in promise form.\n   * Resolves with a collection of reactions that pass the specified filter.\n   * @param {AwaitReactionsOptions} [options={}] Optional options to pass to the internal collector\n   * @returns {Promise<Collection<string | Snowflake, MessageReaction>>}\n   * @example\n   * // Create a reaction collector\n   * const filter = (reaction, user) => reaction.emoji.name === 'ðŸ‘Œ' && user.id === 'someId'\n   * message.awaitReactions({ filter, time: 15_000 })\n   *   .then(collected => console.log(`Collected ${collected.size} reactions`))\n   *   .catch(console.error);\n   */\n\n\n  awaitReactions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new Promise((resolve, reject) => {\n      const collector = this.createReactionCollector(options);\n      collector.once('end', (reactions, reason) => {\n        if (options.errors?.includes(reason)) reject(reactions);else resolve(reactions);\n      });\n    });\n  }\n  /**\n   * @typedef {CollectorOptions} MessageComponentCollectorOptions\n   * @property {MessageComponentType} [componentType] The type of component to listen for\n   * @property {number} [max] The maximum total amount of interactions to collect\n   * @property {number} [maxComponents] The maximum number of components to collect\n   * @property {number} [maxUsers] The maximum number of users to interact\n   */\n\n  /**\n   * Creates a message component interaction collector.\n   * @param {MessageComponentCollectorOptions} [options={}] Options to send to the collector\n   * @returns {InteractionCollector}\n   * @example\n   * // Create a message component interaction collector\n   * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';\n   * const collector = message.createMessageComponentCollector({ filter, time: 15_000 });\n   * collector.on('collect', i => console.log(`Collected ${i.customId}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n\n\n  createMessageComponentCollector() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new InteractionCollector(this.client, { ...options,\n      interactionType: InteractionTypes.MESSAGE_COMPONENT,\n      message: this\n    });\n  }\n  /**\n   * An object containing the same properties as CollectorOptions, but a few more:\n   * @typedef {Object} AwaitMessageComponentOptions\n   * @property {CollectorFilter} [filter] The filter applied to this collector\n   * @property {number} [time] Time to wait for an interaction before rejecting\n   * @property {MessageComponentType} [componentType] The type of component interaction to collect\n   */\n\n  /**\n   * Collects a single component interaction that passes the filter.\n   * The Promise will reject if the time expires.\n   * @param {AwaitMessageComponentOptions} [options={}] Options to pass to the internal collector\n   * @returns {Promise<MessageComponentInteraction>}\n   * @example\n   * // Collect a message component interaction\n   * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';\n   * message.awaitMessageComponent({ filter, time: 15_000 })\n   *   .then(interaction => console.log(`${interaction.customId} was clicked!`))\n   *   .catch(console.error);\n   */\n\n\n  awaitMessageComponent() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const _options = { ...options,\n      max: 1\n    };\n    return new Promise((resolve, reject) => {\n      const collector = this.createMessageComponentCollector(_options);\n      collector.once('end', (interactions, reason) => {\n        const interaction = interactions.first();\n        if (interaction) resolve(interaction);else reject(new Error('INTERACTION_COLLECTOR_ERROR', reason));\n      });\n    });\n  }\n  /**\n   * Whether the message is editable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get editable() {\n    const precheck = Boolean(this.author.id === this.client.user.id && !deletedMessages.has(this) && (!this.guild || this.channel?.viewable)); // Regardless of permissions thread messages cannot be edited if\n    // the thread is locked.\n\n    if (this.channel?.isThread()) {\n      return precheck && !this.channel.locked;\n    }\n\n    return precheck;\n  }\n  /**\n   * Whether the message is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get deletable() {\n    if (deletedMessages.has(this)) {\n      return false;\n    }\n\n    if (!this.guild) {\n      return this.author.id === this.client.user.id;\n    } // DMChannel does not have viewable property, so check viewable after proved that message is on a guild.\n\n\n    if (!this.channel?.viewable) {\n      return false;\n    }\n\n    const permissions = this.channel?.permissionsFor(this.client.user);\n    if (!permissions) return false; // This flag allows deleting even if timed out\n\n    if (permissions.has(Permissions.FLAGS.ADMINISTRATOR, false)) return true;\n    return Boolean(this.author.id === this.client.user.id || permissions.has(Permissions.FLAGS.MANAGE_MESSAGES, false) && this.guild.me.communicationDisabledUntilTimestamp < Date.now());\n  }\n  /**\n   * Whether the message is pinnable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get pinnable() {\n    const {\n      channel\n    } = this;\n    return Boolean(!this.system && !deletedMessages.has(this) && (!this.guild || channel?.viewable && channel?.permissionsFor(this.client.user)?.has(Permissions.FLAGS.MANAGE_MESSAGES, false)));\n  }\n  /**\n   * Fetches the Message this crosspost/reply/pin-add references, if available to the client\n   * @returns {Promise<Message>}\n   */\n\n\n  async fetchReference() {\n    if (!this.reference) throw new Error('MESSAGE_REFERENCE_MISSING');\n    const {\n      channelId,\n      messageId\n    } = this.reference;\n    const channel = this.client.channels.resolve(channelId);\n    if (!channel) throw new Error('GUILD_CHANNEL_RESOLVE');\n    const message = await channel.messages.fetch(messageId);\n    return message;\n  }\n  /**\n   * Whether the message is crosspostable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  get crosspostable() {\n    const bitfield = Permissions.FLAGS.SEND_MESSAGES | (this.author.id === this.client.user.id ? Permissions.defaultBit : Permissions.FLAGS.MANAGE_MESSAGES);\n    const {\n      channel\n    } = this;\n    return Boolean(channel?.type === 'GUILD_NEWS' && !this.flags.has(MessageFlags.FLAGS.CROSSPOSTED) && this.type === 'DEFAULT' && channel.viewable && channel.permissionsFor(this.client.user)?.has(bitfield, false) && !deletedMessages.has(this));\n  }\n  /**\n   * Options that can be passed into {@link Message#edit}.\n   * @typedef {Object} MessageEditOptions\n   * @property {?string} [content] Content to be edited\n   * @property {MessageEmbed[]|APIEmbed[]} [embeds] Embeds to be added/edited\n   * @property {MessageMentionOptions} [allowedMentions] Which mentions should be parsed from the message content\n   * @property {MessageFlags} [flags] Which flags to set for the message. Only `SUPPRESS_EMBEDS` can be edited.\n   * @property {MessageAttachment[]} [attachments] An array of attachments to keep,\n   * all attachments will be kept if omitted\n   * @property {FileOptions[]|BufferResolvable[]|MessageAttachment[]} [files] Files to add to the message\n   * @property {MessageActionRow[]|MessageActionRowOptions[]} [components]\n   * Action rows containing interactive components for the message (buttons, select menus)\n   */\n\n  /**\n   * Edits the content of the message.\n   * @param {string|MessagePayload|MessageEditOptions} options The options to provide\n   * @returns {Promise<Message>}\n   * @example\n   * // Update the content of a message\n   * message.edit('This is my new content!')\n   *   .then(msg => console.log(`Updated the content of a message to ${msg.content}`))\n   *   .catch(console.error);\n   */\n\n\n  edit(options) {\n    if (!this.channel) return Promise.reject(new Error('CHANNEL_NOT_CACHED'));\n    return this.channel.messages.edit(this, options);\n  }\n  /**\n   * Publishes a message in an announcement channel to all channels following it.\n   * @returns {Promise<Message>}\n   * @example\n   * // Crosspost a message\n   * if (message.channel.type === 'GUILD_NEWS') {\n   *   message.crosspost()\n   *     .then(() => console.log('Crossposted message'))\n   *     .catch(console.error);\n   * }\n   */\n\n\n  crosspost() {\n    if (!this.channel) return Promise.reject(new Error('CHANNEL_NOT_CACHED'));\n    return this.channel.messages.crosspost(this.id);\n  }\n  /**\n   * Pins this message to the channel's pinned messages.\n   * @returns {Promise<Message>}\n   * @example\n   * // Pin a message\n   * message.pin()\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n\n\n  async pin() {\n    if (!this.channel) throw new Error('CHANNEL_NOT_CACHED');\n    await this.channel.messages.pin(this.id);\n    return this;\n  }\n  /**\n   * Unpins this message from the channel's pinned messages.\n   * @returns {Promise<Message>}\n   * @example\n   * // Unpin a message\n   * message.unpin()\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n\n\n  async unpin() {\n    if (!this.channel) throw new Error('CHANNEL_NOT_CACHED');\n    await this.channel.messages.unpin(this.id);\n    return this;\n  }\n  /**\n   * Adds a reaction to the message.\n   * @param {EmojiIdentifierResolvable} emoji The emoji to react with\n   * @returns {Promise<MessageReaction>}\n   * @example\n   * // React to a message with a unicode emoji\n   * message.react('ðŸ¤”')\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // React to a message with a custom emoji\n   * message.react(message.guild.emojis.cache.get('123456789012345678'))\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  async react(emoji) {\n    if (!this.channel) throw new Error('CHANNEL_NOT_CACHED');\n    await this.channel.messages.react(this.id, emoji);\n    return this.client.actions.MessageReactionAdd.handle({\n      user: this.client.user,\n      channel: this.channel,\n      message: this,\n      emoji: Util.resolvePartialEmoji(emoji)\n    }, true).reaction;\n  }\n  /**\n   * Deletes the message.\n   * @returns {Promise<Message>}\n   * @example\n   * // Delete a message\n   * message.delete()\n   *   .then(msg => console.log(`Deleted message from ${msg.author.username}`))\n   *   .catch(console.error);\n   */\n\n\n  async delete() {\n    if (!this.channel) throw new Error('CHANNEL_NOT_CACHED');\n    await this.channel.messages.delete(this.id);\n    return this;\n  }\n  /**\n   * Options provided when sending a message as an inline reply.\n   * @typedef {BaseMessageOptions} ReplyMessageOptions\n   * @property {boolean} [failIfNotExists=true] Whether to error if the referenced message\n   * does not exist (creates a standard message in this case when false)\n   * @property {StickerResolvable[]} [stickers=[]] Stickers to send in the message\n   */\n\n  /**\n   * Send an inline reply to this message.\n   * @param {string|MessagePayload|ReplyMessageOptions} options The options to provide\n   * @returns {Promise<Message>}\n   * @example\n   * // Reply to a message\n   * message.reply('This is a reply!')\n   *   .then(() => console.log(`Replied to message \"${message.content}\"`))\n   *   .catch(console.error);\n   */\n\n\n  reply(options) {\n    if (!this.channel) return Promise.reject(new Error('CHANNEL_NOT_CACHED'));\n    let data;\n\n    if (options instanceof MessagePayload) {\n      data = options;\n    } else {\n      data = MessagePayload.create(this, options, {\n        reply: {\n          messageReference: this,\n          failIfNotExists: options?.failIfNotExists ?? this.client.options.failIfNotExists\n        }\n      });\n    }\n\n    return this.channel.send(data);\n  }\n  /**\n   * A number that is allowed to be the duration (in minutes) of inactivity after which a thread is automatically\n   * archived. This can be:\n   * * `60` (1 hour)\n   * * `1440` (1 day)\n   * * `4320` (3 days) <warn>This is only available when the guild has the `THREE_DAY_THREAD_ARCHIVE` feature.</warn>\n   * * `10080` (7 days) <warn>This is only available when the guild has the `SEVEN_DAY_THREAD_ARCHIVE` feature.</warn>\n   * * `'MAX'` Based on the guild's features\n   * @typedef {number|string} ThreadAutoArchiveDuration\n   */\n\n  /**\n   * Options for starting a thread on a message.\n   * @typedef {Object} StartThreadOptions\n   * @property {string} name The name of the new thread\n   * @property {ThreadAutoArchiveDuration} [autoArchiveDuration=this.channel.defaultAutoArchiveDuration] The amount of\n   * time (in minutes) after which the thread should automatically archive in case of no recent activity\n   * @property {string} [reason] Reason for creating the thread\n   * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the thread in seconds\n   */\n\n  /**\n   * Create a new public thread from this message\n   * @see ThreadManager#create\n   * @param {StartThreadOptions} [options] Options for starting a thread on this message\n   * @returns {Promise<ThreadChannel>}\n   */\n\n\n  startThread() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!this.channel) return Promise.reject(new Error('CHANNEL_NOT_CACHED'));\n\n    if (!['GUILD_TEXT', 'GUILD_NEWS'].includes(this.channel.type)) {\n      return Promise.reject(new Error('MESSAGE_THREAD_PARENT'));\n    }\n\n    if (this.hasThread) return Promise.reject(new Error('MESSAGE_EXISTING_THREAD'));\n    return this.channel.threads.create({ ...options,\n      startMessage: this\n    });\n  }\n  /**\n   * Fetch this message.\n   * @param {boolean} [force=true] Whether to skip the cache check and request the API\n   * @returns {Promise<Message>}\n   */\n\n\n  fetch() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (!this.channel) return Promise.reject(new Error('CHANNEL_NOT_CACHED'));\n    return this.channel.messages.fetch(this.id, {\n      force\n    });\n  }\n  /**\n   * Fetches the webhook used to create this message.\n   * @returns {Promise<?Webhook>}\n   */\n\n\n  fetchWebhook() {\n    if (!this.webhookId) return Promise.reject(new Error('WEBHOOK_MESSAGE'));\n    if (this.webhookId === this.applicationId) return Promise.reject(new Error('WEBHOOK_APPLICATION'));\n    return this.client.fetchWebhook(this.webhookId);\n  }\n  /**\n   * Suppresses or unsuppresses embeds on a message.\n   * @param {boolean} [suppress=true] If the embeds should be suppressed or not\n   * @returns {Promise<Message>}\n   */\n\n\n  suppressEmbeds() {\n    let suppress = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    const flags = new MessageFlags(this.flags.bitfield);\n\n    if (suppress) {\n      flags.add(MessageFlags.FLAGS.SUPPRESS_EMBEDS);\n    } else {\n      flags.remove(MessageFlags.FLAGS.SUPPRESS_EMBEDS);\n    }\n\n    return this.edit({\n      flags\n    });\n  }\n  /**\n   * Removes the attachments from this message.\n   * @returns {Promise<Message>}\n   */\n\n\n  removeAttachments() {\n    return this.edit({\n      attachments: []\n    });\n  }\n  /**\n   * Resolves a component by a custom id.\n   * @param {string} customId The custom id to resolve against\n   * @returns {?MessageActionRowComponent}\n   */\n\n\n  resolveComponent(customId) {\n    return this.components.flatMap(row => row.components).find(component => component.customId === customId) ?? null;\n  }\n  /**\n   * Used mainly internally. Whether two messages are identical in properties. If you want to compare messages\n   * without checking all the properties, use `message.id === message2.id`, which is much more efficient. This\n   * method allows you to see if there are differences in content, embeds, attachments, nonce and tts properties.\n   * @param {Message} message The message to compare it to\n   * @param {APIMessage} rawData Raw data passed through the WebSocket about this message\n   * @returns {boolean}\n   */\n\n\n  equals(message, rawData) {\n    if (!message) return false;\n    const embedUpdate = !message.author && !message.attachments;\n    if (embedUpdate) return this.id === message.id && this.embeds.length === message.embeds.length;\n    let equal = this.id === message.id && this.author.id === message.author.id && this.content === message.content && this.tts === message.tts && this.nonce === message.nonce && this.embeds.length === message.embeds.length && this.attachments.length === message.attachments.length;\n\n    if (equal && rawData) {\n      equal = this.mentions.everyone === message.mentions.everyone && this.createdTimestamp === new Date(rawData.timestamp).getTime() && this.editedTimestamp === new Date(rawData.edited_timestamp).getTime();\n    }\n\n    return equal;\n  }\n  /**\n   * Whether this message is from a guild.\n   * @returns {boolean}\n   */\n\n\n  inGuild() {\n    return Boolean(this.guildId);\n  }\n  /**\n   * When concatenated with a string, this automatically concatenates the message's content instead of the object.\n   * @returns {string}\n   * @example\n   * // Logs: Message: This is a message!\n   * console.log(`Message: ${message}`);\n   */\n\n\n  toString() {\n    return this.content;\n  }\n\n  toJSON() {\n    return super.toJSON({\n      channel: 'channelId',\n      author: 'authorId',\n      groupActivityApplication: 'groupActivityApplicationId',\n      guild: 'guildId',\n      cleanContent: true,\n      member: false,\n      reactions: false\n    });\n  }\n\n}\n\nexports.Message = Message;\nexports.deletedMessages = deletedMessages;","map":{"version":3,"names":["process","require","Collection","Base","BaseMessageComponent","ClientApplication","InteractionCollector","MessageAttachment","Embed","Mentions","MessagePayload","ReactionCollector","Sticker","Error","ReactionManager","InteractionTypes","MessageTypes","SystemMessageTypes","MessageFlags","Permissions","SnowflakeUtil","Util","deletedMessages","WeakSet","deprecationEmittedForDeleted","Message","constructor","client","data","channelId","channel_id","guildId","guild_id","channel","guild","id","_patch","createdTimestamp","timestampFrom","type","system","includes","content","author","users","_add","webhook_id","pinned","Boolean","tts","nonce","embeds","map","e","slice","components","c","create","attachments","attachment","set","url","filename","stickers","sticker_items","s","edited_timestamp","editedTimestamp","Date","getTime","reactions","length","reaction","mentions","mention_roles","mention_everyone","mention_channels","referenced_message","roles","everyone","crosspostedChannels","repliedUser","webhookId","groupActivityApplication","application","applicationId","application_id","activity","partyId","party_id","channels","thread","member","members","Object","assign","user","flags","freeze","reference","message_reference","messageId","message_id","messages","interaction","commandName","name","deleted","emitWarning","has","value","add","delete","resolve","partial","createdAt","editedAt","guilds","hasThread","FLAGS","HAS_THREAD","threads","cleanContent","createReactionCollector","options","awaitReactions","Promise","reject","collector","once","reason","errors","createMessageComponentCollector","interactionType","MESSAGE_COMPONENT","message","awaitMessageComponent","_options","max","interactions","first","editable","precheck","viewable","isThread","locked","deletable","permissions","permissionsFor","ADMINISTRATOR","MANAGE_MESSAGES","me","communicationDisabledUntilTimestamp","now","pinnable","fetchReference","fetch","crosspostable","bitfield","SEND_MESSAGES","defaultBit","CROSSPOSTED","edit","crosspost","pin","unpin","react","emoji","actions","MessageReactionAdd","handle","resolvePartialEmoji","reply","messageReference","failIfNotExists","send","startThread","startMessage","force","fetchWebhook","suppressEmbeds","suppress","SUPPRESS_EMBEDS","remove","removeAttachments","resolveComponent","customId","flatMap","row","find","component","equals","rawData","embedUpdate","equal","timestamp","inGuild","toString","toJSON","exports"],"sources":["C:/Users/xsxsam/node_modules/discord.js/src/structures/Message.js"],"sourcesContent":["'use strict';\n\nconst process = require('node:process');\nconst { Collection } = require('@discordjs/collection');\nconst Base = require('./Base');\nconst BaseMessageComponent = require('./BaseMessageComponent');\nconst ClientApplication = require('./ClientApplication');\nconst InteractionCollector = require('./InteractionCollector');\nconst MessageAttachment = require('./MessageAttachment');\nconst Embed = require('./MessageEmbed');\nconst Mentions = require('./MessageMentions');\nconst MessagePayload = require('./MessagePayload');\nconst ReactionCollector = require('./ReactionCollector');\nconst { Sticker } = require('./Sticker');\nconst { Error } = require('../errors');\nconst ReactionManager = require('../managers/ReactionManager');\nconst { InteractionTypes, MessageTypes, SystemMessageTypes } = require('../util/Constants');\nconst MessageFlags = require('../util/MessageFlags');\nconst Permissions = require('../util/Permissions');\nconst SnowflakeUtil = require('../util/SnowflakeUtil');\nconst Util = require('../util/Util');\n\n/**\n * @type {WeakSet<Message>}\n * @private\n * @internal\n */\nconst deletedMessages = new WeakSet();\nlet deprecationEmittedForDeleted = false;\n\n/**\n * Represents a message on Discord.\n * @extends {Base}\n */\nclass Message extends Base {\n  constructor(client, data) {\n    super(client);\n\n    /**\n     * The id of the channel the message was sent in\n     * @type {Snowflake}\n     */\n    this.channelId = data.channel_id;\n\n    /**\n     * The id of the guild the message was sent in, if any\n     * @type {?Snowflake}\n     */\n    this.guildId = data.guild_id ?? this.channel?.guild?.id ?? null;\n\n    this._patch(data);\n  }\n\n  _patch(data) {\n    /**\n     * The message's id\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n\n    /**\n     * The timestamp the message was sent at\n     * @type {number}\n     */\n    this.createdTimestamp = SnowflakeUtil.timestampFrom(this.id);\n\n    if ('type' in data) {\n      /**\n       * The type of the message\n       * @type {?MessageType}\n       */\n      this.type = MessageTypes[data.type];\n\n      /**\n       * Whether or not this message was sent by Discord, not actually a user (e.g. pin notifications)\n       * @type {?boolean}\n       */\n      this.system = SystemMessageTypes.includes(this.type);\n    } else {\n      this.system ??= null;\n      this.type ??= null;\n    }\n\n    if ('content' in data) {\n      /**\n       * The content of the message\n       * @type {?string}\n       */\n      this.content = data.content;\n    } else {\n      this.content ??= null;\n    }\n\n    if ('author' in data) {\n      /**\n       * The author of the message\n       * @type {?User}\n       */\n      this.author = this.client.users._add(data.author, !data.webhook_id);\n    } else {\n      this.author ??= null;\n    }\n\n    if ('pinned' in data) {\n      /**\n       * Whether or not this message is pinned\n       * @type {?boolean}\n       */\n      this.pinned = Boolean(data.pinned);\n    } else {\n      this.pinned ??= null;\n    }\n\n    if ('tts' in data) {\n      /**\n       * Whether or not the message was Text-To-Speech\n       * @type {?boolean}\n       */\n      this.tts = data.tts;\n    } else {\n      this.tts ??= null;\n    }\n\n    if ('nonce' in data) {\n      /**\n       * A random number or string used for checking message delivery\n       * <warn>This is only received after the message was sent successfully, and\n       * lost if re-fetched</warn>\n       * @type {?string}\n       */\n      this.nonce = data.nonce;\n    } else {\n      this.nonce ??= null;\n    }\n\n    if ('embeds' in data) {\n      /**\n       * A list of embeds in the message - e.g. YouTube Player\n       * @type {MessageEmbed[]}\n       */\n      this.embeds = data.embeds.map(e => new Embed(e, true));\n    } else {\n      this.embeds = this.embeds?.slice() ?? [];\n    }\n\n    if ('components' in data) {\n      /**\n       * A list of MessageActionRows in the message\n       * @type {MessageActionRow[]}\n       */\n      this.components = data.components.map(c => BaseMessageComponent.create(c, this.client));\n    } else {\n      this.components = this.components?.slice() ?? [];\n    }\n\n    if ('attachments' in data) {\n      /**\n       * A collection of attachments in the message - e.g. Pictures - mapped by their ids\n       * @type {Collection<Snowflake, MessageAttachment>}\n       */\n      this.attachments = new Collection();\n      if (data.attachments) {\n        for (const attachment of data.attachments) {\n          this.attachments.set(attachment.id, new MessageAttachment(attachment.url, attachment.filename, attachment));\n        }\n      }\n    } else {\n      this.attachments = new Collection(this.attachments);\n    }\n\n    if ('sticker_items' in data || 'stickers' in data) {\n      /**\n       * A collection of stickers in the message\n       * @type {Collection<Snowflake, Sticker>}\n       */\n      this.stickers = new Collection(\n        (data.sticker_items ?? data.stickers)?.map(s => [s.id, new Sticker(this.client, s)]),\n      );\n    } else {\n      this.stickers = new Collection(this.stickers);\n    }\n\n    // Discord sends null if the message has not been edited\n    if (data.edited_timestamp) {\n      /**\n       * The timestamp the message was last edited at (if applicable)\n       * @type {?number}\n       */\n      this.editedTimestamp = new Date(data.edited_timestamp).getTime();\n    } else {\n      this.editedTimestamp ??= null;\n    }\n\n    if ('reactions' in data) {\n      /**\n       * A manager of the reactions belonging to this message\n       * @type {ReactionManager}\n       */\n      this.reactions = new ReactionManager(this);\n      if (data.reactions?.length > 0) {\n        for (const reaction of data.reactions) {\n          this.reactions._add(reaction);\n        }\n      }\n    } else {\n      this.reactions ??= new ReactionManager(this);\n    }\n\n    if (!this.mentions) {\n      /**\n       * All valid mentions that the message contains\n       * @type {MessageMentions}\n       */\n      this.mentions = new Mentions(\n        this,\n        data.mentions,\n        data.mention_roles,\n        data.mention_everyone,\n        data.mention_channels,\n        data.referenced_message?.author,\n      );\n    } else {\n      this.mentions = new Mentions(\n        this,\n        data.mentions ?? this.mentions.users,\n        data.mention_roles ?? this.mentions.roles,\n        data.mention_everyone ?? this.mentions.everyone,\n        data.mention_channels ?? this.mentions.crosspostedChannels,\n        data.referenced_message?.author ?? this.mentions.repliedUser,\n      );\n    }\n\n    if ('webhook_id' in data) {\n      /**\n       * The id of the webhook that sent the message, if applicable\n       * @type {?Snowflake}\n       */\n      this.webhookId = data.webhook_id;\n    } else {\n      this.webhookId ??= null;\n    }\n\n    if ('application' in data) {\n      /**\n       * Supplemental application information for group activities\n       * @type {?ClientApplication}\n       */\n      this.groupActivityApplication = new ClientApplication(this.client, data.application);\n    } else {\n      this.groupActivityApplication ??= null;\n    }\n\n    if ('application_id' in data) {\n      /**\n       * The id of the application of the interaction that sent this message, if any\n       * @type {?Snowflake}\n       */\n      this.applicationId = data.application_id;\n    } else {\n      this.applicationId ??= null;\n    }\n\n    if ('activity' in data) {\n      /**\n       * Group activity\n       * @type {?MessageActivity}\n       */\n      this.activity = {\n        partyId: data.activity.party_id,\n        type: data.activity.type,\n      };\n    } else {\n      this.activity ??= null;\n    }\n\n    if ('thread' in data) {\n      this.client.channels._add(data.thread, this.guild);\n    }\n\n    if (this.member && data.member) {\n      this.member._patch(data.member);\n    } else if (data.member && this.guild && this.author) {\n      this.guild.members._add(Object.assign(data.member, { user: this.author }));\n    }\n\n    if ('flags' in data) {\n      /**\n       * Flags that are applied to the message\n       * @type {Readonly<MessageFlags>}\n       */\n      this.flags = new MessageFlags(data.flags).freeze();\n    } else {\n      this.flags = new MessageFlags(this.flags).freeze();\n    }\n\n    /**\n     * Reference data sent in a message that contains ids identifying the referenced message.\n     * This can be present in the following types of message:\n     * * Crossposted messages (IS_CROSSPOST {@link MessageFlags.FLAGS message flag})\n     * * CHANNEL_FOLLOW_ADD\n     * * CHANNEL_PINNED_MESSAGE\n     * * REPLY\n     * * THREAD_STARTER_MESSAGE\n     * @see {@link https://discord.com/developers/docs/resources/channel#message-types}\n     * @typedef {Object} MessageReference\n     * @property {Snowflake} channelId The channel's id the message was referenced\n     * @property {?Snowflake} guildId The guild's id the message was referenced\n     * @property {?Snowflake} messageId The message's id that was referenced\n     */\n\n    if ('message_reference' in data) {\n      /**\n       * Message reference data\n       * @type {?MessageReference}\n       */\n      this.reference = {\n        channelId: data.message_reference.channel_id,\n        guildId: data.message_reference.guild_id,\n        messageId: data.message_reference.message_id,\n      };\n    } else {\n      this.reference ??= null;\n    }\n\n    if (data.referenced_message) {\n      this.channel?.messages._add({ guild_id: data.message_reference?.guild_id, ...data.referenced_message });\n    }\n\n    /**\n     * Partial data of the interaction that a message is a reply to\n     * @typedef {Object} MessageInteraction\n     * @property {Snowflake} id The interaction's id\n     * @property {InteractionType} type The type of the interaction\n     * @property {string} commandName The name of the interaction's application command\n     * @property {User} user The user that invoked the interaction\n     */\n\n    if (data.interaction) {\n      /**\n       * Partial data of the interaction that this message is a reply to\n       * @type {?MessageInteraction}\n       */\n      this.interaction = {\n        id: data.interaction.id,\n        type: InteractionTypes[data.interaction.type],\n        commandName: data.interaction.name,\n        user: this.client.users._add(data.interaction.user),\n      };\n    } else {\n      this.interaction ??= null;\n    }\n  }\n\n  /**\n   * Whether or not the structure has been deleted\n   * @type {boolean}\n   * @deprecated This will be removed in the next major version, see https://github.com/discordjs/discord.js/issues/7091\n   */\n  get deleted() {\n    if (!deprecationEmittedForDeleted) {\n      deprecationEmittedForDeleted = true;\n      process.emitWarning(\n        'Message#deleted is deprecated, see https://github.com/discordjs/discord.js/issues/7091.',\n        'DeprecationWarning',\n      );\n    }\n\n    return deletedMessages.has(this);\n  }\n\n  set deleted(value) {\n    if (!deprecationEmittedForDeleted) {\n      deprecationEmittedForDeleted = true;\n      process.emitWarning(\n        'Message#deleted is deprecated, see https://github.com/discordjs/discord.js/issues/7091.',\n        'DeprecationWarning',\n      );\n    }\n\n    if (value) deletedMessages.add(this);\n    else deletedMessages.delete(this);\n  }\n\n  /**\n   * The channel that the message was sent in\n   * @type {TextChannel|DMChannel|NewsChannel|ThreadChannel}\n   * @readonly\n   */\n  get channel() {\n    return this.client.channels.resolve(this.channelId);\n  }\n\n  /**\n   * Whether or not this message is a partial\n   * @type {boolean}\n   * @readonly\n   */\n  get partial() {\n    return typeof this.content !== 'string' || !this.author;\n  }\n\n  /**\n   * Represents the author of the message as a guild member.\n   * Only available if the message comes from a guild where the author is still a member\n   * @type {?GuildMember}\n   * @readonly\n   */\n  get member() {\n    return this.guild?.members.resolve(this.author) ?? null;\n  }\n\n  /**\n   * The time the message was sent at\n   * @type {Date}\n   * @readonly\n   */\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The time the message was last edited at (if applicable)\n   * @type {?Date}\n   * @readonly\n   */\n  get editedAt() {\n    return this.editedTimestamp ? new Date(this.editedTimestamp) : null;\n  }\n\n  /**\n   * The guild the message was sent in (if in a guild channel)\n   * @type {?Guild}\n   * @readonly\n   */\n  get guild() {\n    return this.client.guilds.resolve(this.guildId) ?? this.channel?.guild ?? null;\n  }\n\n  /**\n   * Whether this message has a thread associated with it\n   * @type {boolean}\n   * @readonly\n   */\n  get hasThread() {\n    return this.flags.has(MessageFlags.FLAGS.HAS_THREAD);\n  }\n\n  /**\n   * The thread started by this message\n   * <info>This property is not suitable for checking whether a message has a thread,\n   * use {@link Message#hasThread} instead.</info>\n   * @type {?ThreadChannel}\n   * @readonly\n   */\n  get thread() {\n    return this.channel?.threads?.resolve(this.id) ?? null;\n  }\n\n  /**\n   * The URL to jump to this message\n   * @type {string}\n   * @readonly\n   */\n  get url() {\n    return `https://discord.com/channels/${this.guildId ?? '@me'}/${this.channelId}/${this.id}`;\n  }\n\n  /**\n   * The message contents with all mentions replaced by the equivalent text.\n   * If mentions cannot be resolved to a name, the relevant mention in the message content will not be converted.\n   * @type {?string}\n   * @readonly\n   */\n  get cleanContent() {\n    // eslint-disable-next-line eqeqeq\n    return this.content != null ? Util.cleanContent(this.content, this.channel) : null;\n  }\n\n  /**\n   * Creates a reaction collector.\n   * @param {ReactionCollectorOptions} [options={}] Options to send to the collector\n   * @returns {ReactionCollector}\n   * @example\n   * // Create a reaction collector\n   * const filter = (reaction, user) => reaction.emoji.name === 'ðŸ‘Œ' && user.id === 'someId';\n   * const collector = message.createReactionCollector({ filter, time: 15_000 });\n   * collector.on('collect', r => console.log(`Collected ${r.emoji.name}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n  createReactionCollector(options = {}) {\n    return new ReactionCollector(this, options);\n  }\n\n  /**\n   * An object containing the same properties as CollectorOptions, but a few more:\n   * @typedef {ReactionCollectorOptions} AwaitReactionsOptions\n   * @property {string[]} [errors] Stop/end reasons that cause the promise to reject\n   */\n\n  /**\n   * Similar to createReactionCollector but in promise form.\n   * Resolves with a collection of reactions that pass the specified filter.\n   * @param {AwaitReactionsOptions} [options={}] Optional options to pass to the internal collector\n   * @returns {Promise<Collection<string | Snowflake, MessageReaction>>}\n   * @example\n   * // Create a reaction collector\n   * const filter = (reaction, user) => reaction.emoji.name === 'ðŸ‘Œ' && user.id === 'someId'\n   * message.awaitReactions({ filter, time: 15_000 })\n   *   .then(collected => console.log(`Collected ${collected.size} reactions`))\n   *   .catch(console.error);\n   */\n  awaitReactions(options = {}) {\n    return new Promise((resolve, reject) => {\n      const collector = this.createReactionCollector(options);\n      collector.once('end', (reactions, reason) => {\n        if (options.errors?.includes(reason)) reject(reactions);\n        else resolve(reactions);\n      });\n    });\n  }\n\n  /**\n   * @typedef {CollectorOptions} MessageComponentCollectorOptions\n   * @property {MessageComponentType} [componentType] The type of component to listen for\n   * @property {number} [max] The maximum total amount of interactions to collect\n   * @property {number} [maxComponents] The maximum number of components to collect\n   * @property {number} [maxUsers] The maximum number of users to interact\n   */\n\n  /**\n   * Creates a message component interaction collector.\n   * @param {MessageComponentCollectorOptions} [options={}] Options to send to the collector\n   * @returns {InteractionCollector}\n   * @example\n   * // Create a message component interaction collector\n   * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';\n   * const collector = message.createMessageComponentCollector({ filter, time: 15_000 });\n   * collector.on('collect', i => console.log(`Collected ${i.customId}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n  createMessageComponentCollector(options = {}) {\n    return new InteractionCollector(this.client, {\n      ...options,\n      interactionType: InteractionTypes.MESSAGE_COMPONENT,\n      message: this,\n    });\n  }\n\n  /**\n   * An object containing the same properties as CollectorOptions, but a few more:\n   * @typedef {Object} AwaitMessageComponentOptions\n   * @property {CollectorFilter} [filter] The filter applied to this collector\n   * @property {number} [time] Time to wait for an interaction before rejecting\n   * @property {MessageComponentType} [componentType] The type of component interaction to collect\n   */\n\n  /**\n   * Collects a single component interaction that passes the filter.\n   * The Promise will reject if the time expires.\n   * @param {AwaitMessageComponentOptions} [options={}] Options to pass to the internal collector\n   * @returns {Promise<MessageComponentInteraction>}\n   * @example\n   * // Collect a message component interaction\n   * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';\n   * message.awaitMessageComponent({ filter, time: 15_000 })\n   *   .then(interaction => console.log(`${interaction.customId} was clicked!`))\n   *   .catch(console.error);\n   */\n  awaitMessageComponent(options = {}) {\n    const _options = { ...options, max: 1 };\n    return new Promise((resolve, reject) => {\n      const collector = this.createMessageComponentCollector(_options);\n      collector.once('end', (interactions, reason) => {\n        const interaction = interactions.first();\n        if (interaction) resolve(interaction);\n        else reject(new Error('INTERACTION_COLLECTOR_ERROR', reason));\n      });\n    });\n  }\n\n  /**\n   * Whether the message is editable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get editable() {\n    const precheck = Boolean(\n      this.author.id === this.client.user.id && !deletedMessages.has(this) && (!this.guild || this.channel?.viewable),\n    );\n    // Regardless of permissions thread messages cannot be edited if\n    // the thread is locked.\n    if (this.channel?.isThread()) {\n      return precheck && !this.channel.locked;\n    }\n    return precheck;\n  }\n\n  /**\n   * Whether the message is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get deletable() {\n    if (deletedMessages.has(this)) {\n      return false;\n    }\n    if (!this.guild) {\n      return this.author.id === this.client.user.id;\n    }\n    // DMChannel does not have viewable property, so check viewable after proved that message is on a guild.\n    if (!this.channel?.viewable) {\n      return false;\n    }\n\n    const permissions = this.channel?.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    // This flag allows deleting even if timed out\n    if (permissions.has(Permissions.FLAGS.ADMINISTRATOR, false)) return true;\n\n    return Boolean(\n      this.author.id === this.client.user.id ||\n        (permissions.has(Permissions.FLAGS.MANAGE_MESSAGES, false) &&\n          this.guild.me.communicationDisabledUntilTimestamp < Date.now()),\n    );\n  }\n\n  /**\n   * Whether the message is pinnable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get pinnable() {\n    const { channel } = this;\n    return Boolean(\n      !this.system &&\n        !deletedMessages.has(this) &&\n        (!this.guild ||\n          (channel?.viewable &&\n            channel?.permissionsFor(this.client.user)?.has(Permissions.FLAGS.MANAGE_MESSAGES, false))),\n    );\n  }\n\n  /**\n   * Fetches the Message this crosspost/reply/pin-add references, if available to the client\n   * @returns {Promise<Message>}\n   */\n  async fetchReference() {\n    if (!this.reference) throw new Error('MESSAGE_REFERENCE_MISSING');\n    const { channelId, messageId } = this.reference;\n    const channel = this.client.channels.resolve(channelId);\n    if (!channel) throw new Error('GUILD_CHANNEL_RESOLVE');\n    const message = await channel.messages.fetch(messageId);\n    return message;\n  }\n\n  /**\n   * Whether the message is crosspostable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get crosspostable() {\n    const bitfield =\n      Permissions.FLAGS.SEND_MESSAGES |\n      (this.author.id === this.client.user.id ? Permissions.defaultBit : Permissions.FLAGS.MANAGE_MESSAGES);\n    const { channel } = this;\n    return Boolean(\n      channel?.type === 'GUILD_NEWS' &&\n        !this.flags.has(MessageFlags.FLAGS.CROSSPOSTED) &&\n        this.type === 'DEFAULT' &&\n        channel.viewable &&\n        channel.permissionsFor(this.client.user)?.has(bitfield, false) &&\n        !deletedMessages.has(this),\n    );\n  }\n\n  /**\n   * Options that can be passed into {@link Message#edit}.\n   * @typedef {Object} MessageEditOptions\n   * @property {?string} [content] Content to be edited\n   * @property {MessageEmbed[]|APIEmbed[]} [embeds] Embeds to be added/edited\n   * @property {MessageMentionOptions} [allowedMentions] Which mentions should be parsed from the message content\n   * @property {MessageFlags} [flags] Which flags to set for the message. Only `SUPPRESS_EMBEDS` can be edited.\n   * @property {MessageAttachment[]} [attachments] An array of attachments to keep,\n   * all attachments will be kept if omitted\n   * @property {FileOptions[]|BufferResolvable[]|MessageAttachment[]} [files] Files to add to the message\n   * @property {MessageActionRow[]|MessageActionRowOptions[]} [components]\n   * Action rows containing interactive components for the message (buttons, select menus)\n   */\n\n  /**\n   * Edits the content of the message.\n   * @param {string|MessagePayload|MessageEditOptions} options The options to provide\n   * @returns {Promise<Message>}\n   * @example\n   * // Update the content of a message\n   * message.edit('This is my new content!')\n   *   .then(msg => console.log(`Updated the content of a message to ${msg.content}`))\n   *   .catch(console.error);\n   */\n  edit(options) {\n    if (!this.channel) return Promise.reject(new Error('CHANNEL_NOT_CACHED'));\n    return this.channel.messages.edit(this, options);\n  }\n\n  /**\n   * Publishes a message in an announcement channel to all channels following it.\n   * @returns {Promise<Message>}\n   * @example\n   * // Crosspost a message\n   * if (message.channel.type === 'GUILD_NEWS') {\n   *   message.crosspost()\n   *     .then(() => console.log('Crossposted message'))\n   *     .catch(console.error);\n   * }\n   */\n  crosspost() {\n    if (!this.channel) return Promise.reject(new Error('CHANNEL_NOT_CACHED'));\n    return this.channel.messages.crosspost(this.id);\n  }\n\n  /**\n   * Pins this message to the channel's pinned messages.\n   * @returns {Promise<Message>}\n   * @example\n   * // Pin a message\n   * message.pin()\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n  async pin() {\n    if (!this.channel) throw new Error('CHANNEL_NOT_CACHED');\n    await this.channel.messages.pin(this.id);\n    return this;\n  }\n\n  /**\n   * Unpins this message from the channel's pinned messages.\n   * @returns {Promise<Message>}\n   * @example\n   * // Unpin a message\n   * message.unpin()\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n  async unpin() {\n    if (!this.channel) throw new Error('CHANNEL_NOT_CACHED');\n    await this.channel.messages.unpin(this.id);\n    return this;\n  }\n\n  /**\n   * Adds a reaction to the message.\n   * @param {EmojiIdentifierResolvable} emoji The emoji to react with\n   * @returns {Promise<MessageReaction>}\n   * @example\n   * // React to a message with a unicode emoji\n   * message.react('ðŸ¤”')\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // React to a message with a custom emoji\n   * message.react(message.guild.emojis.cache.get('123456789012345678'))\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async react(emoji) {\n    if (!this.channel) throw new Error('CHANNEL_NOT_CACHED');\n    await this.channel.messages.react(this.id, emoji);\n\n    return this.client.actions.MessageReactionAdd.handle(\n      {\n        user: this.client.user,\n        channel: this.channel,\n        message: this,\n        emoji: Util.resolvePartialEmoji(emoji),\n      },\n      true,\n    ).reaction;\n  }\n\n  /**\n   * Deletes the message.\n   * @returns {Promise<Message>}\n   * @example\n   * // Delete a message\n   * message.delete()\n   *   .then(msg => console.log(`Deleted message from ${msg.author.username}`))\n   *   .catch(console.error);\n   */\n  async delete() {\n    if (!this.channel) throw new Error('CHANNEL_NOT_CACHED');\n    await this.channel.messages.delete(this.id);\n    return this;\n  }\n\n  /**\n   * Options provided when sending a message as an inline reply.\n   * @typedef {BaseMessageOptions} ReplyMessageOptions\n   * @property {boolean} [failIfNotExists=true] Whether to error if the referenced message\n   * does not exist (creates a standard message in this case when false)\n   * @property {StickerResolvable[]} [stickers=[]] Stickers to send in the message\n   */\n\n  /**\n   * Send an inline reply to this message.\n   * @param {string|MessagePayload|ReplyMessageOptions} options The options to provide\n   * @returns {Promise<Message>}\n   * @example\n   * // Reply to a message\n   * message.reply('This is a reply!')\n   *   .then(() => console.log(`Replied to message \"${message.content}\"`))\n   *   .catch(console.error);\n   */\n  reply(options) {\n    if (!this.channel) return Promise.reject(new Error('CHANNEL_NOT_CACHED'));\n    let data;\n\n    if (options instanceof MessagePayload) {\n      data = options;\n    } else {\n      data = MessagePayload.create(this, options, {\n        reply: {\n          messageReference: this,\n          failIfNotExists: options?.failIfNotExists ?? this.client.options.failIfNotExists,\n        },\n      });\n    }\n    return this.channel.send(data);\n  }\n\n  /**\n   * A number that is allowed to be the duration (in minutes) of inactivity after which a thread is automatically\n   * archived. This can be:\n   * * `60` (1 hour)\n   * * `1440` (1 day)\n   * * `4320` (3 days) <warn>This is only available when the guild has the `THREE_DAY_THREAD_ARCHIVE` feature.</warn>\n   * * `10080` (7 days) <warn>This is only available when the guild has the `SEVEN_DAY_THREAD_ARCHIVE` feature.</warn>\n   * * `'MAX'` Based on the guild's features\n   * @typedef {number|string} ThreadAutoArchiveDuration\n   */\n\n  /**\n   * Options for starting a thread on a message.\n   * @typedef {Object} StartThreadOptions\n   * @property {string} name The name of the new thread\n   * @property {ThreadAutoArchiveDuration} [autoArchiveDuration=this.channel.defaultAutoArchiveDuration] The amount of\n   * time (in minutes) after which the thread should automatically archive in case of no recent activity\n   * @property {string} [reason] Reason for creating the thread\n   * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the thread in seconds\n   */\n\n  /**\n   * Create a new public thread from this message\n   * @see ThreadManager#create\n   * @param {StartThreadOptions} [options] Options for starting a thread on this message\n   * @returns {Promise<ThreadChannel>}\n   */\n  startThread(options = {}) {\n    if (!this.channel) return Promise.reject(new Error('CHANNEL_NOT_CACHED'));\n    if (!['GUILD_TEXT', 'GUILD_NEWS'].includes(this.channel.type)) {\n      return Promise.reject(new Error('MESSAGE_THREAD_PARENT'));\n    }\n    if (this.hasThread) return Promise.reject(new Error('MESSAGE_EXISTING_THREAD'));\n    return this.channel.threads.create({ ...options, startMessage: this });\n  }\n\n  /**\n   * Fetch this message.\n   * @param {boolean} [force=true] Whether to skip the cache check and request the API\n   * @returns {Promise<Message>}\n   */\n  fetch(force = true) {\n    if (!this.channel) return Promise.reject(new Error('CHANNEL_NOT_CACHED'));\n    return this.channel.messages.fetch(this.id, { force });\n  }\n\n  /**\n   * Fetches the webhook used to create this message.\n   * @returns {Promise<?Webhook>}\n   */\n  fetchWebhook() {\n    if (!this.webhookId) return Promise.reject(new Error('WEBHOOK_MESSAGE'));\n    if (this.webhookId === this.applicationId) return Promise.reject(new Error('WEBHOOK_APPLICATION'));\n    return this.client.fetchWebhook(this.webhookId);\n  }\n\n  /**\n   * Suppresses or unsuppresses embeds on a message.\n   * @param {boolean} [suppress=true] If the embeds should be suppressed or not\n   * @returns {Promise<Message>}\n   */\n  suppressEmbeds(suppress = true) {\n    const flags = new MessageFlags(this.flags.bitfield);\n\n    if (suppress) {\n      flags.add(MessageFlags.FLAGS.SUPPRESS_EMBEDS);\n    } else {\n      flags.remove(MessageFlags.FLAGS.SUPPRESS_EMBEDS);\n    }\n\n    return this.edit({ flags });\n  }\n\n  /**\n   * Removes the attachments from this message.\n   * @returns {Promise<Message>}\n   */\n  removeAttachments() {\n    return this.edit({ attachments: [] });\n  }\n\n  /**\n   * Resolves a component by a custom id.\n   * @param {string} customId The custom id to resolve against\n   * @returns {?MessageActionRowComponent}\n   */\n  resolveComponent(customId) {\n    return this.components.flatMap(row => row.components).find(component => component.customId === customId) ?? null;\n  }\n\n  /**\n   * Used mainly internally. Whether two messages are identical in properties. If you want to compare messages\n   * without checking all the properties, use `message.id === message2.id`, which is much more efficient. This\n   * method allows you to see if there are differences in content, embeds, attachments, nonce and tts properties.\n   * @param {Message} message The message to compare it to\n   * @param {APIMessage} rawData Raw data passed through the WebSocket about this message\n   * @returns {boolean}\n   */\n  equals(message, rawData) {\n    if (!message) return false;\n    const embedUpdate = !message.author && !message.attachments;\n    if (embedUpdate) return this.id === message.id && this.embeds.length === message.embeds.length;\n\n    let equal =\n      this.id === message.id &&\n      this.author.id === message.author.id &&\n      this.content === message.content &&\n      this.tts === message.tts &&\n      this.nonce === message.nonce &&\n      this.embeds.length === message.embeds.length &&\n      this.attachments.length === message.attachments.length;\n\n    if (equal && rawData) {\n      equal =\n        this.mentions.everyone === message.mentions.everyone &&\n        this.createdTimestamp === new Date(rawData.timestamp).getTime() &&\n        this.editedTimestamp === new Date(rawData.edited_timestamp).getTime();\n    }\n\n    return equal;\n  }\n\n  /**\n   * Whether this message is from a guild.\n   * @returns {boolean}\n   */\n  inGuild() {\n    return Boolean(this.guildId);\n  }\n\n  /**\n   * When concatenated with a string, this automatically concatenates the message's content instead of the object.\n   * @returns {string}\n   * @example\n   * // Logs: Message: This is a message!\n   * console.log(`Message: ${message}`);\n   */\n  toString() {\n    return this.content;\n  }\n\n  toJSON() {\n    return super.toJSON({\n      channel: 'channelId',\n      author: 'authorId',\n      groupActivityApplication: 'groupActivityApplicationId',\n      guild: 'guildId',\n      cleanContent: true,\n      member: false,\n      reactions: false,\n    });\n  }\n}\n\nexports.Message = Message;\nexports.deletedMessages = deletedMessages;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}