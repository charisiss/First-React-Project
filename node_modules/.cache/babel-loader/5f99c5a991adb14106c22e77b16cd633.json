{"ast":null,"code":"'use strict';\n\nconst process = require('node:process');\n\nconst {\n  setTimeout\n} = require('node:timers');\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst CachedManager = require('./CachedManager');\n\nconst {\n  Guild\n} = require('../structures/Guild');\n\nconst GuildChannel = require('../structures/GuildChannel');\n\nconst GuildEmoji = require('../structures/GuildEmoji');\n\nconst {\n  GuildMember\n} = require('../structures/GuildMember');\n\nconst Invite = require('../structures/Invite');\n\nconst OAuth2Guild = require('../structures/OAuth2Guild');\n\nconst {\n  Role\n} = require('../structures/Role');\n\nconst {\n  ChannelTypes,\n  Events,\n  OverwriteTypes,\n  VerificationLevels,\n  DefaultMessageNotificationLevels,\n  ExplicitContentFilterLevels\n} = require('../util/Constants');\n\nconst DataResolver = require('../util/DataResolver');\n\nconst Permissions = require('../util/Permissions');\n\nconst SystemChannelFlags = require('../util/SystemChannelFlags');\n\nconst {\n  resolveColor\n} = require('../util/Util');\n\nlet cacheWarningEmitted = false;\n/**\n * Manages API methods for Guilds and stores their cache.\n * @extends {CachedManager}\n */\n\nclass GuildManager extends CachedManager {\n  constructor(client, iterable) {\n    super(client, Guild, iterable);\n\n    if (!cacheWarningEmitted && this._cache.constructor.name !== 'Collection') {\n      cacheWarningEmitted = true;\n      process.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, 'UnsupportedCacheOverwriteWarning');\n    }\n  }\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, Guild>}\n   * @name GuildManager#cache\n   */\n\n  /**\n   * Data that resolves to give a Guild object. This can be:\n   * * A Guild object\n   * * A GuildChannel object\n   * * A GuildEmoji object\n   * * A Role object\n   * * A Snowflake\n   * * An Invite object\n   * @typedef {Guild|GuildChannel|GuildMember|GuildEmoji|Role|Snowflake|Invite} GuildResolvable\n   */\n\n  /**\n   * Partial data for a Role.\n   * @typedef {Object} PartialRoleData\n   * @property {Snowflake|number} [id] The role's id, used to set channel overrides,\n   * this is a placeholder and will be replaced by the API after consumption\n   * @property {string} [name] The name of the role\n   * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number\n   * @property {boolean} [hoist] Whether or not the role should be hoisted\n   * @property {number} [position] The position of the role\n   * @property {PermissionResolvable} [permissions] The permissions of the role\n   * @property {boolean} [mentionable] Whether or not the role should be mentionable\n   */\n\n  /**\n   * Partial overwrite data.\n   * @typedef {Object} PartialOverwriteData\n   * @property {Snowflake|number} id The id of the {@link Role} or {@link User} this overwrite belongs to\n   * @property {OverwriteType} [type] The type of this overwrite\n   * @property {PermissionResolvable} [allow] The permissions to allow\n   * @property {PermissionResolvable} [deny] The permissions to deny\n   */\n\n  /**\n   * Partial data for a Channel.\n   * @typedef {Object} PartialChannelData\n   * @property {Snowflake|number} [id] The channel's id, used to set its parent,\n   * this is a placeholder and will be replaced by the API after consumption\n   * @property {Snowflake|number} [parentId] The parent id for this channel\n   * @property {ChannelType|number} [type] The type of the channel\n   * @property {string} name The name of the channel\n   * @property {string} [topic] The topic of the text channel\n   * @property {boolean} [nsfw] Whether the channel is NSFW\n   * @property {number} [bitrate] The bitrate of the voice channel\n   * @property {number} [userLimit] The user limit of the channel\n   * @property {?string} [rtcRegion] The RTC region of the channel\n   * @property {PartialOverwriteData[]} [permissionOverwrites]\n   * Overwrites of the channel\n   * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) of the channel in seconds\n   */\n\n  /**\n   * Resolves a GuildResolvable to a Guild object.\n   * @method resolve\n   * @memberof GuildManager\n   * @instance\n   * @param {GuildResolvable} guild The guild resolvable to identify\n   * @returns {?Guild}\n   */\n\n\n  resolve(guild) {\n    if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite && guild.guild) {\n      return super.resolve(guild.guild);\n    }\n\n    return super.resolve(guild);\n  }\n  /**\n   * Resolves a {@link GuildResolvable} to a {@link Guild} id string.\n   * @method resolveId\n   * @memberof GuildManager\n   * @instance\n   * @param {GuildResolvable} guild The guild resolvable to identify\n   * @returns {?Snowflake}\n   */\n\n\n  resolveId(guild) {\n    if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite && guild.guild) {\n      return super.resolveId(guild.guild.id);\n    }\n\n    return super.resolveId(guild);\n  }\n  /**\n   * Options used to create a guild.\n   * @typedef {Object} GuildCreateOptions\n   * @property {Snowflake|number} [afkChannelId] The AFK channel's id\n   * @property {number} [afkTimeout] The AFK timeout in seconds\n   * @property {PartialChannelData[]} [channels=[]] The channels for this guild\n   * @property {DefaultMessageNotificationLevel|number} [defaultMessageNotifications] The default message notifications\n   * for the guild\n   * @property {ExplicitContentFilterLevel} [explicitContentFilter] The explicit content filter level for the guild\n   * @property {?(BufferResolvable|Base64Resolvable)} [icon=null] The icon for the guild\n   * @property {PartialRoleData[]} [roles=[]] The roles for this guild,\n   * the first element of this array is used to change properties of the guild's everyone role.\n   * @property {Snowflake|number} [systemChannelId] The system channel's id\n   * @property {SystemChannelFlagsResolvable} [systemChannelFlags] The flags of the system channel\n   * @property {VerificationLevel} [verificationLevel] The verification level for the guild\n   */\n\n  /**\n   * Creates a guild.\n   * <warn>This is only available to bots in fewer than 10 guilds.</warn>\n   * @param {string} name The name of the guild\n   * @param {GuildCreateOptions} [options] Options for creating the guild\n   * @returns {Promise<Guild>} The guild that was created\n   */\n\n\n  async create(name) {\n    let {\n      afkChannelId,\n      afkTimeout,\n      channels = [],\n      defaultMessageNotifications,\n      explicitContentFilter,\n      icon = null,\n      roles = [],\n      systemChannelId,\n      systemChannelFlags,\n      verificationLevel\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    icon = await DataResolver.resolveImage(icon);\n\n    if (typeof verificationLevel === 'string') {\n      verificationLevel = VerificationLevels[verificationLevel];\n    }\n\n    if (typeof defaultMessageNotifications === 'string') {\n      defaultMessageNotifications = DefaultMessageNotificationLevels[defaultMessageNotifications];\n    }\n\n    if (typeof explicitContentFilter === 'string') {\n      explicitContentFilter = ExplicitContentFilterLevels[explicitContentFilter];\n    }\n\n    for (const channel of channels) {\n      channel.type &&= typeof channel.type === 'number' ? channel.type : ChannelTypes[channel.type];\n      channel.parent_id = channel.parentId;\n      delete channel.parentId;\n      channel.user_limit = channel.userLimit;\n      delete channel.userLimit;\n      channel.rate_limit_per_user = channel.rateLimitPerUser;\n      delete channel.rateLimitPerUser;\n      channel.rtc_region = channel.rtcRegion;\n      delete channel.rtcRegion;\n      if (!channel.permissionOverwrites) continue;\n\n      for (const overwrite of channel.permissionOverwrites) {\n        if (typeof overwrite.type === 'string') {\n          overwrite.type = OverwriteTypes[overwrite.type];\n        }\n\n        overwrite.allow &&= Permissions.resolve(overwrite.allow).toString();\n        overwrite.deny &&= Permissions.resolve(overwrite.deny).toString();\n      }\n\n      channel.permission_overwrites = channel.permissionOverwrites;\n      delete channel.permissionOverwrites;\n    }\n\n    for (const role of roles) {\n      role.color &&= resolveColor(role.color);\n      role.permissions &&= Permissions.resolve(role.permissions).toString();\n    }\n\n    systemChannelFlags &&= SystemChannelFlags.resolve(systemChannelFlags);\n    const data = await this.client.api.guilds.post({\n      data: {\n        name,\n        icon,\n        verification_level: verificationLevel,\n        default_message_notifications: defaultMessageNotifications,\n        explicit_content_filter: explicitContentFilter,\n        roles,\n        channels,\n        afk_channel_id: afkChannelId,\n        afk_timeout: afkTimeout,\n        system_channel_id: systemChannelId,\n        system_channel_flags: systemChannelFlags\n      }\n    });\n    if (this.client.guilds.cache.has(data.id)) return this.client.guilds.cache.get(data.id);\n    return new Promise(resolve => {\n      const handleGuild = guild => {\n        if (guild.id === data.id) {\n          clearTimeout(timeout);\n          this.client.removeListener(Events.GUILD_CREATE, handleGuild);\n          this.client.decrementMaxListeners();\n          resolve(guild);\n        }\n      };\n\n      this.client.incrementMaxListeners();\n      this.client.on(Events.GUILD_CREATE, handleGuild);\n      const timeout = setTimeout(() => {\n        this.client.removeListener(Events.GUILD_CREATE, handleGuild);\n        this.client.decrementMaxListeners();\n        resolve(this.client.guilds._add(data));\n      }, 10_000).unref();\n    });\n  }\n  /**\n   * Options used to fetch a single guild.\n   * @typedef {BaseFetchOptions} FetchGuildOptions\n   * @property {GuildResolvable} guild The guild to fetch\n   * @property {boolean} [withCounts=true] Whether the approximate member and presence counts should be returned\n   */\n\n  /**\n   * Options used to fetch multiple guilds.\n   * @typedef {Object} FetchGuildsOptions\n   * @property {Snowflake} [before] Get guilds before this guild id\n   * @property {Snowflake} [after] Get guilds after this guild id\n   * @property {number} [limit=200] Maximum number of guilds to request (1-200)\n   */\n\n  /**\n   * Obtains one or multiple guilds from Discord, or the guild cache if it's already available.\n   * @param {GuildResolvable|FetchGuildOptions|FetchGuildsOptions} [options] The guild's id or options\n   * @returns {Promise<Guild|Collection<Snowflake, OAuth2Guild>>}\n   */\n\n\n  async fetch() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const id = this.resolveId(options) ?? this.resolveId(options.guild);\n\n    if (id) {\n      if (!options.force) {\n        const existing = this.cache.get(id);\n        if (existing) return existing;\n      }\n\n      const data = await this.client.api.guilds(id).get({\n        query: {\n          with_counts: options.withCounts ?? true\n        }\n      });\n      return this._add(data, options.cache);\n    }\n\n    const data = await this.client.api.users('@me').guilds.get({\n      query: options\n    });\n    return data.reduce((coll, guild) => coll.set(guild.id, new OAuth2Guild(this.client, guild)), new Collection());\n  }\n\n}\n\nmodule.exports = GuildManager;","map":{"version":3,"names":["process","require","setTimeout","Collection","CachedManager","Guild","GuildChannel","GuildEmoji","GuildMember","Invite","OAuth2Guild","Role","ChannelTypes","Events","OverwriteTypes","VerificationLevels","DefaultMessageNotificationLevels","ExplicitContentFilterLevels","DataResolver","Permissions","SystemChannelFlags","resolveColor","cacheWarningEmitted","GuildManager","constructor","client","iterable","_cache","name","emitWarning","resolve","guild","resolveId","id","create","afkChannelId","afkTimeout","channels","defaultMessageNotifications","explicitContentFilter","icon","roles","systemChannelId","systemChannelFlags","verificationLevel","resolveImage","channel","type","parent_id","parentId","user_limit","userLimit","rate_limit_per_user","rateLimitPerUser","rtc_region","rtcRegion","permissionOverwrites","overwrite","allow","toString","deny","permission_overwrites","role","color","permissions","data","api","guilds","post","verification_level","default_message_notifications","explicit_content_filter","afk_channel_id","afk_timeout","system_channel_id","system_channel_flags","cache","has","get","Promise","handleGuild","clearTimeout","timeout","removeListener","GUILD_CREATE","decrementMaxListeners","incrementMaxListeners","on","_add","unref","fetch","options","force","existing","query","with_counts","withCounts","users","reduce","coll","set","module","exports"],"sources":["C:/Users/xsxsam/node_modules/discord.js/src/managers/GuildManager.js"],"sourcesContent":["'use strict';\n\nconst process = require('node:process');\nconst { setTimeout } = require('node:timers');\nconst { Collection } = require('@discordjs/collection');\nconst CachedManager = require('./CachedManager');\nconst { Guild } = require('../structures/Guild');\nconst GuildChannel = require('../structures/GuildChannel');\nconst GuildEmoji = require('../structures/GuildEmoji');\nconst { GuildMember } = require('../structures/GuildMember');\nconst Invite = require('../structures/Invite');\nconst OAuth2Guild = require('../structures/OAuth2Guild');\nconst { Role } = require('../structures/Role');\nconst {\n  ChannelTypes,\n  Events,\n  OverwriteTypes,\n  VerificationLevels,\n  DefaultMessageNotificationLevels,\n  ExplicitContentFilterLevels,\n} = require('../util/Constants');\nconst DataResolver = require('../util/DataResolver');\nconst Permissions = require('../util/Permissions');\nconst SystemChannelFlags = require('../util/SystemChannelFlags');\nconst { resolveColor } = require('../util/Util');\n\nlet cacheWarningEmitted = false;\n\n/**\n * Manages API methods for Guilds and stores their cache.\n * @extends {CachedManager}\n */\nclass GuildManager extends CachedManager {\n  constructor(client, iterable) {\n    super(client, Guild, iterable);\n    if (!cacheWarningEmitted && this._cache.constructor.name !== 'Collection') {\n      cacheWarningEmitted = true;\n      process.emitWarning(\n        `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,\n        'UnsupportedCacheOverwriteWarning',\n      );\n    }\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, Guild>}\n   * @name GuildManager#cache\n   */\n\n  /**\n   * Data that resolves to give a Guild object. This can be:\n   * * A Guild object\n   * * A GuildChannel object\n   * * A GuildEmoji object\n   * * A Role object\n   * * A Snowflake\n   * * An Invite object\n   * @typedef {Guild|GuildChannel|GuildMember|GuildEmoji|Role|Snowflake|Invite} GuildResolvable\n   */\n\n  /**\n   * Partial data for a Role.\n   * @typedef {Object} PartialRoleData\n   * @property {Snowflake|number} [id] The role's id, used to set channel overrides,\n   * this is a placeholder and will be replaced by the API after consumption\n   * @property {string} [name] The name of the role\n   * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number\n   * @property {boolean} [hoist] Whether or not the role should be hoisted\n   * @property {number} [position] The position of the role\n   * @property {PermissionResolvable} [permissions] The permissions of the role\n   * @property {boolean} [mentionable] Whether or not the role should be mentionable\n   */\n\n  /**\n   * Partial overwrite data.\n   * @typedef {Object} PartialOverwriteData\n   * @property {Snowflake|number} id The id of the {@link Role} or {@link User} this overwrite belongs to\n   * @property {OverwriteType} [type] The type of this overwrite\n   * @property {PermissionResolvable} [allow] The permissions to allow\n   * @property {PermissionResolvable} [deny] The permissions to deny\n   */\n\n  /**\n   * Partial data for a Channel.\n   * @typedef {Object} PartialChannelData\n   * @property {Snowflake|number} [id] The channel's id, used to set its parent,\n   * this is a placeholder and will be replaced by the API after consumption\n   * @property {Snowflake|number} [parentId] The parent id for this channel\n   * @property {ChannelType|number} [type] The type of the channel\n   * @property {string} name The name of the channel\n   * @property {string} [topic] The topic of the text channel\n   * @property {boolean} [nsfw] Whether the channel is NSFW\n   * @property {number} [bitrate] The bitrate of the voice channel\n   * @property {number} [userLimit] The user limit of the channel\n   * @property {?string} [rtcRegion] The RTC region of the channel\n   * @property {PartialOverwriteData[]} [permissionOverwrites]\n   * Overwrites of the channel\n   * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) of the channel in seconds\n   */\n\n  /**\n   * Resolves a GuildResolvable to a Guild object.\n   * @method resolve\n   * @memberof GuildManager\n   * @instance\n   * @param {GuildResolvable} guild The guild resolvable to identify\n   * @returns {?Guild}\n   */\n  resolve(guild) {\n    if (\n      guild instanceof GuildChannel ||\n      guild instanceof GuildMember ||\n      guild instanceof GuildEmoji ||\n      guild instanceof Role ||\n      (guild instanceof Invite && guild.guild)\n    ) {\n      return super.resolve(guild.guild);\n    }\n    return super.resolve(guild);\n  }\n\n  /**\n   * Resolves a {@link GuildResolvable} to a {@link Guild} id string.\n   * @method resolveId\n   * @memberof GuildManager\n   * @instance\n   * @param {GuildResolvable} guild The guild resolvable to identify\n   * @returns {?Snowflake}\n   */\n  resolveId(guild) {\n    if (\n      guild instanceof GuildChannel ||\n      guild instanceof GuildMember ||\n      guild instanceof GuildEmoji ||\n      guild instanceof Role ||\n      (guild instanceof Invite && guild.guild)\n    ) {\n      return super.resolveId(guild.guild.id);\n    }\n    return super.resolveId(guild);\n  }\n\n  /**\n   * Options used to create a guild.\n   * @typedef {Object} GuildCreateOptions\n   * @property {Snowflake|number} [afkChannelId] The AFK channel's id\n   * @property {number} [afkTimeout] The AFK timeout in seconds\n   * @property {PartialChannelData[]} [channels=[]] The channels for this guild\n   * @property {DefaultMessageNotificationLevel|number} [defaultMessageNotifications] The default message notifications\n   * for the guild\n   * @property {ExplicitContentFilterLevel} [explicitContentFilter] The explicit content filter level for the guild\n   * @property {?(BufferResolvable|Base64Resolvable)} [icon=null] The icon for the guild\n   * @property {PartialRoleData[]} [roles=[]] The roles for this guild,\n   * the first element of this array is used to change properties of the guild's everyone role.\n   * @property {Snowflake|number} [systemChannelId] The system channel's id\n   * @property {SystemChannelFlagsResolvable} [systemChannelFlags] The flags of the system channel\n   * @property {VerificationLevel} [verificationLevel] The verification level for the guild\n   */\n\n  /**\n   * Creates a guild.\n   * <warn>This is only available to bots in fewer than 10 guilds.</warn>\n   * @param {string} name The name of the guild\n   * @param {GuildCreateOptions} [options] Options for creating the guild\n   * @returns {Promise<Guild>} The guild that was created\n   */\n  async create(\n    name,\n    {\n      afkChannelId,\n      afkTimeout,\n      channels = [],\n      defaultMessageNotifications,\n      explicitContentFilter,\n      icon = null,\n      roles = [],\n      systemChannelId,\n      systemChannelFlags,\n      verificationLevel,\n    } = {},\n  ) {\n    icon = await DataResolver.resolveImage(icon);\n    if (typeof verificationLevel === 'string') {\n      verificationLevel = VerificationLevels[verificationLevel];\n    }\n    if (typeof defaultMessageNotifications === 'string') {\n      defaultMessageNotifications = DefaultMessageNotificationLevels[defaultMessageNotifications];\n    }\n    if (typeof explicitContentFilter === 'string') {\n      explicitContentFilter = ExplicitContentFilterLevels[explicitContentFilter];\n    }\n    for (const channel of channels) {\n      channel.type &&= typeof channel.type === 'number' ? channel.type : ChannelTypes[channel.type];\n      channel.parent_id = channel.parentId;\n      delete channel.parentId;\n      channel.user_limit = channel.userLimit;\n      delete channel.userLimit;\n      channel.rate_limit_per_user = channel.rateLimitPerUser;\n      delete channel.rateLimitPerUser;\n      channel.rtc_region = channel.rtcRegion;\n      delete channel.rtcRegion;\n\n      if (!channel.permissionOverwrites) continue;\n      for (const overwrite of channel.permissionOverwrites) {\n        if (typeof overwrite.type === 'string') {\n          overwrite.type = OverwriteTypes[overwrite.type];\n        }\n        overwrite.allow &&= Permissions.resolve(overwrite.allow).toString();\n        overwrite.deny &&= Permissions.resolve(overwrite.deny).toString();\n      }\n      channel.permission_overwrites = channel.permissionOverwrites;\n      delete channel.permissionOverwrites;\n    }\n    for (const role of roles) {\n      role.color &&= resolveColor(role.color);\n      role.permissions &&= Permissions.resolve(role.permissions).toString();\n    }\n    systemChannelFlags &&= SystemChannelFlags.resolve(systemChannelFlags);\n\n    const data = await this.client.api.guilds.post({\n      data: {\n        name,\n        icon,\n        verification_level: verificationLevel,\n        default_message_notifications: defaultMessageNotifications,\n        explicit_content_filter: explicitContentFilter,\n        roles,\n        channels,\n        afk_channel_id: afkChannelId,\n        afk_timeout: afkTimeout,\n        system_channel_id: systemChannelId,\n        system_channel_flags: systemChannelFlags,\n      },\n    });\n\n    if (this.client.guilds.cache.has(data.id)) return this.client.guilds.cache.get(data.id);\n\n    return new Promise(resolve => {\n      const handleGuild = guild => {\n        if (guild.id === data.id) {\n          clearTimeout(timeout);\n          this.client.removeListener(Events.GUILD_CREATE, handleGuild);\n          this.client.decrementMaxListeners();\n          resolve(guild);\n        }\n      };\n      this.client.incrementMaxListeners();\n      this.client.on(Events.GUILD_CREATE, handleGuild);\n\n      const timeout = setTimeout(() => {\n        this.client.removeListener(Events.GUILD_CREATE, handleGuild);\n        this.client.decrementMaxListeners();\n        resolve(this.client.guilds._add(data));\n      }, 10_000).unref();\n    });\n  }\n\n  /**\n   * Options used to fetch a single guild.\n   * @typedef {BaseFetchOptions} FetchGuildOptions\n   * @property {GuildResolvable} guild The guild to fetch\n   * @property {boolean} [withCounts=true] Whether the approximate member and presence counts should be returned\n   */\n\n  /**\n   * Options used to fetch multiple guilds.\n   * @typedef {Object} FetchGuildsOptions\n   * @property {Snowflake} [before] Get guilds before this guild id\n   * @property {Snowflake} [after] Get guilds after this guild id\n   * @property {number} [limit=200] Maximum number of guilds to request (1-200)\n   */\n\n  /**\n   * Obtains one or multiple guilds from Discord, or the guild cache if it's already available.\n   * @param {GuildResolvable|FetchGuildOptions|FetchGuildsOptions} [options] The guild's id or options\n   * @returns {Promise<Guild|Collection<Snowflake, OAuth2Guild>>}\n   */\n  async fetch(options = {}) {\n    const id = this.resolveId(options) ?? this.resolveId(options.guild);\n\n    if (id) {\n      if (!options.force) {\n        const existing = this.cache.get(id);\n        if (existing) return existing;\n      }\n\n      const data = await this.client.api.guilds(id).get({ query: { with_counts: options.withCounts ?? true } });\n      return this._add(data, options.cache);\n    }\n\n    const data = await this.client.api.users('@me').guilds.get({ query: options });\n    return data.reduce((coll, guild) => coll.set(guild.id, new OAuth2Guild(this.client, guild)), new Collection());\n  }\n}\n\nmodule.exports = GuildManager;\n"],"mappings":"AAAA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,cAAD,CAAvB;;AACA,MAAM;EAAEC;AAAF,IAAiBD,OAAO,CAAC,aAAD,CAA9B;;AACA,MAAM;EAAEE;AAAF,IAAiBF,OAAO,CAAC,uBAAD,CAA9B;;AACA,MAAMG,aAAa,GAAGH,OAAO,CAAC,iBAAD,CAA7B;;AACA,MAAM;EAAEI;AAAF,IAAYJ,OAAO,CAAC,qBAAD,CAAzB;;AACA,MAAMK,YAAY,GAAGL,OAAO,CAAC,4BAAD,CAA5B;;AACA,MAAMM,UAAU,GAAGN,OAAO,CAAC,0BAAD,CAA1B;;AACA,MAAM;EAAEO;AAAF,IAAkBP,OAAO,CAAC,2BAAD,CAA/B;;AACA,MAAMQ,MAAM,GAAGR,OAAO,CAAC,sBAAD,CAAtB;;AACA,MAAMS,WAAW,GAAGT,OAAO,CAAC,2BAAD,CAA3B;;AACA,MAAM;EAAEU;AAAF,IAAWV,OAAO,CAAC,oBAAD,CAAxB;;AACA,MAAM;EACJW,YADI;EAEJC,MAFI;EAGJC,cAHI;EAIJC,kBAJI;EAKJC,gCALI;EAMJC;AANI,IAOFhB,OAAO,CAAC,mBAAD,CAPX;;AAQA,MAAMiB,YAAY,GAAGjB,OAAO,CAAC,sBAAD,CAA5B;;AACA,MAAMkB,WAAW,GAAGlB,OAAO,CAAC,qBAAD,CAA3B;;AACA,MAAMmB,kBAAkB,GAAGnB,OAAO,CAAC,4BAAD,CAAlC;;AACA,MAAM;EAAEoB;AAAF,IAAmBpB,OAAO,CAAC,cAAD,CAAhC;;AAEA,IAAIqB,mBAAmB,GAAG,KAA1B;AAEA;AACA;AACA;AACA;;AACA,MAAMC,YAAN,SAA2BnB,aAA3B,CAAyC;EACvCoB,WAAW,CAACC,MAAD,EAASC,QAAT,EAAmB;IAC5B,MAAMD,MAAN,EAAcpB,KAAd,EAAqBqB,QAArB;;IACA,IAAI,CAACJ,mBAAD,IAAwB,KAAKK,MAAL,CAAYH,WAAZ,CAAwBI,IAAxB,KAAiC,YAA7D,EAA2E;MACzEN,mBAAmB,GAAG,IAAtB;MACAtB,OAAO,CAAC6B,WAAR,CACG,qCAAoC,KAAKL,WAAL,CAAiBI,IAAK,2CAD7D,EAEE,kCAFF;IAID;EACF;EAED;AACF;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEE,OAAO,CAACC,KAAD,EAAQ;IACb,IACEA,KAAK,YAAYzB,YAAjB,IACAyB,KAAK,YAAYvB,WADjB,IAEAuB,KAAK,YAAYxB,UAFjB,IAGAwB,KAAK,YAAYpB,IAHjB,IAICoB,KAAK,YAAYtB,MAAjB,IAA2BsB,KAAK,CAACA,KALpC,EAME;MACA,OAAO,MAAMD,OAAN,CAAcC,KAAK,CAACA,KAApB,CAAP;IACD;;IACD,OAAO,MAAMD,OAAN,CAAcC,KAAd,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEC,SAAS,CAACD,KAAD,EAAQ;IACf,IACEA,KAAK,YAAYzB,YAAjB,IACAyB,KAAK,YAAYvB,WADjB,IAEAuB,KAAK,YAAYxB,UAFjB,IAGAwB,KAAK,YAAYpB,IAHjB,IAICoB,KAAK,YAAYtB,MAAjB,IAA2BsB,KAAK,CAACA,KALpC,EAME;MACA,OAAO,MAAMC,SAAN,CAAgBD,KAAK,CAACA,KAAN,CAAYE,EAA5B,CAAP;IACD;;IACD,OAAO,MAAMD,SAAN,CAAgBD,KAAhB,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;;;EACc,MAANG,MAAM,CACVN,IADU,EAcV;IAAA,IAZA;MACEO,YADF;MAEEC,UAFF;MAGEC,QAAQ,GAAG,EAHb;MAIEC,2BAJF;MAKEC,qBALF;MAMEC,IAAI,GAAG,IANT;MAOEC,KAAK,GAAG,EAPV;MAQEC,eA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"},"metadata":{},"sourceType":"script"}