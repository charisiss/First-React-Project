{"ast":null,"code":"'use strict';\n\nconst process = require('node:process');\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst CachedManager = require('./CachedManager');\n\nconst {\n  TypeError\n} = require('../errors');\n\nconst PermissionOverwrites = require('../structures/PermissionOverwrites');\n\nconst {\n  Role\n} = require('../structures/Role');\n\nconst {\n  OverwriteTypes\n} = require('../util/Constants');\n\nlet cacheWarningEmitted = false;\n/**\n * Manages API methods for guild channel permission overwrites and stores their cache.\n * @extends {CachedManager}\n */\n\nclass PermissionOverwriteManager extends CachedManager {\n  constructor(channel, iterable) {\n    super(channel.client, PermissionOverwrites);\n\n    if (!cacheWarningEmitted && this._cache.constructor.name !== 'Collection') {\n      cacheWarningEmitted = true;\n      process.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, 'UnsupportedCacheOverwriteWarning');\n    }\n    /**\n     * The channel of the permission overwrite this manager belongs to\n     * @type {GuildChannel}\n     */\n\n\n    this.channel = channel;\n\n    if (iterable) {\n      for (const item of iterable) {\n        this._add(item);\n      }\n    }\n  }\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, PermissionOverwrites>}\n   * @name PermissionOverwriteManager#cache\n   */\n\n\n  _add(data, cache) {\n    return super._add(data, cache, {\n      extras: [this.channel]\n    });\n  }\n  /**\n   * Replaces the permission overwrites in this channel.\n   * @param {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} overwrites\n   * Permission overwrites the channel gets updated with\n   * @param {string} [reason] Reason for updating the channel overwrites\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * message.channel.permissionOverwrites.set([\n   *   {\n   *      id: message.author.id,\n   *      deny: [Permissions.FLAGS.VIEW_CHANNEL],\n   *   },\n   * ], 'Needed to change permissions');\n   */\n\n\n  set(overwrites, reason) {\n    if (!Array.isArray(overwrites) && !(overwrites instanceof Collection)) {\n      return Promise.reject(new TypeError('INVALID_TYPE', 'overwrites', 'Array or Collection of Permission Overwrites', true));\n    }\n\n    return this.channel.edit({\n      permissionOverwrites: overwrites,\n      reason\n    });\n  }\n  /**\n   * Extra information about the overwrite\n   * @typedef {Object} GuildChannelOverwriteOptions\n   * @property {string} [reason] Reason for creating/editing this overwrite\n   * @property {number} [type] The type of overwrite, either `0` for a role or `1` for a member. Use this to bypass\n   * automatic resolution of type that results in an error for uncached structure\n   */\n\n  /**\n   * Creates or edits permission overwrites for a user or role in this channel.\n   * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update\n   * @param {PermissionOverwriteOptions} options The options for the update\n   * @param {GuildChannelOverwriteOptions} [overwriteOptions] The extra information for the update\n   * @param {PermissionOverwrites} [existing] The existing overwrites to merge with this update\n   * @returns {Promise<GuildChannel>}\n   * @private\n   */\n\n\n  async upsert(userOrRole, options) {\n    let overwriteOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let existing = arguments.length > 3 ? arguments[3] : undefined;\n    let userOrRoleId = this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole);\n    let {\n      type,\n      reason\n    } = overwriteOptions;\n\n    if (typeof type !== 'number') {\n      userOrRole = this.channel.guild.roles.resolve(userOrRole) ?? this.client.users.resolve(userOrRole);\n      if (!userOrRole) throw new TypeError('INVALID_TYPE', 'parameter', 'User nor a Role');\n      type = userOrRole instanceof Role ? OverwriteTypes.role : OverwriteTypes.member;\n    }\n\n    const {\n      allow,\n      deny\n    } = PermissionOverwrites.resolveOverwriteOptions(options, existing);\n    await this.client.api.channels(this.channel.id).permissions(userOrRoleId).put({\n      data: {\n        id: userOrRoleId,\n        type,\n        allow,\n        deny\n      },\n      reason\n    });\n    return this.channel;\n  }\n  /**\n   * Creates permission overwrites for a user or role in this channel, or replaces them if already present.\n   * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update\n   * @param {PermissionOverwriteOptions} options The options for the update\n   * @param {GuildChannelOverwriteOptions} [overwriteOptions] The extra information for the update\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Create or Replace permission overwrites for a message author\n   * message.channel.permissionOverwrites.create(message.author, {\n   *   SEND_MESSAGES: false\n   * })\n   *   .then(channel => console.log(channel.permissionOverwrites.cache.get(message.author.id)))\n   *   .catch(console.error);\n   */\n\n\n  create(userOrRole, options, overwriteOptions) {\n    return this.upsert(userOrRole, options, overwriteOptions);\n  }\n  /**\n   * Edits permission overwrites for a user or role in this channel, or creates an entry if not already present.\n   * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update\n   * @param {PermissionOverwriteOptions} options The options for the update\n   * @param {GuildChannelOverwriteOptions} [overwriteOptions] The extra information for the update\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Edit or Create permission overwrites for a message author\n   * message.channel.permissionOverwrites.edit(message.author, {\n   *   SEND_MESSAGES: false\n   * })\n   *   .then(channel => console.log(channel.permissionOverwrites.cache.get(message.author.id)))\n   *   .catch(console.error);\n   */\n\n\n  edit(userOrRole, options, overwriteOptions) {\n    userOrRole = this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole);\n    const existing = this.cache.get(userOrRole);\n    return this.upsert(userOrRole, options, overwriteOptions, existing);\n  }\n  /**\n   * Deletes permission overwrites for a user or role in this channel.\n   * @param {UserResolvable|RoleResolvable} userOrRole The user or role to delete\n   * @param {string} [reason] The reason for deleting the overwrite\n   * @returns {Promise<GuildChannel>}\n   */\n\n\n  async delete(userOrRole, reason) {\n    const userOrRoleId = this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole);\n    if (!userOrRoleId) throw new TypeError('INVALID_TYPE', 'parameter', 'User nor a Role');\n    await this.client.api.channels(this.channel.id).permissions(userOrRoleId).delete({\n      reason\n    });\n    return this.channel;\n  }\n\n}\n\nmodule.exports = PermissionOverwriteManager;","map":{"version":3,"names":["process","require","Collection","CachedManager","TypeError","PermissionOverwrites","Role","OverwriteTypes","cacheWarningEmitted","PermissionOverwriteManager","constructor","channel","iterable","client","_cache","name","emitWarning","item","_add","data","cache","extras","set","overwrites","reason","Array","isArray","Promise","reject","edit","permissionOverwrites","upsert","userOrRole","options","overwriteOptions","existing","userOrRoleId","guild","roles","resolveId","users","type","resolve","role","member","allow","deny","resolveOverwriteOptions","api","channels","id","permissions","put","create","get","delete","module","exports"],"sources":["C:/Users/xsxsam/node_modules/discord.js/src/managers/PermissionOverwriteManager.js"],"sourcesContent":["'use strict';\n\nconst process = require('node:process');\nconst { Collection } = require('@discordjs/collection');\nconst CachedManager = require('./CachedManager');\nconst { TypeError } = require('../errors');\nconst PermissionOverwrites = require('../structures/PermissionOverwrites');\nconst { Role } = require('../structures/Role');\nconst { OverwriteTypes } = require('../util/Constants');\n\nlet cacheWarningEmitted = false;\n\n/**\n * Manages API methods for guild channel permission overwrites and stores their cache.\n * @extends {CachedManager}\n */\nclass PermissionOverwriteManager extends CachedManager {\n  constructor(channel, iterable) {\n    super(channel.client, PermissionOverwrites);\n    if (!cacheWarningEmitted && this._cache.constructor.name !== 'Collection') {\n      cacheWarningEmitted = true;\n      process.emitWarning(\n        `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,\n        'UnsupportedCacheOverwriteWarning',\n      );\n    }\n\n    /**\n     * The channel of the permission overwrite this manager belongs to\n     * @type {GuildChannel}\n     */\n    this.channel = channel;\n\n    if (iterable) {\n      for (const item of iterable) {\n        this._add(item);\n      }\n    }\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, PermissionOverwrites>}\n   * @name PermissionOverwriteManager#cache\n   */\n\n  _add(data, cache) {\n    return super._add(data, cache, { extras: [this.channel] });\n  }\n\n  /**\n   * Replaces the permission overwrites in this channel.\n   * @param {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} overwrites\n   * Permission overwrites the channel gets updated with\n   * @param {string} [reason] Reason for updating the channel overwrites\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * message.channel.permissionOverwrites.set([\n   *   {\n   *      id: message.author.id,\n   *      deny: [Permissions.FLAGS.VIEW_CHANNEL],\n   *   },\n   * ], 'Needed to change permissions');\n   */\n  set(overwrites, reason) {\n    if (!Array.isArray(overwrites) && !(overwrites instanceof Collection)) {\n      return Promise.reject(\n        new TypeError('INVALID_TYPE', 'overwrites', 'Array or Collection of Permission Overwrites', true),\n      );\n    }\n    return this.channel.edit({ permissionOverwrites: overwrites, reason });\n  }\n\n  /**\n   * Extra information about the overwrite\n   * @typedef {Object} GuildChannelOverwriteOptions\n   * @property {string} [reason] Reason for creating/editing this overwrite\n   * @property {number} [type] The type of overwrite, either `0` for a role or `1` for a member. Use this to bypass\n   * automatic resolution of type that results in an error for uncached structure\n   */\n\n  /**\n   * Creates or edits permission overwrites for a user or role in this channel.\n   * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update\n   * @param {PermissionOverwriteOptions} options The options for the update\n   * @param {GuildChannelOverwriteOptions} [overwriteOptions] The extra information for the update\n   * @param {PermissionOverwrites} [existing] The existing overwrites to merge with this update\n   * @returns {Promise<GuildChannel>}\n   * @private\n   */\n  async upsert(userOrRole, options, overwriteOptions = {}, existing) {\n    let userOrRoleId = this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole);\n    let { type, reason } = overwriteOptions;\n    if (typeof type !== 'number') {\n      userOrRole = this.channel.guild.roles.resolve(userOrRole) ?? this.client.users.resolve(userOrRole);\n      if (!userOrRole) throw new TypeError('INVALID_TYPE', 'parameter', 'User nor a Role');\n      type = userOrRole instanceof Role ? OverwriteTypes.role : OverwriteTypes.member;\n    }\n\n    const { allow, deny } = PermissionOverwrites.resolveOverwriteOptions(options, existing);\n\n    await this.client.api\n      .channels(this.channel.id)\n      .permissions(userOrRoleId)\n      .put({\n        data: { id: userOrRoleId, type, allow, deny },\n        reason,\n      });\n    return this.channel;\n  }\n\n  /**\n   * Creates permission overwrites for a user or role in this channel, or replaces them if already present.\n   * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update\n   * @param {PermissionOverwriteOptions} options The options for the update\n   * @param {GuildChannelOverwriteOptions} [overwriteOptions] The extra information for the update\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Create or Replace permission overwrites for a message author\n   * message.channel.permissionOverwrites.create(message.author, {\n   *   SEND_MESSAGES: false\n   * })\n   *   .then(channel => console.log(channel.permissionOverwrites.cache.get(message.author.id)))\n   *   .catch(console.error);\n   */\n  create(userOrRole, options, overwriteOptions) {\n    return this.upsert(userOrRole, options, overwriteOptions);\n  }\n\n  /**\n   * Edits permission overwrites for a user or role in this channel, or creates an entry if not already present.\n   * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update\n   * @param {PermissionOverwriteOptions} options The options for the update\n   * @param {GuildChannelOverwriteOptions} [overwriteOptions] The extra information for the update\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Edit or Create permission overwrites for a message author\n   * message.channel.permissionOverwrites.edit(message.author, {\n   *   SEND_MESSAGES: false\n   * })\n   *   .then(channel => console.log(channel.permissionOverwrites.cache.get(message.author.id)))\n   *   .catch(console.error);\n   */\n  edit(userOrRole, options, overwriteOptions) {\n    userOrRole = this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole);\n    const existing = this.cache.get(userOrRole);\n    return this.upsert(userOrRole, options, overwriteOptions, existing);\n  }\n\n  /**\n   * Deletes permission overwrites for a user or role in this channel.\n   * @param {UserResolvable|RoleResolvable} userOrRole The user or role to delete\n   * @param {string} [reason] The reason for deleting the overwrite\n   * @returns {Promise<GuildChannel>}\n   */\n  async delete(userOrRole, reason) {\n    const userOrRoleId = this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole);\n    if (!userOrRoleId) throw new TypeError('INVALID_TYPE', 'parameter', 'User nor a Role');\n\n    await this.client.api.channels(this.channel.id).permissions(userOrRoleId).delete({ reason });\n    return this.channel;\n  }\n}\n\nmodule.exports = PermissionOverwriteManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}