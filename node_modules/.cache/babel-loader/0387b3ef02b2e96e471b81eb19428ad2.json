{"ast":null,"code":"'use strict';\n\nconst Base = require('./Base');\n\nconst ApplicationCommandPermissionsManager = require('../managers/ApplicationCommandPermissionsManager');\n\nconst {\n  ApplicationCommandOptionTypes,\n  ApplicationCommandTypes,\n  ChannelTypes\n} = require('../util/Constants');\n\nconst SnowflakeUtil = require('../util/SnowflakeUtil');\n/**\n * Represents an application command.\n * @extends {Base}\n */\n\n\nclass ApplicationCommand extends Base {\n  constructor(client, data, guild, guildId) {\n    super(client);\n    /**\n     * The command's id\n     * @type {Snowflake}\n     */\n\n    this.id = data.id;\n    /**\n     * The parent application's id\n     * @type {Snowflake}\n     */\n\n    this.applicationId = data.application_id;\n    /**\n     * The guild this command is part of\n     * @type {?Guild}\n     */\n\n    this.guild = guild ?? null;\n    /**\n     * The guild's id this command is part of, this may be non-null when `guild` is `null` if the command\n     * was fetched from the `ApplicationCommandManager`\n     * @type {?Snowflake}\n     */\n\n    this.guildId = guild?.id ?? guildId ?? null;\n    /**\n     * The manager for permissions of this command on its guild or arbitrary guilds when the command is global\n     * @type {ApplicationCommandPermissionsManager}\n     */\n\n    this.permissions = new ApplicationCommandPermissionsManager(this);\n    /**\n     * The type of this application command\n     * @type {ApplicationCommandType}\n     */\n\n    this.type = ApplicationCommandTypes[data.type];\n\n    this._patch(data);\n  }\n\n  _patch(data) {\n    if ('name' in data) {\n      /**\n       * The name of this command\n       * @type {string}\n       */\n      this.name = data.name;\n    }\n\n    if ('description' in data) {\n      /**\n       * The description of this command\n       * @type {string}\n       */\n      this.description = data.description;\n    }\n\n    if ('options' in data) {\n      /**\n       * The options of this command\n       * @type {ApplicationCommandOption[]}\n       */\n      this.options = data.options.map(o => this.constructor.transformOption(o, true));\n    } else {\n      this.options ??= [];\n    }\n\n    if ('default_permission' in data) {\n      /**\n       * Whether the command is enabled by default when the app is added to a guild\n       * @type {boolean}\n       */\n      this.defaultPermission = data.default_permission;\n    }\n\n    if ('version' in data) {\n      /**\n       * Autoincrementing version identifier updated during substantial record changes\n       * @type {Snowflake}\n       */\n      this.version = data.version;\n    }\n  }\n  /**\n   * The timestamp the command was created at\n   * @type {number}\n   * @readonly\n   */\n\n\n  get createdTimestamp() {\n    return SnowflakeUtil.timestampFrom(this.id);\n  }\n  /**\n   * The time the command was created at\n   * @type {Date}\n   * @readonly\n   */\n\n\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n  /**\n   * The manager that this command belongs to\n   * @type {ApplicationCommandManager}\n   * @readonly\n   */\n\n\n  get manager() {\n    return (this.guild ?? this.client.application).commands;\n  }\n  /**\n   * Data for creating or editing an application command.\n   * @typedef {Object} ApplicationCommandData\n   * @property {string} name The name of the command\n   * @property {string} description The description of the command\n   * @property {ApplicationCommandType} [type] The type of the command\n   * @property {ApplicationCommandOptionData[]} [options] Options for the command\n   * @property {boolean} [defaultPermission] Whether the command is enabled by default when the app is added to a guild\n   */\n\n  /**\n   * An option for an application command or subcommand.\n   * <info>In addition to the listed properties, when used as a parameter,\n   * API style `snake_case` properties can be used for compatibility with generators like `@discordjs/builders`.</info>\n   * <warn>Note that providing a value for the `camelCase` counterpart for any `snake_case` property\n   * will discard the provided `snake_case` property.</warn>\n   * @typedef {Object} ApplicationCommandOptionData\n   * @property {ApplicationCommandOptionType|number} type The type of the option\n   * @property {string} name The name of the option\n   * @property {string} description The description of the option\n   * @property {boolean} [autocomplete] Whether the option is an autocomplete option\n   * @property {boolean} [required] Whether the option is required\n   * @property {ApplicationCommandOptionChoice[]} [choices] The choices of the option for the user to pick from\n   * @property {ApplicationCommandOptionData[]} [options] Additional options if this option is a subcommand (group)\n   * @property {ChannelType[]|number[]} [channelTypes] When the option type is channel,\n   * the allowed types of channels that can be selected\n   * @property {number} [minValue] The minimum value for an `INTEGER` or `NUMBER` option\n   * @property {number} [maxValue] The maximum value for an `INTEGER` or `NUMBER` option\n   */\n\n  /**\n   * Edits this application command.\n   * @param {ApplicationCommandData} data The data to update the command with\n   * @returns {Promise<ApplicationCommand>}\n   * @example\n   * // Edit the description of this command\n   * command.edit({\n   *   description: 'New description',\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  edit(data) {\n    return this.manager.edit(this, data, this.guildId);\n  }\n  /**\n   * Edits the name of this ApplicationCommand\n   * @param {string} name The new name of the command\n   * @returns {Promise<ApplicationCommand>}\n   */\n\n\n  setName(name) {\n    return this.edit({\n      name\n    });\n  }\n  /**\n   * Edits the description of this ApplicationCommand\n   * @param {string} description The new description of the command\n   * @returns {Promise<ApplicationCommand>}\n   */\n\n\n  setDescription(description) {\n    return this.edit({\n      description\n    });\n  }\n  /**\n   * Edits the default permission of this ApplicationCommand\n   * @param {boolean} [defaultPermission=true] The default permission for this command\n   * @returns {Promise<ApplicationCommand>}\n   */\n\n\n  setDefaultPermission() {\n    let defaultPermission = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return this.edit({\n      defaultPermission\n    });\n  }\n  /**\n   * Edits the options of this ApplicationCommand\n   * @param {ApplicationCommandOptionData[]} options The options to set for this command\n   * @returns {Promise<ApplicationCommand>}\n   */\n\n\n  setOptions(options) {\n    return this.edit({\n      options\n    });\n  }\n  /**\n   * Deletes this command.\n   * @returns {Promise<ApplicationCommand>}\n   * @example\n   * // Delete this command\n   * command.delete()\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  delete() {\n    return this.manager.delete(this, this.guildId);\n  }\n  /**\n   * Whether this command equals another command. It compares all properties, so for most operations\n   * it is advisable to just compare `command.id === command2.id` as it is much faster and is often\n   * what most users need.\n   * @param {ApplicationCommand|ApplicationCommandData|APIApplicationCommand} command The command to compare with\n   * @param {boolean} [enforceOptionOrder=false] Whether to strictly check that options and choices are in the same\n   * order in the array <info>The client may not always respect this ordering!</info>\n   * @returns {boolean}\n   */\n\n\n  equals(command) {\n    let enforceOptionOrder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    // If given an id, check if the id matches\n    if (command.id && this.id !== command.id) return false; // Check top level parameters\n\n    const commandType = typeof command.type === 'string' ? command.type : ApplicationCommandTypes[command.type];\n\n    if (command.name !== this.name || 'description' in command && command.description !== this.description || 'version' in command && command.version !== this.version || 'autocomplete' in command && command.autocomplete !== this.autocomplete || commandType && commandType !== this.type || // Future proof for options being nullable\n    // TODO: remove ?? 0 on each when nullable\n    (command.options?.length ?? 0) !== (this.options?.length ?? 0) || (command.defaultPermission ?? command.default_permission ?? true) !== this.defaultPermission) {\n      return false;\n    }\n\n    if (command.options) {\n      return this.constructor.optionsEqual(this.options, command.options, enforceOptionOrder);\n    }\n\n    return true;\n  }\n  /**\n   * Recursively checks that all options for an {@link ApplicationCommand} are equal to the provided options.\n   * In most cases it is better to compare using {@link ApplicationCommand#equals}\n   * @param {ApplicationCommandOptionData[]} existing The options on the existing command,\n   * should be {@link ApplicationCommand#options}\n   * @param {ApplicationCommandOptionData[]|APIApplicationCommandOption[]} options The options to compare against\n   * @param {boolean} [enforceOptionOrder=false] Whether to strictly check that options and choices are in the same\n   * order in the array <info>The client may not always respect this ordering!</info>\n   * @returns {boolean}\n   */\n\n\n  static optionsEqual(existing, options) {\n    let enforceOptionOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (existing.length !== options.length) return false;\n\n    if (enforceOptionOrder) {\n      return existing.every((option, index) => this._optionEquals(option, options[index], enforceOptionOrder));\n    }\n\n    const newOptions = new Map(options.map(option => [option.name, option]));\n\n    for (const option of existing) {\n      const foundOption = newOptions.get(option.name);\n      if (!foundOption || !this._optionEquals(option, foundOption)) return false;\n    }\n\n    return true;\n  }\n  /**\n   * Checks that an option for an {@link ApplicationCommand} is equal to the provided option\n   * In most cases it is better to compare using {@link ApplicationCommand#equals}\n   * @param {ApplicationCommandOptionData} existing The option on the existing command,\n   * should be from {@link ApplicationCommand#options}\n   * @param {ApplicationCommandOptionData|APIApplicationCommandOption} option The option to compare against\n   * @param {boolean} [enforceOptionOrder=false] Whether to strictly check that options or choices are in the same\n   * order in their array <info>The client may not always respect this ordering!</info>\n   * @returns {boolean}\n   * @private\n   */\n\n\n  static _optionEquals(existing, option) {\n    let enforceOptionOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const optionType = typeof option.type === 'string' ? option.type : ApplicationCommandOptionTypes[option.type];\n\n    if (option.name !== existing.name || optionType !== existing.type || option.description !== existing.description || option.autocomplete !== existing.autocomplete || (option.required ?? (['SUB_COMMAND', 'SUB_COMMAND_GROUP'].includes(optionType) ? undefined : false)) !== existing.required || option.choices?.length !== existing.choices?.length || option.options?.length !== existing.options?.length || (option.channelTypes ?? option.channel_types)?.length !== existing.channelTypes?.length || (option.minValue ?? option.min_value) !== existing.minValue || (option.maxValue ?? option.max_value) !== existing.maxValue) {\n      return false;\n    }\n\n    if (existing.choices) {\n      if (enforceOptionOrder && !existing.choices.every((choice, index) => choice.name === option.choices[index].name && choice.value === option.choices[index].value)) {\n        return false;\n      }\n\n      if (!enforceOptionOrder) {\n        const newChoices = new Map(option.choices.map(choice => [choice.name, choice]));\n\n        for (const choice of existing.choices) {\n          const foundChoice = newChoices.get(choice.name);\n          if (!foundChoice || foundChoice.value !== choice.value) return false;\n        }\n      }\n    }\n\n    if (existing.channelTypes) {\n      const newTypes = (option.channelTypes ?? option.channel_types).map(type => typeof type === 'number' ? ChannelTypes[type] : type);\n\n      for (const type of existing.channelTypes) {\n        if (!newTypes.includes(type)) return false;\n      }\n    }\n\n    if (existing.options) {\n      return this.optionsEqual(existing.options, option.options, enforceOptionOrder);\n    }\n\n    return true;\n  }\n  /**\n   * An option for an application command or subcommand.\n   * @typedef {Object} ApplicationCommandOption\n   * @property {ApplicationCommandOptionType} type The type of the option\n   * @property {string} name The name of the option\n   * @property {string} description The description of the option\n   * @property {boolean} [required] Whether the option is required\n   * @property {boolean} [autocomplete] Whether the option is an autocomplete option\n   * @property {ApplicationCommandOptionChoice[]} [choices] The choices of the option for the user to pick from\n   * @property {ApplicationCommandOption[]} [options] Additional options if this option is a subcommand (group)\n   * @property {ChannelType[]} [channelTypes] When the option type is channel,\n   * the allowed types of channels that can be selected\n   * @property {number} [minValue] The minimum value for an `INTEGER` or `NUMBER` option\n   * @property {number} [maxValue] The maximum value for an `INTEGER` or `NUMBER` option\n   */\n\n  /**\n   * A choice for an application command option.\n   * @typedef {Object} ApplicationCommandOptionChoice\n   * @property {string} name The name of the choice\n   * @property {string|number} value The value of the choice\n   */\n\n  /**\n   * Transforms an {@link ApplicationCommandOptionData} object into something that can be used with the API.\n   * @param {ApplicationCommandOptionData} option The option to transform\n   * @param {boolean} [received] Whether this option has been received from Discord\n   * @returns {APIApplicationCommandOption}\n   * @private\n   */\n\n\n  static transformOption(option, received) {\n    const stringType = typeof option.type === 'string' ? option.type : ApplicationCommandOptionTypes[option.type];\n    const channelTypesKey = received ? 'channelTypes' : 'channel_types';\n    const minValueKey = received ? 'minValue' : 'min_value';\n    const maxValueKey = received ? 'maxValue' : 'max_value';\n    return {\n      type: typeof option.type === 'number' && !received ? option.type : ApplicationCommandOptionTypes[option.type],\n      name: option.name,\n      description: option.description,\n      required: option.required ?? (stringType === 'SUB_COMMAND' || stringType === 'SUB_COMMAND_GROUP' ? undefined : false),\n      autocomplete: option.autocomplete,\n      choices: option.choices,\n      options: option.options?.map(o => this.transformOption(o, received)),\n      [channelTypesKey]: received ? option.channel_types?.map(type => ChannelTypes[type]) : option.channelTypes?.map(type => typeof type === 'string' ? ChannelTypes[type] : type) ?? // When transforming to API data, accept API data\n      option.channel_types,\n      [minValueKey]: option.minValue ?? option.min_value,\n      [maxValueKey]: option.maxValue ?? option.max_value\n    };\n  }\n\n}\n\nmodule.exports = ApplicationCommand;\n/* eslint-disable max-len */\n\n/**\n * @external APIApplicationCommand\n * @see {@link https://discord.com/developers/docs/interactions/application-commands#application-command-object-application-command-structure}\n */\n\n/**\n * @external APIApplicationCommandOption\n * @see {@link https://discord.com/developers/docs/interactions/application-commands#application-command-object-application-command-option-structure}\n */","map":{"version":3,"names":["Base","require","ApplicationCommandPermissionsManager","ApplicationCommandOptionTypes","ApplicationCommandTypes","ChannelTypes","SnowflakeUtil","ApplicationCommand","constructor","client","data","guild","guildId","id","applicationId","application_id","permissions","type","_patch","name","description","options","map","o","transformOption","defaultPermission","default_permission","version","createdTimestamp","timestampFrom","createdAt","Date","manager","application","commands","edit","setName","setDescription","setDefaultPermission","setOptions","delete","equals","command","enforceOptionOrder","commandType","autocomplete","length","optionsEqual","existing","every","option","index","_optionEquals","newOptions","Map","foundOption","get","optionType","required","includes","undefined","choices","channelTypes","channel_types","minValue","min_value","maxValue","max_value","choice","value","newChoices","foundChoice","newTypes","received","stringType","channelTypesKey","minValueKey","maxValueKey","module","exports"],"sources":["C:/Users/xsxsam/node_modules/discord.js/src/structures/ApplicationCommand.js"],"sourcesContent":["'use strict';\n\nconst Base = require('./Base');\nconst ApplicationCommandPermissionsManager = require('../managers/ApplicationCommandPermissionsManager');\nconst { ApplicationCommandOptionTypes, ApplicationCommandTypes, ChannelTypes } = require('../util/Constants');\nconst SnowflakeUtil = require('../util/SnowflakeUtil');\n\n/**\n * Represents an application command.\n * @extends {Base}\n */\nclass ApplicationCommand extends Base {\n  constructor(client, data, guild, guildId) {\n    super(client);\n\n    /**\n     * The command's id\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n\n    /**\n     * The parent application's id\n     * @type {Snowflake}\n     */\n    this.applicationId = data.application_id;\n\n    /**\n     * The guild this command is part of\n     * @type {?Guild}\n     */\n    this.guild = guild ?? null;\n\n    /**\n     * The guild's id this command is part of, this may be non-null when `guild` is `null` if the command\n     * was fetched from the `ApplicationCommandManager`\n     * @type {?Snowflake}\n     */\n    this.guildId = guild?.id ?? guildId ?? null;\n\n    /**\n     * The manager for permissions of this command on its guild or arbitrary guilds when the command is global\n     * @type {ApplicationCommandPermissionsManager}\n     */\n    this.permissions = new ApplicationCommandPermissionsManager(this);\n\n    /**\n     * The type of this application command\n     * @type {ApplicationCommandType}\n     */\n    this.type = ApplicationCommandTypes[data.type];\n\n    this._patch(data);\n  }\n\n  _patch(data) {\n    if ('name' in data) {\n      /**\n       * The name of this command\n       * @type {string}\n       */\n      this.name = data.name;\n    }\n\n    if ('description' in data) {\n      /**\n       * The description of this command\n       * @type {string}\n       */\n      this.description = data.description;\n    }\n\n    if ('options' in data) {\n      /**\n       * The options of this command\n       * @type {ApplicationCommandOption[]}\n       */\n      this.options = data.options.map(o => this.constructor.transformOption(o, true));\n    } else {\n      this.options ??= [];\n    }\n\n    if ('default_permission' in data) {\n      /**\n       * Whether the command is enabled by default when the app is added to a guild\n       * @type {boolean}\n       */\n      this.defaultPermission = data.default_permission;\n    }\n\n    if ('version' in data) {\n      /**\n       * Autoincrementing version identifier updated during substantial record changes\n       * @type {Snowflake}\n       */\n      this.version = data.version;\n    }\n  }\n\n  /**\n   * The timestamp the command was created at\n   * @type {number}\n   * @readonly\n   */\n  get createdTimestamp() {\n    return SnowflakeUtil.timestampFrom(this.id);\n  }\n\n  /**\n   * The time the command was created at\n   * @type {Date}\n   * @readonly\n   */\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The manager that this command belongs to\n   * @type {ApplicationCommandManager}\n   * @readonly\n   */\n  get manager() {\n    return (this.guild ?? this.client.application).commands;\n  }\n\n  /**\n   * Data for creating or editing an application command.\n   * @typedef {Object} ApplicationCommandData\n   * @property {string} name The name of the command\n   * @property {string} description The description of the command\n   * @property {ApplicationCommandType} [type] The type of the command\n   * @property {ApplicationCommandOptionData[]} [options] Options for the command\n   * @property {boolean} [defaultPermission] Whether the command is enabled by default when the app is added to a guild\n   */\n\n  /**\n   * An option for an application command or subcommand.\n   * <info>In addition to the listed properties, when used as a parameter,\n   * API style `snake_case` properties can be used for compatibility with generators like `@discordjs/builders`.</info>\n   * <warn>Note that providing a value for the `camelCase` counterpart for any `snake_case` property\n   * will discard the provided `snake_case` property.</warn>\n   * @typedef {Object} ApplicationCommandOptionData\n   * @property {ApplicationCommandOptionType|number} type The type of the option\n   * @property {string} name The name of the option\n   * @property {string} description The description of the option\n   * @property {boolean} [autocomplete] Whether the option is an autocomplete option\n   * @property {boolean} [required] Whether the option is required\n   * @property {ApplicationCommandOptionChoice[]} [choices] The choices of the option for the user to pick from\n   * @property {ApplicationCommandOptionData[]} [options] Additional options if this option is a subcommand (group)\n   * @property {ChannelType[]|number[]} [channelTypes] When the option type is channel,\n   * the allowed types of channels that can be selected\n   * @property {number} [minValue] The minimum value for an `INTEGER` or `NUMBER` option\n   * @property {number} [maxValue] The maximum value for an `INTEGER` or `NUMBER` option\n   */\n\n  /**\n   * Edits this application command.\n   * @param {ApplicationCommandData} data The data to update the command with\n   * @returns {Promise<ApplicationCommand>}\n   * @example\n   * // Edit the description of this command\n   * command.edit({\n   *   description: 'New description',\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  edit(data) {\n    return this.manager.edit(this, data, this.guildId);\n  }\n\n  /**\n   * Edits the name of this ApplicationCommand\n   * @param {string} name The new name of the command\n   * @returns {Promise<ApplicationCommand>}\n   */\n  setName(name) {\n    return this.edit({ name });\n  }\n\n  /**\n   * Edits the description of this ApplicationCommand\n   * @param {string} description The new description of the command\n   * @returns {Promise<ApplicationCommand>}\n   */\n  setDescription(description) {\n    return this.edit({ description });\n  }\n\n  /**\n   * Edits the default permission of this ApplicationCommand\n   * @param {boolean} [defaultPermission=true] The default permission for this command\n   * @returns {Promise<ApplicationCommand>}\n   */\n  setDefaultPermission(defaultPermission = true) {\n    return this.edit({ defaultPermission });\n  }\n\n  /**\n   * Edits the options of this ApplicationCommand\n   * @param {ApplicationCommandOptionData[]} options The options to set for this command\n   * @returns {Promise<ApplicationCommand>}\n   */\n  setOptions(options) {\n    return this.edit({ options });\n  }\n\n  /**\n   * Deletes this command.\n   * @returns {Promise<ApplicationCommand>}\n   * @example\n   * // Delete this command\n   * command.delete()\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  delete() {\n    return this.manager.delete(this, this.guildId);\n  }\n\n  /**\n   * Whether this command equals another command. It compares all properties, so for most operations\n   * it is advisable to just compare `command.id === command2.id` as it is much faster and is often\n   * what most users need.\n   * @param {ApplicationCommand|ApplicationCommandData|APIApplicationCommand} command The command to compare with\n   * @param {boolean} [enforceOptionOrder=false] Whether to strictly check that options and choices are in the same\n   * order in the array <info>The client may not always respect this ordering!</info>\n   * @returns {boolean}\n   */\n  equals(command, enforceOptionOrder = false) {\n    // If given an id, check if the id matches\n    if (command.id && this.id !== command.id) return false;\n\n    // Check top level parameters\n    const commandType = typeof command.type === 'string' ? command.type : ApplicationCommandTypes[command.type];\n    if (\n      command.name !== this.name ||\n      ('description' in command && command.description !== this.description) ||\n      ('version' in command && command.version !== this.version) ||\n      ('autocomplete' in command && command.autocomplete !== this.autocomplete) ||\n      (commandType && commandType !== this.type) ||\n      // Future proof for options being nullable\n      // TODO: remove ?? 0 on each when nullable\n      (command.options?.length ?? 0) !== (this.options?.length ?? 0) ||\n      (command.defaultPermission ?? command.default_permission ?? true) !== this.defaultPermission\n    ) {\n      return false;\n    }\n\n    if (command.options) {\n      return this.constructor.optionsEqual(this.options, command.options, enforceOptionOrder);\n    }\n    return true;\n  }\n\n  /**\n   * Recursively checks that all options for an {@link ApplicationCommand} are equal to the provided options.\n   * In most cases it is better to compare using {@link ApplicationCommand#equals}\n   * @param {ApplicationCommandOptionData[]} existing The options on the existing command,\n   * should be {@link ApplicationCommand#options}\n   * @param {ApplicationCommandOptionData[]|APIApplicationCommandOption[]} options The options to compare against\n   * @param {boolean} [enforceOptionOrder=false] Whether to strictly check that options and choices are in the same\n   * order in the array <info>The client may not always respect this ordering!</info>\n   * @returns {boolean}\n   */\n  static optionsEqual(existing, options, enforceOptionOrder = false) {\n    if (existing.length !== options.length) return false;\n    if (enforceOptionOrder) {\n      return existing.every((option, index) => this._optionEquals(option, options[index], enforceOptionOrder));\n    }\n    const newOptions = new Map(options.map(option => [option.name, option]));\n    for (const option of existing) {\n      const foundOption = newOptions.get(option.name);\n      if (!foundOption || !this._optionEquals(option, foundOption)) return false;\n    }\n    return true;\n  }\n\n  /**\n   * Checks that an option for an {@link ApplicationCommand} is equal to the provided option\n   * In most cases it is better to compare using {@link ApplicationCommand#equals}\n   * @param {ApplicationCommandOptionData} existing The option on the existing command,\n   * should be from {@link ApplicationCommand#options}\n   * @param {ApplicationCommandOptionData|APIApplicationCommandOption} option The option to compare against\n   * @param {boolean} [enforceOptionOrder=false] Whether to strictly check that options or choices are in the same\n   * order in their array <info>The client may not always respect this ordering!</info>\n   * @returns {boolean}\n   * @private\n   */\n  static _optionEquals(existing, option, enforceOptionOrder = false) {\n    const optionType = typeof option.type === 'string' ? option.type : ApplicationCommandOptionTypes[option.type];\n    if (\n      option.name !== existing.name ||\n      optionType !== existing.type ||\n      option.description !== existing.description ||\n      option.autocomplete !== existing.autocomplete ||\n      (option.required ?? (['SUB_COMMAND', 'SUB_COMMAND_GROUP'].includes(optionType) ? undefined : false)) !==\n        existing.required ||\n      option.choices?.length !== existing.choices?.length ||\n      option.options?.length !== existing.options?.length ||\n      (option.channelTypes ?? option.channel_types)?.length !== existing.channelTypes?.length ||\n      (option.minValue ?? option.min_value) !== existing.minValue ||\n      (option.maxValue ?? option.max_value) !== existing.maxValue\n    ) {\n      return false;\n    }\n\n    if (existing.choices) {\n      if (\n        enforceOptionOrder &&\n        !existing.choices.every(\n          (choice, index) => choice.name === option.choices[index].name && choice.value === option.choices[index].value,\n        )\n      ) {\n        return false;\n      }\n      if (!enforceOptionOrder) {\n        const newChoices = new Map(option.choices.map(choice => [choice.name, choice]));\n        for (const choice of existing.choices) {\n          const foundChoice = newChoices.get(choice.name);\n          if (!foundChoice || foundChoice.value !== choice.value) return false;\n        }\n      }\n    }\n\n    if (existing.channelTypes) {\n      const newTypes = (option.channelTypes ?? option.channel_types).map(type =>\n        typeof type === 'number' ? ChannelTypes[type] : type,\n      );\n      for (const type of existing.channelTypes) {\n        if (!newTypes.includes(type)) return false;\n      }\n    }\n\n    if (existing.options) {\n      return this.optionsEqual(existing.options, option.options, enforceOptionOrder);\n    }\n    return true;\n  }\n\n  /**\n   * An option for an application command or subcommand.\n   * @typedef {Object} ApplicationCommandOption\n   * @property {ApplicationCommandOptionType} type The type of the option\n   * @property {string} name The name of the option\n   * @property {string} description The description of the option\n   * @property {boolean} [required] Whether the option is required\n   * @property {boolean} [autocomplete] Whether the option is an autocomplete option\n   * @property {ApplicationCommandOptionChoice[]} [choices] The choices of the option for the user to pick from\n   * @property {ApplicationCommandOption[]} [options] Additional options if this option is a subcommand (group)\n   * @property {ChannelType[]} [channelTypes] When the option type is channel,\n   * the allowed types of channels that can be selected\n   * @property {number} [minValue] The minimum value for an `INTEGER` or `NUMBER` option\n   * @property {number} [maxValue] The maximum value for an `INTEGER` or `NUMBER` option\n   */\n\n  /**\n   * A choice for an application command option.\n   * @typedef {Object} ApplicationCommandOptionChoice\n   * @property {string} name The name of the choice\n   * @property {string|number} value The value of the choice\n   */\n\n  /**\n   * Transforms an {@link ApplicationCommandOptionData} object into something that can be used with the API.\n   * @param {ApplicationCommandOptionData} option The option to transform\n   * @param {boolean} [received] Whether this option has been received from Discord\n   * @returns {APIApplicationCommandOption}\n   * @private\n   */\n  static transformOption(option, received) {\n    const stringType = typeof option.type === 'string' ? option.type : ApplicationCommandOptionTypes[option.type];\n    const channelTypesKey = received ? 'channelTypes' : 'channel_types';\n    const minValueKey = received ? 'minValue' : 'min_value';\n    const maxValueKey = received ? 'maxValue' : 'max_value';\n    return {\n      type: typeof option.type === 'number' && !received ? option.type : ApplicationCommandOptionTypes[option.type],\n      name: option.name,\n      description: option.description,\n      required:\n        option.required ?? (stringType === 'SUB_COMMAND' || stringType === 'SUB_COMMAND_GROUP' ? undefined : false),\n      autocomplete: option.autocomplete,\n      choices: option.choices,\n      options: option.options?.map(o => this.transformOption(o, received)),\n      [channelTypesKey]: received\n        ? option.channel_types?.map(type => ChannelTypes[type])\n        : option.channelTypes?.map(type => (typeof type === 'string' ? ChannelTypes[type] : type)) ??\n          // When transforming to API data, accept API data\n          option.channel_types,\n      [minValueKey]: option.minValue ?? option.min_value,\n      [maxValueKey]: option.maxValue ?? option.max_value,\n    };\n  }\n}\n\nmodule.exports = ApplicationCommand;\n\n/* eslint-disable max-len */\n/**\n * @external APIApplicationCommand\n * @see {@link https://discord.com/developers/docs/interactions/application-commands#application-command-object-application-command-structure}\n */\n\n/**\n * @external APIApplicationCommandOption\n * @see {@link https://discord.com/developers/docs/interactions/application-commands#application-command-object-application-command-option-structure}\n */\n"],"mappings":"AAAA;;AAEA,MAAMA,IAAI,GAAGC,OAAO,CAAC,QAAD,CAApB;;AACA,MAAMC,oCAAoC,GAAGD,OAAO,CAAC,kDAAD,CAApD;;AACA,MAAM;EAAEE,6BAAF;EAAiCC,uBAAjC;EAA0DC;AAA1D,IAA2EJ,OAAO,CAAC,mBAAD,CAAxF;;AACA,MAAMK,aAAa,GAAGL,OAAO,CAAC,uBAAD,CAA7B;AAEA;AACA;AACA;AACA;;;AACA,MAAMM,kBAAN,SAAiCP,IAAjC,CAAsC;EACpCQ,WAAW,CAACC,MAAD,EAASC,IAAT,EAAeC,KAAf,EAAsBC,OAAtB,EAA+B;IACxC,MAAMH,MAAN;IAEA;AACJ;AACA;AACA;;IACI,KAAKI,EAAL,GAAUH,IAAI,CAACG,EAAf;IAEA;AACJ;AACA;AACA;;IACI,KAAKC,aAAL,GAAqBJ,IAAI,CAACK,cAA1B;IAEA;AACJ;AACA;AACA;;IACI,KAAKJ,KAAL,GAAaA,KAAK,IAAI,IAAtB;IAEA;AACJ;AACA;AACA;AACA;;IACI,KAAKC,OAAL,GAAeD,KAAK,EAAEE,EAAP,IAAaD,OAAb,IAAwB,IAAvC;IAEA;AACJ;AACA;AACA;;IACI,KAAKI,WAAL,GAAmB,IAAId,oCAAJ,CAAyC,IAAzC,CAAnB;IAEA;AACJ;AACA;AACA;;IACI,KAAKe,IAAL,GAAYb,uBAAuB,CAACM,IAAI,CAACO,IAAN,CAAnC;;IAEA,KAAKC,MAAL,CAAYR,IAAZ;EACD;;EAEDQ,MAAM,CAACR,IAAD,EAAO;IACX,IAAI,UAAUA,IAAd,EAAoB;MAClB;AACN;AACA;AACA;MACM,KAAKS,IAAL,GAAYT,IAAI,CAACS,IAAjB;IACD;;IAED,IAAI,iBAAiBT,IAArB,EAA2B;MACzB;AACN;AACA;AACA;MACM,KAAKU,WAAL,GAAmBV,IAAI,CAACU,WAAxB;IACD;;IAED,IAAI,aAAaV,IAAjB,EAAuB;MACrB;AACN;AACA;AACA;MACM,KAAKW,OAAL,GAAeX,IAAI,CAACW,OAAL,CAAaC,GAAb,CAAiBC,CAAC,IAAI,KAAKf,WAAL,CAAiBgB,eAAjB,CAAiCD,CAAjC,EAAoC,IAApC,CAAtB,CAAf;IACD,CAND,MAMO;MACL,KAAKF,OAAL,KAAiB,EAAjB;IACD;;IAED,IAAI,wBAAwBX,IAA5B,EAAkC;MAChC;AACN;AACA;AACA;MACM,KAAKe,iBAAL,GAAyBf,IAAI,CAACgB,kBAA9B;IACD;;IAED,IAAI,aAAahB,IAAjB,EAAuB;MACrB;AACN;AACA;AACA;MACM,KAAKiB,OAAL,GAAejB,IAAI,CAACiB,OAApB;IACD;EACF;EAED;AACF;AACA;AACA;AACA;;;EACsB,IAAhBC,gBAAgB,GAAG;IACrB,OAAOtB,aAAa,CAACuB,aAAd,CAA4B,KAAKhB,EAAjC,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;;;EACe,IAATiB,SAAS,GAAG;IACd,OAAO,IAAIC,IAAJ,CAAS,KAAKH,gBAAd,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;;;EACa,IAAPI,OAAO,GAAG;IACZ,OAAO,CAAC,KAAKrB,KAAL,IAAc,KAAKF,MAAL,CAAYwB,WAA3B,EAAwCC,QAA/C;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEC,IAAI,CAACzB,IAAD,EAAO;IACT,OAAO,KAAKsB,OAAL,CAAaG,IAAb,CAAkB,IAAlB,EAAwBzB,IAAxB,EAA8B,KAAKE,OAAnC,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;;;EACEwB,OAAO,CAACjB,IAAD,EAAO;IACZ,OAAO,KAAKgB,IAAL,CAAU;MAAEhB;IAAF,CAAV,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;;;EACEkB,cAAc,CAACjB,WAAD,EAAc;IAC1B,OAAO,KAAKe,IAAL,CAAU;MAAEf;IAAF,CAAV,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;;;EACEkB,oBAAoB,GAA2B;IAAA,IAA1Bb,iBAA0B,uEAAN,IAAM;I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"},"metadata":{},"sourceType":"script"}