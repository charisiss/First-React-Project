{"ast":null,"code":"'use strict';\n/* eslint-disable import/order */\n\nconst MessageCollector = require('../MessageCollector');\n\nconst MessagePayload = require('../MessagePayload');\n\nconst SnowflakeUtil = require('../../util/SnowflakeUtil');\n\nconst {\n  Collection\n} = require('@discordjs/collection');\n\nconst {\n  InteractionTypes\n} = require('../../util/Constants');\n\nconst {\n  TypeError,\n  Error\n} = require('../../errors');\n\nconst InteractionCollector = require('../InteractionCollector');\n/**\n * Interface for classes that have text-channel-like features.\n * @interface\n */\n\n\nclass TextBasedChannel {\n  constructor() {\n    /**\n     * A manager of the messages sent to this channel\n     * @type {MessageManager}\n     */\n    this.messages = new MessageManager(this);\n    /**\n     * The channel's last message id, if one was sent\n     * @type {?Snowflake}\n     */\n\n    this.lastMessageId = null;\n    /**\n     * The timestamp when the last pinned message was pinned, if there was one\n     * @type {?number}\n     */\n\n    this.lastPinTimestamp = null;\n  }\n  /**\n   * The Message object of the last message in the channel, if one was sent\n   * @type {?Message}\n   * @readonly\n   */\n\n\n  get lastMessage() {\n    return this.messages.resolve(this.lastMessageId);\n  }\n  /**\n   * The date when the last pinned message was pinned, if there was one\n   * @type {?Date}\n   * @readonly\n   */\n\n\n  get lastPinAt() {\n    return this.lastPinTimestamp ? new Date(this.lastPinTimestamp) : null;\n  }\n  /**\n   * Base options provided when sending.\n   * @typedef {Object} BaseMessageOptions\n   * @property {boolean} [tts=false] Whether or not the message should be spoken aloud\n   * @property {string} [nonce=''] The nonce for the message\n   * @property {string} [content=''] The content for the message\n   * @property {MessageEmbed[]|APIEmbed[]} [embeds] The embeds for the message\n   * (see [here](https://discord.com/developers/docs/resources/channel#embed-object) for more details)\n   * @property {MessageMentionOptions} [allowedMentions] Which mentions should be parsed from the message content\n   * (see [here](https://discord.com/developers/docs/resources/channel#allowed-mentions-object) for more details)\n   * @property {FileOptions[]|BufferResolvable[]|MessageAttachment[]} [files] Files to send with the message\n   * @property {MessageActionRow[]|MessageActionRowOptions[]} [components]\n   * Action rows containing interactive components for the message (buttons, select menus)\n   * @property {MessageAttachment[]} [attachments] Attachments to send in the message\n   */\n\n  /**\n   * Options provided when sending or editing a message.\n   * @typedef {BaseMessageOptions} MessageOptions\n   * @property {ReplyOptions} [reply] The options for replying to a message\n   * @property {StickerResolvable[]} [stickers=[]] Stickers to send in the message\n   */\n\n  /**\n   * Options provided to control parsing of mentions by Discord\n   * @typedef {Object} MessageMentionOptions\n   * @property {MessageMentionTypes[]} [parse] Types of mentions to be parsed\n   * @property {Snowflake[]} [users] Snowflakes of Users to be parsed as mentions\n   * @property {Snowflake[]} [roles] Snowflakes of Roles to be parsed as mentions\n   * @property {boolean} [repliedUser=true] Whether the author of the Message being replied to should be pinged\n   */\n\n  /**\n   * Types of mentions to enable in MessageMentionOptions.\n   * - `roles`\n   * - `users`\n   * - `everyone`\n   * @typedef {string} MessageMentionTypes\n   */\n\n  /**\n   * @typedef {Object} FileOptions\n   * @property {BufferResolvable} attachment File to attach\n   * @property {string} [name='file.jpg'] Filename of the attachment\n   * @property {string} description The description of the file\n   */\n\n  /**\n   * Options for sending a message with a reply.\n   * @typedef {Object} ReplyOptions\n   * @property {MessageResolvable} messageReference The message to reply to (must be in the same channel and not system)\n   * @property {boolean} [failIfNotExists=true] Whether to error if the referenced message\n   * does not exist (creates a standard message in this case when false)\n   */\n\n  /**\n   * Sends a message to this channel.\n   * @param {string|MessagePayload|MessageOptions} options The options to provide\n   * @returns {Promise<Message>}\n   * @example\n   * // Send a basic message\n   * channel.send('hello!')\n   *   .then(message => console.log(`Sent message: ${message.content}`))\n   *   .catch(console.error);\n   * @example\n   * // Send a remote file\n   * channel.send({\n   *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send a local file\n   * channel.send({\n   *   files: [{\n   *     attachment: 'entire/path/to/file.jpg',\n   *     name: 'file.jpg'\n   *     description: 'A description of the file'\n   *   }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send an embed with a local image inside\n   * channel.send({\n   *   content: 'This is an embed',\n   *   embeds: [\n   *     {\n   *       thumbnail: {\n   *         url: 'attachment://file.jpg'\n   *       }\n   *     }\n   *   ],\n   *   files: [{\n   *     attachment: 'entire/path/to/file.jpg',\n   *     name: 'file.jpg'\n   *     description: 'A description of the file'\n   *   }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n\n\n  async send(options) {\n    const User = require('../User');\n\n    const {\n      GuildMember\n    } = require('../GuildMember');\n\n    if (this instanceof User || this instanceof GuildMember) {\n      const dm = await this.createDM();\n      return dm.send(options);\n    }\n\n    let messagePayload;\n\n    if (options instanceof MessagePayload) {\n      messagePayload = options.resolveData();\n    } else {\n      messagePayload = MessagePayload.create(this, options).resolveData();\n    }\n\n    const {\n      data,\n      files\n    } = await messagePayload.resolveFiles();\n    const d = await this.client.api.channels[this.id].messages.post({\n      data,\n      files\n    });\n    return this.messages.cache.get(d.id) ?? this.messages._add(d);\n  }\n  /**\n   * Sends a typing indicator in the channel.\n   * @returns {Promise<void>} Resolves upon the typing status being sent\n   * @example\n   * // Start typing in a channel\n   * channel.sendTyping();\n   */\n\n\n  async sendTyping() {\n    await this.client.api.channels(this.id).typing.post();\n  }\n  /**\n   * Creates a Message Collector.\n   * @param {MessageCollectorOptions} [options={}] The options to pass to the collector\n   * @returns {MessageCollector}\n   * @example\n   * // Create a message collector\n   * const filter = m => m.content.includes('discord');\n   * const collector = channel.createMessageCollector({ filter, time: 15_000 });\n   * collector.on('collect', m => console.log(`Collected ${m.content}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n\n\n  createMessageCollector() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new MessageCollector(this, options);\n  }\n  /**\n   * An object containing the same properties as CollectorOptions, but a few more:\n   * @typedef {MessageCollectorOptions} AwaitMessagesOptions\n   * @property {string[]} [errors] Stop/end reasons that cause the promise to reject\n   */\n\n  /**\n   * Similar to createMessageCollector but in promise form.\n   * Resolves with a collection of messages that pass the specified filter.\n   * @param {AwaitMessagesOptions} [options={}] Optional options to pass to the internal collector\n   * @returns {Promise<Collection<Snowflake, Message>>}\n   * @example\n   * // Await !vote messages\n   * const filter = m => m.content.startsWith('!vote');\n   * // Errors: ['time'] treats ending because of the time limit as an error\n   * channel.awaitMessages({ filter, max: 4, time: 60_000, errors: ['time'] })\n   *   .then(collected => console.log(collected.size))\n   *   .catch(collected => console.log(`After a minute, only ${collected.size} out of 4 voted.`));\n   */\n\n\n  awaitMessages() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new Promise((resolve, reject) => {\n      const collector = this.createMessageCollector(options);\n      collector.once('end', (collection, reason) => {\n        if (options.errors?.includes(reason)) {\n          reject(collection);\n        } else {\n          resolve(collection);\n        }\n      });\n    });\n  }\n  /**\n   * Creates a button interaction collector.\n   * @param {MessageComponentCollectorOptions} [options={}] Options to send to the collector\n   * @returns {InteractionCollector}\n   * @example\n   * // Create a button interaction collector\n   * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';\n   * const collector = channel.createMessageComponentCollector({ filter, time: 15_000 });\n   * collector.on('collect', i => console.log(`Collected ${i.customId}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n\n\n  createMessageComponentCollector() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new InteractionCollector(this.client, { ...options,\n      interactionType: InteractionTypes.MESSAGE_COMPONENT,\n      channel: this\n    });\n  }\n  /**\n   * Collects a single component interaction that passes the filter.\n   * The Promise will reject if the time expires.\n   * @param {AwaitMessageComponentOptions} [options={}] Options to pass to the internal collector\n   * @returns {Promise<MessageComponentInteraction>}\n   * @example\n   * // Collect a message component interaction\n   * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';\n   * channel.awaitMessageComponent({ filter, time: 15_000 })\n   *   .then(interaction => console.log(`${interaction.customId} was clicked!`))\n   *   .catch(console.error);\n   */\n\n\n  awaitMessageComponent() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const _options = { ...options,\n      max: 1\n    };\n    return new Promise((resolve, reject) => {\n      const collector = this.createMessageComponentCollector(_options);\n      collector.once('end', (interactions, reason) => {\n        const interaction = interactions.first();\n        if (interaction) resolve(interaction);else reject(new Error('INTERACTION_COLLECTOR_ERROR', reason));\n      });\n    });\n  }\n  /**\n   * Bulk deletes given messages that are newer than two weeks.\n   * @param {Collection<Snowflake, Message>|MessageResolvable[]|number} messages\n   * Messages or number of messages to delete\n   * @param {boolean} [filterOld=false] Filter messages to remove those which are older than two weeks automatically\n   * @returns {Promise<Collection<Snowflake, Message>>} Returns the deleted messages\n   * @example\n   * // Bulk delete messages\n   * channel.bulkDelete(5)\n   *   .then(messages => console.log(`Bulk deleted ${messages.size} messages`))\n   *   .catch(console.error);\n   */\n\n\n  async bulkDelete(messages) {\n    let filterOld = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (Array.isArray(messages) || messages instanceof Collection) {\n      let messageIds = messages instanceof Collection ? [...messages.keys()] : messages.map(m => m.id ?? m);\n\n      if (filterOld) {\n        messageIds = messageIds.filter(id => Date.now() - SnowflakeUtil.timestampFrom(id) < 1_209_600_000);\n      }\n\n      if (messageIds.length === 0) return new Collection();\n\n      if (messageIds.length === 1) {\n        await this.client.api.channels(this.id).messages(messageIds[0]).delete();\n        const message = this.client.actions.MessageDelete.getMessage({\n          message_id: messageIds[0]\n        }, this);\n        return message ? new Collection([[message.id, message]]) : new Collection();\n      }\n\n      await this.client.api.channels[this.id].messages['bulk-delete'].post({\n        data: {\n          messages: messageIds\n        }\n      });\n      return messageIds.reduce((col, id) => col.set(id, this.client.actions.MessageDeleteBulk.getMessage({\n        message_id: id\n      }, this)), new Collection());\n    }\n\n    if (!isNaN(messages)) {\n      const msgs = await this.messages.fetch({\n        limit: messages\n      });\n      return this.bulkDelete(msgs, filterOld);\n    }\n\n    throw new TypeError('MESSAGE_BULK_DELETE_TYPE');\n  }\n\n  static applyToClass(structure) {\n    let full = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let ignore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    const props = ['send'];\n\n    if (full) {\n      props.push('lastMessage', 'lastPinAt', 'bulkDelete', 'sendTyping', 'createMessageCollector', 'awaitMessages', 'createMessageComponentCollector', 'awaitMessageComponent');\n    }\n\n    for (const prop of props) {\n      if (ignore.includes(prop)) continue;\n      Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(TextBasedChannel.prototype, prop));\n    }\n  }\n\n}\n\nmodule.exports = TextBasedChannel; // Fixes Circular\n\nconst MessageManager = require('../../managers/MessageManager');","map":{"version":3,"names":["MessageCollector","require","MessagePayload","SnowflakeUtil","Collection","InteractionTypes","TypeError","Error","InteractionCollector","TextBasedChannel","constructor","messages","MessageManager","lastMessageId","lastPinTimestamp","lastMessage","resolve","lastPinAt","Date","send","options","User","GuildMember","dm","createDM","messagePayload","resolveData","create","data","files","resolveFiles","d","client","api","channels","id","post","cache","get","_add","sendTyping","typing","createMessageCollector","awaitMessages","Promise","reject","collector","once","collection","reason","errors","includes","createMessageComponentCollector","interactionType","MESSAGE_COMPONENT","channel","awaitMessageComponent","_options","max","interactions","interaction","first","bulkDelete","filterOld","Array","isArray","messageIds","keys","map","m","filter","now","timestampFrom","length","delete","message","actions","MessageDelete","getMessage","message_id","reduce","col","set","MessageDeleteBulk","isNaN","msgs","fetch","limit","applyToClass","structure","full","ignore","props","push","prop","Object","defineProperty","prototype","getOwnPropertyDescriptor","module","exports"],"sources":["C:/Users/xsxsam/node_modules/discord.js/src/structures/interfaces/TextBasedChannel.js"],"sourcesContent":["'use strict';\n\n/* eslint-disable import/order */\nconst MessageCollector = require('../MessageCollector');\nconst MessagePayload = require('../MessagePayload');\nconst SnowflakeUtil = require('../../util/SnowflakeUtil');\nconst { Collection } = require('@discordjs/collection');\nconst { InteractionTypes } = require('../../util/Constants');\nconst { TypeError, Error } = require('../../errors');\nconst InteractionCollector = require('../InteractionCollector');\n\n/**\n * Interface for classes that have text-channel-like features.\n * @interface\n */\nclass TextBasedChannel {\n  constructor() {\n    /**\n     * A manager of the messages sent to this channel\n     * @type {MessageManager}\n     */\n    this.messages = new MessageManager(this);\n\n    /**\n     * The channel's last message id, if one was sent\n     * @type {?Snowflake}\n     */\n    this.lastMessageId = null;\n\n    /**\n     * The timestamp when the last pinned message was pinned, if there was one\n     * @type {?number}\n     */\n    this.lastPinTimestamp = null;\n  }\n\n  /**\n   * The Message object of the last message in the channel, if one was sent\n   * @type {?Message}\n   * @readonly\n   */\n  get lastMessage() {\n    return this.messages.resolve(this.lastMessageId);\n  }\n\n  /**\n   * The date when the last pinned message was pinned, if there was one\n   * @type {?Date}\n   * @readonly\n   */\n  get lastPinAt() {\n    return this.lastPinTimestamp ? new Date(this.lastPinTimestamp) : null;\n  }\n\n  /**\n   * Base options provided when sending.\n   * @typedef {Object} BaseMessageOptions\n   * @property {boolean} [tts=false] Whether or not the message should be spoken aloud\n   * @property {string} [nonce=''] The nonce for the message\n   * @property {string} [content=''] The content for the message\n   * @property {MessageEmbed[]|APIEmbed[]} [embeds] The embeds for the message\n   * (see [here](https://discord.com/developers/docs/resources/channel#embed-object) for more details)\n   * @property {MessageMentionOptions} [allowedMentions] Which mentions should be parsed from the message content\n   * (see [here](https://discord.com/developers/docs/resources/channel#allowed-mentions-object) for more details)\n   * @property {FileOptions[]|BufferResolvable[]|MessageAttachment[]} [files] Files to send with the message\n   * @property {MessageActionRow[]|MessageActionRowOptions[]} [components]\n   * Action rows containing interactive components for the message (buttons, select menus)\n   * @property {MessageAttachment[]} [attachments] Attachments to send in the message\n   */\n\n  /**\n   * Options provided when sending or editing a message.\n   * @typedef {BaseMessageOptions} MessageOptions\n   * @property {ReplyOptions} [reply] The options for replying to a message\n   * @property {StickerResolvable[]} [stickers=[]] Stickers to send in the message\n   */\n\n  /**\n   * Options provided to control parsing of mentions by Discord\n   * @typedef {Object} MessageMentionOptions\n   * @property {MessageMentionTypes[]} [parse] Types of mentions to be parsed\n   * @property {Snowflake[]} [users] Snowflakes of Users to be parsed as mentions\n   * @property {Snowflake[]} [roles] Snowflakes of Roles to be parsed as mentions\n   * @property {boolean} [repliedUser=true] Whether the author of the Message being replied to should be pinged\n   */\n\n  /**\n   * Types of mentions to enable in MessageMentionOptions.\n   * - `roles`\n   * - `users`\n   * - `everyone`\n   * @typedef {string} MessageMentionTypes\n   */\n\n  /**\n   * @typedef {Object} FileOptions\n   * @property {BufferResolvable} attachment File to attach\n   * @property {string} [name='file.jpg'] Filename of the attachment\n   * @property {string} description The description of the file\n   */\n\n  /**\n   * Options for sending a message with a reply.\n   * @typedef {Object} ReplyOptions\n   * @property {MessageResolvable} messageReference The message to reply to (must be in the same channel and not system)\n   * @property {boolean} [failIfNotExists=true] Whether to error if the referenced message\n   * does not exist (creates a standard message in this case when false)\n   */\n\n  /**\n   * Sends a message to this channel.\n   * @param {string|MessagePayload|MessageOptions} options The options to provide\n   * @returns {Promise<Message>}\n   * @example\n   * // Send a basic message\n   * channel.send('hello!')\n   *   .then(message => console.log(`Sent message: ${message.content}`))\n   *   .catch(console.error);\n   * @example\n   * // Send a remote file\n   * channel.send({\n   *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send a local file\n   * channel.send({\n   *   files: [{\n   *     attachment: 'entire/path/to/file.jpg',\n   *     name: 'file.jpg'\n   *     description: 'A description of the file'\n   *   }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send an embed with a local image inside\n   * channel.send({\n   *   content: 'This is an embed',\n   *   embeds: [\n   *     {\n   *       thumbnail: {\n   *         url: 'attachment://file.jpg'\n   *       }\n   *     }\n   *   ],\n   *   files: [{\n   *     attachment: 'entire/path/to/file.jpg',\n   *     name: 'file.jpg'\n   *     description: 'A description of the file'\n   *   }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async send(options) {\n    const User = require('../User');\n    const { GuildMember } = require('../GuildMember');\n\n    if (this instanceof User || this instanceof GuildMember) {\n      const dm = await this.createDM();\n      return dm.send(options);\n    }\n\n    let messagePayload;\n\n    if (options instanceof MessagePayload) {\n      messagePayload = options.resolveData();\n    } else {\n      messagePayload = MessagePayload.create(this, options).resolveData();\n    }\n\n    const { data, files } = await messagePayload.resolveFiles();\n    const d = await this.client.api.channels[this.id].messages.post({ data, files });\n\n    return this.messages.cache.get(d.id) ?? this.messages._add(d);\n  }\n\n  /**\n   * Sends a typing indicator in the channel.\n   * @returns {Promise<void>} Resolves upon the typing status being sent\n   * @example\n   * // Start typing in a channel\n   * channel.sendTyping();\n   */\n  async sendTyping() {\n    await this.client.api.channels(this.id).typing.post();\n  }\n\n  /**\n   * Creates a Message Collector.\n   * @param {MessageCollectorOptions} [options={}] The options to pass to the collector\n   * @returns {MessageCollector}\n   * @example\n   * // Create a message collector\n   * const filter = m => m.content.includes('discord');\n   * const collector = channel.createMessageCollector({ filter, time: 15_000 });\n   * collector.on('collect', m => console.log(`Collected ${m.content}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n  createMessageCollector(options = {}) {\n    return new MessageCollector(this, options);\n  }\n\n  /**\n   * An object containing the same properties as CollectorOptions, but a few more:\n   * @typedef {MessageCollectorOptions} AwaitMessagesOptions\n   * @property {string[]} [errors] Stop/end reasons that cause the promise to reject\n   */\n\n  /**\n   * Similar to createMessageCollector but in promise form.\n   * Resolves with a collection of messages that pass the specified filter.\n   * @param {AwaitMessagesOptions} [options={}] Optional options to pass to the internal collector\n   * @returns {Promise<Collection<Snowflake, Message>>}\n   * @example\n   * // Await !vote messages\n   * const filter = m => m.content.startsWith('!vote');\n   * // Errors: ['time'] treats ending because of the time limit as an error\n   * channel.awaitMessages({ filter, max: 4, time: 60_000, errors: ['time'] })\n   *   .then(collected => console.log(collected.size))\n   *   .catch(collected => console.log(`After a minute, only ${collected.size} out of 4 voted.`));\n   */\n  awaitMessages(options = {}) {\n    return new Promise((resolve, reject) => {\n      const collector = this.createMessageCollector(options);\n      collector.once('end', (collection, reason) => {\n        if (options.errors?.includes(reason)) {\n          reject(collection);\n        } else {\n          resolve(collection);\n        }\n      });\n    });\n  }\n\n  /**\n   * Creates a button interaction collector.\n   * @param {MessageComponentCollectorOptions} [options={}] Options to send to the collector\n   * @returns {InteractionCollector}\n   * @example\n   * // Create a button interaction collector\n   * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';\n   * const collector = channel.createMessageComponentCollector({ filter, time: 15_000 });\n   * collector.on('collect', i => console.log(`Collected ${i.customId}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n  createMessageComponentCollector(options = {}) {\n    return new InteractionCollector(this.client, {\n      ...options,\n      interactionType: InteractionTypes.MESSAGE_COMPONENT,\n      channel: this,\n    });\n  }\n\n  /**\n   * Collects a single component interaction that passes the filter.\n   * The Promise will reject if the time expires.\n   * @param {AwaitMessageComponentOptions} [options={}] Options to pass to the internal collector\n   * @returns {Promise<MessageComponentInteraction>}\n   * @example\n   * // Collect a message component interaction\n   * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';\n   * channel.awaitMessageComponent({ filter, time: 15_000 })\n   *   .then(interaction => console.log(`${interaction.customId} was clicked!`))\n   *   .catch(console.error);\n   */\n  awaitMessageComponent(options = {}) {\n    const _options = { ...options, max: 1 };\n    return new Promise((resolve, reject) => {\n      const collector = this.createMessageComponentCollector(_options);\n      collector.once('end', (interactions, reason) => {\n        const interaction = interactions.first();\n        if (interaction) resolve(interaction);\n        else reject(new Error('INTERACTION_COLLECTOR_ERROR', reason));\n      });\n    });\n  }\n\n  /**\n   * Bulk deletes given messages that are newer than two weeks.\n   * @param {Collection<Snowflake, Message>|MessageResolvable[]|number} messages\n   * Messages or number of messages to delete\n   * @param {boolean} [filterOld=false] Filter messages to remove those which are older than two weeks automatically\n   * @returns {Promise<Collection<Snowflake, Message>>} Returns the deleted messages\n   * @example\n   * // Bulk delete messages\n   * channel.bulkDelete(5)\n   *   .then(messages => console.log(`Bulk deleted ${messages.size} messages`))\n   *   .catch(console.error);\n   */\n  async bulkDelete(messages, filterOld = false) {\n    if (Array.isArray(messages) || messages instanceof Collection) {\n      let messageIds = messages instanceof Collection ? [...messages.keys()] : messages.map(m => m.id ?? m);\n      if (filterOld) {\n        messageIds = messageIds.filter(id => Date.now() - SnowflakeUtil.timestampFrom(id) < 1_209_600_000);\n      }\n      if (messageIds.length === 0) return new Collection();\n      if (messageIds.length === 1) {\n        await this.client.api.channels(this.id).messages(messageIds[0]).delete();\n        const message = this.client.actions.MessageDelete.getMessage(\n          {\n            message_id: messageIds[0],\n          },\n          this,\n        );\n        return message ? new Collection([[message.id, message]]) : new Collection();\n      }\n      await this.client.api.channels[this.id].messages['bulk-delete'].post({ data: { messages: messageIds } });\n      return messageIds.reduce(\n        (col, id) =>\n          col.set(\n            id,\n            this.client.actions.MessageDeleteBulk.getMessage(\n              {\n                message_id: id,\n              },\n              this,\n            ),\n          ),\n        new Collection(),\n      );\n    }\n    if (!isNaN(messages)) {\n      const msgs = await this.messages.fetch({ limit: messages });\n      return this.bulkDelete(msgs, filterOld);\n    }\n    throw new TypeError('MESSAGE_BULK_DELETE_TYPE');\n  }\n\n  static applyToClass(structure, full = false, ignore = []) {\n    const props = ['send'];\n    if (full) {\n      props.push(\n        'lastMessage',\n        'lastPinAt',\n        'bulkDelete',\n        'sendTyping',\n        'createMessageCollector',\n        'awaitMessages',\n        'createMessageComponentCollector',\n        'awaitMessageComponent',\n      );\n    }\n    for (const prop of props) {\n      if (ignore.includes(prop)) continue;\n      Object.defineProperty(\n        structure.prototype,\n        prop,\n        Object.getOwnPropertyDescriptor(TextBasedChannel.prototype, prop),\n      );\n    }\n  }\n}\n\nmodule.exports = TextBasedChannel;\n\n// Fixes Circular\nconst MessageManager = require('../../managers/MessageManager');\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}